<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="STM32," />










<meta name="description" content="STM32学习的记录">
<meta property="og:type" content="article">
<meta property="og:title" content="STM32学习">
<meta property="og:url" content="http://example.com/2022/04/19/STM32%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="星辰塔">
<meta property="og:description" content="STM32学习的记录">
<meta property="og:locale">
<meta property="article:published_time" content="2022-04-19T05:44:41.000Z">
<meta property="article:modified_time" content="2022-05-30T15:01:24.629Z">
<meta property="article:author" content="风雪归心">
<meta property="article:tag" content="STM32">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/2022/04/19/STM32学习/"/>





  <title>STM32学习 | 星辰塔</title>
  








<meta name="generator" content="Hexo 6.0.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">星辰塔</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Long May The Sun Shine</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/2022/01/26/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99%E7%82%B9/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/19/STM32%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/ying.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星辰塔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">STM32学习</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-04-19T13:44:41+08:00">
                2022-04-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/STM32/" itemprop="url" rel="index">
                    <span itemprop="name">STM32</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          
              <div class="post-description">
                  STM32学习的记录
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="开发板资源"><a href="#开发板资源" class="headerlink" title="开发板资源"></a>开发板资源</h1><p>◆ CPU：STM32F103ZET6，LQFP144，FLASH：512K，SRAM：64K； ◆ 外扩 SPI FLASH：W25Q128，16M 字节<br>◆ 1 个电源指示灯（蓝色）<br>◆ 2 个状态指示灯（DS0：红色，DS1：绿色）<br>◆ 1 个红外接收头，并配备一款小巧的红外遥控器<br>◆ 1 个 EEPROM 芯片，24C02，容量 256 字节<br>◆ 1 个光敏传感器<br>◆ 1 个无线模块接口（可接 NRF24L01/RFID 模块等）<br>◆ 1 路 CAN 接口，采用 TJA1050 芯片<br>◆ 1 路 485 接口，采用 SP3485 芯片<br>◆ 1 路数字温湿度传感器接口，支持 DS18B20 /DHT11 等 ◆ 1 个 ATK 模块接口，支持 ALIENTEK 蓝牙/GPS   模块/MPU6050 模块等<br>◆ 1 个标准的 2.4/2.8/3.5/4.3/7 寸 LCD 接口，支持触摸屏<br>◆ 1 个摄像头模块接口<br>◆ 1 个 OLED 模块接口（与摄像头接口共用）<br>◆ 1 个 USB 串口，可用于程序下载和代码调试（USMART 调试）<br>◆ 1 个 USB SLAVE 接口，用于 USB 通信<br>◆ 1 个有源蜂鸣器<br>◆ 1 个 RS485 选择接口<br>◆ 1 个 CAN/USB 选择接口<br>◆ 1 个串口选择接口<br>◆ 1 个 SD 卡接口（在板子背面，SDIO 接口）<br>◆ 1 个标准的 JTAG/SWD 调试下载口<br>◆ 1 组 AD/DA 组合接口（DAC/ADC/ TPAD） ◆ 1 组 5V 电源供应/接入口<br>◆ 1 组 3.3V 电源供应/接入口<br>◆ 1 个直流电源输入接口（输入电压范围：6~24V） ◆ 1 个启动模式选择配置接口<br>◆ 1 个 RTC 后备电池座，并带电池<br>◆ 1 个复位按钮，可用于复位 MCU 和 LCD<br>◆ 3 个功能按钮，其中 KEY_UP 兼具唤醒功能<br>◆ 1 个电容触摸按键<br>◆ 1 个电源开关，控制整个板的电源<br>◆ 独创的一键下载功能<br>◆ 除晶振占用的 IO 口外，其余所有 IO 口全部引出</p>
<h2 id="1-WIRELESS-模块接口"><a href="#1-WIRELESS-模块接口" class="headerlink" title="1. WIRELESS 模块接口"></a>1. WIRELESS 模块接口</h2><pre><code>这是开发板板载的无线模块接口（U2），可以外接 NRF24L01/RFID 等无线模块。从而实现
</code></pre>
<p>无线通信等功能。注意：接 NRF24L01 模块进行无线通信的时候，必须同时有 2 个模块和 2 个<br>板子，才可以测试，单个模块/板子例程是不能测试的。</p>
<h2 id="2-W25Q128-128Mbit-FLASH"><a href="#2-W25Q128-128Mbit-FLASH" class="headerlink" title="2. W25Q128 128Mbit FLASH"></a>2. W25Q128 128Mbit FLASH</h2><pre><code>这是开发板外扩的 SPI FLASH 芯片（U8），容量为 128Mbit，也就是 16M 字节，可用于存
</code></pre>
<p>储字库和其他用户数据，满足大容量数据存储要求。当然如果觉得 16M 字节还不够用，你可以<br>把数据存放在外部 SD 卡。</p>
<h2 id="3-SD卡接口"><a href="#3-SD卡接口" class="headerlink" title="3. SD卡接口"></a>3. SD卡接口</h2><pre><code>这是开发板板载的一个标准 SD 卡接口（SD_CARD），该接口在开发板的背面，采用大 SD
</code></pre>
<p>卡接口（即相机卡，也可以是 TF 卡+卡套的形式），SDIO 方式驱动，有了这个 SD 卡接口，就<br>可以满足海量数据存储的需求。</p>
<h2 id="4-CAN-USB-选择口"><a href="#4-CAN-USB-选择口" class="headerlink" title="4. CAN/USB 选择口"></a>4. CAN/USB 选择口</h2><pre><code>这是一个 CAN/USB 的选择接口（P6），因为 STM32 的 USB 和 CAN 是共用一组 IO（PA11
</code></pre>
<p>和 PA12），所以我们通过跳线帽来选择不同的功能，以实现 USB/CAN 的实验。</p>
<h2 id="5-USB-串口-串口-1"><a href="#5-USB-串口-串口-1" class="headerlink" title="5.USB 串口/串口 1"></a>5.USB 串口/串口 1</h2><pre><code>这是 USB 串口同 STM32F103ZET6 的串口 1 进行连接的接口（P3），标号 RXD 和 TXD 是
</code></pre>
<p>USB 转串口的 2 个数据口（对 CH340G 来说），而 PA9(TXD)和 PA10(RXD)则是 STM32 的串口<br>1 的两个数据口（复用功能下）。他们通过跳线帽对接，就可以和连接在一起了，从而实现 STM32<br>的程序下载以及串口通信。<br>设计成 USB 串口，是出于现在电脑上串口正在消失，尤其是笔记本，几乎清一色的没有串<br>口。所以板载了 USB 串口可以方便大家下载代码和调试。而在板子上并没有直接连接在一起，<br>则是出于使用方便的考虑。这样设计，你可以把 ALIENTEK 精英 STM32F103 当成一个 USB<br>转 TTL 串口，来和其他板子通信，而其他板子的串口，也可以方便地接到 ALIENTEK 精英<br>STM32F103 开发板上。</p>
<h2 id="6-JTAG-SWD-接口"><a href="#6-JTAG-SWD-接口" class="headerlink" title="6. JTAG/SWD 接口"></a>6. JTAG/SWD 接口</h2><pre><code>这是 ALIENTEK 精英 STM32F103 板载的 20 针标准 JTAG 调试口（JTAG），该 JTAG 口直
</code></pre>
<p>接可以和 ULINK、JLINK 或者 STLINK 等调试器（仿真器）连接，同时由于 STM32 支持 SWD<br>调试，这个 JTAG 口也可以用 SWD 模式来连接。<br>    用标准的 JTAG 调试，需要占用 5 个 IO 口，有些时候，可能造成 IO 口不够用，而用 SWD<br>则只需要 2 个 IO 口，大大节约了 IO 数量，但他们达到的效果是一样的，所以我们强烈建议仿<br>真器使用 SWD 模式！</p>
<h2 id="7-24C02-EEPROM"><a href="#7-24C02-EEPROM" class="headerlink" title="7. 24C02 EEPROM"></a>7. 24C02 EEPROM</h2><pre><code>这是开发板板载的 EEPROM 芯片（U9），容量为 2Kb，也就是 256 字节。用于存储一些掉
</code></pre>
<p>电不能丢失的重要数据，比如系统设置的一些参数/触摸屏校准数据等。有了这个就可以方便的<br>实现掉电数据保存。</p>
<h2 id="8-USB-SLAVE"><a href="#8-USB-SLAVE" class="headerlink" title="8. USB SLAVE"></a>8. USB SLAVE</h2><pre><code>这是开发板板载的一个 MiniUSB 头（USB_SLAVE），用于 USB 从机（SLAVE）通信，一
</code></pre>
<p>般用于 STM32 与电脑的 USB 通信。通过此 MiniUSB 头，开发板就可以和电脑进行 USB 通信<br>了。<br>    开发板总共板载了 2 个 MiniUSB 头，一个（USB_232）用于 USB 转串口，连接 CH340G<br>芯片；另外一个（USB_SLAVE）用于 STM32 内带的 USB。同时开发板可以通过此 MiniUSB<br>头供电，板载两个 MiniUSB 头（不共用），主要是考虑了使用的方便性，以及可以给板子提供<br>更大的电流（两个 USB 都接上）这两个因素。</p>
<h2 id="9-USB-转串口"><a href="#9-USB-转串口" class="headerlink" title="9. USB 转串口"></a>9. USB 转串口</h2><pre><code>这是开发板板载的另外一个 MiniUSB 头（USB_232），用于 USB 连接 CH340G 芯片，从而
</code></pre>
<p>实现 USB 转 TTL 串口。同时，此 MiniUSB 接头也是开发板电源的主要提供口。</p>
<h2 id="10-后备电池接口"><a href="#10-后备电池接口" class="headerlink" title="10. 后备电池接口"></a>10. 后备电池接口</h2><pre><code>这是 STM32 后备区域的供电接口(BAT)，可安装 CR1220 电池（默认安装了），可以用来给
</code></pre>
<p>STM32 的后备区域提供能量，在外部电源断电的时候，维持后备区域数据的存储，以及 RTC<br>的运行。</p>
<h2 id="11-OLED-摄像头模块接口"><a href="#11-OLED-摄像头模块接口" class="headerlink" title="11. OLED/摄像头模块接口"></a>11. OLED/摄像头模块接口</h2><pre><code>这是开发板板载的一个 OLED/摄像头模块接口（P4），如果是 OLED 模块，靠左插即可（右
</code></pre>
<p>边两个孔位悬空）。如果是摄像头模块（ALIENTEK 提供），则刚好插满。通过这个接口，可以<br>分别连接 2 种外部模块，从而实现相关实验。</p>
<h2 id="12-有源蜂鸣器"><a href="#12-有源蜂鸣器" class="headerlink" title="12. 有源蜂鸣器"></a>12. 有源蜂鸣器</h2><pre><code>这是开发板的板载蜂鸣器（BEEP），可以实现简单的报警/闹铃等功能。
</code></pre>
<h2 id="13-红外接收器"><a href="#13-红外接收器" class="headerlink" title="13. 红外接收器"></a>13. 红外接收器</h2><pre><code>这是开发板的红外接收头（U6），可以实现红外遥控功能，通过这个接收头，可以接受市
</code></pre>
<p>面常见的各种遥控器的红外信号，大家甚至可以自己实现万能红外解码。当然，如果应用得当，<br>该接收头也可以用来传输数据。</p>
<h2 id="14-DS18B20-DHT11-接口"><a href="#14-DS18B20-DHT11-接口" class="headerlink" title="14. DS18B20/DHT11 接口"></a>14. DS18B20/DHT11 接口</h2><pre><code>这是开发板的一个复用接口（U4），该接口由 4 个镀金排孔组成，可以用来接
</code></pre>
<p>DS18B20/DS1820 等数字温度传感器。也可以用来接 DHT11 这样的数字温湿度传感器。实现一<br>个接口，2 个功能。不用的时候，大家可以拆下上面的传感器，放到其他地方去用，使用上是<br>十分方便灵活的。</p>
<h2 id="15-2-个-LED"><a href="#15-2-个-LED" class="headerlink" title="15. 2 个 LED"></a>15. 2 个 LED</h2><pre><code>这是开发板板载的两个 LED 灯（DS0 和 DS1），DS0 是红色的，DS1 是绿色的，主要是方
</code></pre>
<p>便大家识别。这里提醒大家不要停留在 51 跑马灯的思维，搞这么多灯，除了浪费 IO 口，实在<br>是想不出其他什么优点。<br>我们一般的应用 2 个 LED 足够了，在调试代码的时候，使用 LED 来指示程序状态，是非<br>常不错的一个辅助调试方法。精英 STM32F103 几乎每个实例都使用了 LED 来指示程序的运行<br>状态。</p>
<h2 id="16-启动选择端口"><a href="#16-启动选择端口" class="headerlink" title="16. 启动选择端口"></a>16. 启动选择端口</h2><pre><code>这是开发板板载的启动模式选择端口（BOOT），STM32 有 BOOT0（B0）和 BOOT1（B1）
</code></pre>
<p>两个启动选择引脚，用于选择复位后 STM32 的启动模式，作为开发板，这两个是必须的。在<br>开发板上，我们通过跳线帽选择 STM32 的启动模式。</p>
<h2 id="17-触摸按钮"><a href="#17-触摸按钮" class="headerlink" title="17. 触摸按钮"></a>17. 触摸按钮</h2><pre><code>这是开发板板载的一个电容触摸输入按键（TPAD），利用电容充放电原理，实现触摸按键
</code></pre>
<p>检测。</p>
<h2 id="18-电源指示灯"><a href="#18-电源指示灯" class="headerlink" title="18. 电源指示灯"></a>18. 电源指示灯</h2><pre><code>这是开发板板载的一颗蓝色的 LED 灯（PWR），用于指示电源状态。在电源开启的时候（通
</code></pre>
<p>过板上的电源开关控制），该灯会亮，否则不亮。通过这个 LED，可以判断开发板的上电情况。</p>
<h2 id="19-复位按钮"><a href="#19-复位按钮" class="headerlink" title="19. 复位按钮"></a>19. 复位按钮</h2><pre><code>这是开发板板载的复位按键（RESET），用于复位 STM32，还具有复位液晶的功能，因为
</code></pre>
<p>液晶模块的复位引脚和 STM32 的复位引脚是连接在一起的，当按下该键的时候，STM32 和液<br>晶一并被复位。</p>
<h2 id="20-3个按键"><a href="#20-3个按键" class="headerlink" title="20. 3个按键"></a>20. 3个按键</h2><pre><code>这是开发板板载的 3 个机械式输入按键（KEY0、KEY1 和 KEY_UP），其中 KEY_UP 具有
</code></pre>
<p>唤醒功能，该按键连接到 STM32 的 WAKE_UP（PA0）引脚，可用于待机模式下的唤醒，在不<br>使用唤醒功能的时候，也可以做为普通按键输入使用。<br>    其他 2 个是普通按键，可以用于人机交互的输入，这 2 个按键是直接连接在 STM32 的 IO<br>口上的。这里注意 KEY_UP 是高电平有效，而 KEY0 和 KEY1 是低电平有效，大家在使用的时<br>候留意一下。</p>
<h2 id="21-STM32F103ZET6"><a href="#21-STM32F103ZET6" class="headerlink" title="21. STM32F103ZET6"></a>21. STM32F103ZET6</h2><pre><code>这是开发板的核心芯片（U1），型号为：STM32F103ZET6。该芯片具有 64KB SRAM、512KB 
</code></pre>
<p>FLASH、2 个基本定时器、4 个通用定时器、2 个高级定时器、2 个 DMA 控制器（共 12 个通道）、3 个 SPI、2 个 IIC、5 个串口、1 个 USB、1 个 CAN、3 个 12 位 ADC、1 个 12 位 DAC、1 个SDIO 接口、1 个 FSMC 接口以及 112 个通用 IO 口。</p>
<h2 id="22-AD-DA-组合接口"><a href="#22-AD-DA-组合接口" class="headerlink" title="22. AD/DA 组合接口"></a>22. AD/DA 组合接口</h2><pre><code>这是 1 个由 4 个排针组成的一个组合接口（P7）。可以实现 AD 采集、DA 输出和板载电容
</code></pre>
<p>触摸按键（TPAD）检测的功能。</p>
<h2 id="23-ATK-模块接口"><a href="#23-ATK-模块接口" class="headerlink" title="23. ATK 模块接口"></a>23. ATK 模块接口</h2><pre><code>这是开发板板载的一个 ALIENTEK 通用模块接口（U3），目前可以支持 ALIENTEK 开发
</code></pre>
<p>的 GPS 模块、蓝牙模块和 MPU6050 模块等，直接插上对应的模块，就可以进行开发。后续我<br>们将开发更多兼容该接口的其他模块，实现更强大的扩展性能。</p>
<h2 id="24-3-3V-电源输入-输出"><a href="#24-3-3V-电源输入-输出" class="headerlink" title="24. 3.3V 电源输入/输出"></a>24. 3.3V 电源输入/输出</h2><pre><code>这是开发板板载的一组 3.3V 电源输入输出排针（2*3）（VOUT1），用于给外部提供 3.3V
</code></pre>
<p>的电源，也可以用于从外部接 3.3V 的电源给板子供电。<br>    大家在实验的时候可能经常会为没有 3.3V 电源而苦恼不已，有了 ALIENTEK 精英<br>STM32F103，你就可以很方便的拥有一个简单的 3.3V 电源（USB 供电的时候，最大电流不能<br>超过 500mA，外部供电的时候，最大可达 1000mA）</p>
<h2 id="25-5V-电源输入-输出"><a href="#25-5V-电源输入-输出" class="headerlink" title="25. 5V 电源输入/输出"></a>25. 5V 电源输入/输出</h2><pre><code>这是开发板板载的一组 5V 电源输入输出排针（2*3）（VOUT2），该排针用于给外部提供
</code></pre>
<p>5V 的电源，也可以用于从外部接 5V 的电源给板子供电。<br>    同样大家在实验的时候可能经常会为没有 5V 电源而苦恼不已，ALIENTEK 充分考虑到了<br>大家需求，有了这组 5V 排针，你就可以很方便的拥有一个简单的 5V 电源（USB 供电的时候，<br>最大电流不能超过 500mA，外部供电的时候，最大可达 1000mA）。</p>
<h2 id="26-电源开关"><a href="#26-电源开关" class="headerlink" title="26. 电源开关"></a>26. 电源开关</h2><pre><code>这是开发板板载的电源开关（K1）。该开关用于控制整个开发板的供电，如果切断，则整
</code></pre>
<p>个开发板都将断电，电源指示灯（PWR）会随着此开关的状态而亮灭。</p>
<h2 id="27-DC6-24V-电源输入"><a href="#27-DC6-24V-电源输入" class="headerlink" title="27. DC6~24V 电源输入"></a>27. DC6~24V 电源输入</h2><pre><code>这是开发板板载的一个外部电源输入口（DC_IN），采用标准的直流电源插座。开发板板载
</code></pre>
<p>了 DC-DC 芯片（MP2359），用于给开发板提供高效、稳定的 5V 电源。由于采用了 DC-DC 芯<br>片，所以开发板的供电范围十分宽，大家可以很方便的找到合适的电源（只要输出范围在<br>DC 6~24V的基本都可以）来给开发板供电。在耗电比较大的情况下，比如用到 4.3 屏/7 寸屏的<br>时候，建议使用外部电源供电，可以提供足够的电流给开发板使用.</p>
<h2 id="28-RS485-选择接口"><a href="#28-RS485-选择接口" class="headerlink" title="28. RS485 选择接口"></a>28. RS485 选择接口</h2><pre><code>这是开发板板载的 RS485 选择接口（P5），MAX3485 通过这个接口来决定是否连接到
</code></pre>
<p>STM32 的串口 2（USART2），当这里断开的时候：串口 2 可以用来做普通串口使用，而 RS485<br>则可以用来实现 RS485 转 TTL 的功能；当这里接上时：串口 2 连接 MAX3485，就可以实现<br>RS485 通信。  </p>
<h2 id="29-引出-IO-口（共-2-组）"><a href="#29-引出-IO-口（共-2-组）" class="headerlink" title="29. 引出 IO 口（共 2 组）"></a>29. 引出 IO 口（共 2 组）</h2><pre><code>这是开发板 IO 引出端口，总共有 2 组主 IO 引出口：P1 和 P2。它们采用 2*27 排针引出，
</code></pre>
<p>总共引出 106 个 IO 口。而 STM32F103ZET6 总共只有 112 个 IO，除去 RTC 晶振占用的 2 个 IO<br>，还剩下 110 个，这 2 组排针，总共引出 106 个 IO，剩下的 4 个 IO 分别通过：P3 和 P5 引出。</p>
<h2 id="30-LCD-接口"><a href="#30-LCD-接口" class="headerlink" title="30. LCD 接口"></a>30. LCD 接口</h2><pre><code>这是开发板板载的 LCD 模块接口，该接口兼容 ALIENTEK 全系列 TFTLCD 模块，包括：
</code></pre>
<p>2.4 寸、2.8 寸、3.5 寸、4.3 寸和 7 寸等 TFTLCD 模块，并且支持电阻/电容触摸功能。</p>
<h2 id="31-光敏传感器"><a href="#31-光敏传感器" class="headerlink" title="31. 光敏传感器"></a>31. 光敏传感器</h2><pre><code>这是开发板板载的一个光敏传感器（LS1），通过该传感器，开发板可以感知周围环境光线
</code></pre>
<p>的变化，从而可以实现类似自动背光控制的应用。</p>
<h2 id="32-RS485-接口"><a href="#32-RS485-接口" class="headerlink" title="32. RS485 接口"></a>32. RS485 接口</h2><pre><code>这是开发板板载的 RS485 总线接口（RS485），通过 2 个端口和外部 485 设备连接。这里提
</code></pre>
<p>醒大家，RS485 通信的时候，必须 A 接 A，B 接 B。否则可能通信不正常！另外，开发板自带<br>了终端电阻（120Ω）。</p>
<h2 id="33-CAN-接口"><a href="#33-CAN-接口" class="headerlink" title="33. CAN 接口"></a>33. CAN 接口</h2><pre><code>这是开发板板载的 CAN 总线接口（CAN），通过 2 个端口和外部 CAN 总线连接，即 CANH
</code></pre>
<p>和 CANL。这里提醒大家：CAN 通信的时候，必须 CANH 接 CANH，CANL 接 CANL，否则<br>可能通信不正常！</p>
<h1 id="STM32-初探"><a href="#STM32-初探" class="headerlink" title="STM32 初探"></a>STM32 初探</h1><h2 id="1-为什么选择STM32"><a href="#1-为什么选择STM32" class="headerlink" title="1. 为什么选择STM32"></a>1. 为什么选择STM32</h2><pre><code>·STM32 是基于ARM内核的32位的 Cortex-M内核
·具有标准的ARM框架
·好性能、低功耗、低电压、创新的内核及外设
·简单易用、低风险

Cortex-M3内核属于ARMv7架构
ARMv7架构定义了三大分工明确的系列:
&quot;A&quot;系列：面向尖端的基于虚拟内存的操作系统和用户应用
&quot;R&quot;系列：针对实时系统
&quot;M”系列：对微控制器

STM32F1属于Cortex-M系列中的Cortex-M3内核，采用ARMv7-M架构。
STM32F4属于Cortex-M4系列采用ARMv7-ME架构。 
Cortex-A5/A8采用ARMv7-A架构。
传统的ARM7系列采用的是ARMv4T架构。

详细对比见PPT的表格

总之Cortex-M3比ARM7好多了
</code></pre>
<h2 id="3-M3系列的优点"><a href="#3-M3系列的优点" class="headerlink" title="3. M3系列的优点"></a>3. M3系列的优点</h2><pre><code>1. 高性能Cortex-M内核
 采用ARM公司流行的标准内核Cortex-M3
 低动态功耗上实现的高性能
 哈佛结构上实现1.25DMIPS/MHZ，功耗只有0.19mv/MHZ，比ARM7TDMI改进了30%
 单周期的乘法和硬件除法
 不可分的位操作，实现对RAM，I/O和寄存器的最优访问。

2. 最佳的代码密度
 Thumb-2指令集以16位指令的密度实现32位指令性能（与ARM7TDMI的ARM模式比减少了30%-45%的代码量）

3. 可预见的运行时间
 中断控制器嵌在内核之中，中断之间的间隔最少可达6个CPU周期。 
 从低功耗模式唤醒只需6个CPU周期

4.改进的调试功能
 串行单步调试和JTAG调试
</code></pre>
<h2 id="2-STM32的命名规则"><a href="#2-STM32的命名规则" class="headerlink" title="2. STM32的命名规则"></a>2. STM32的命名规则</h2><pre><code>见PPT
</code></pre>
<h2 id="3-STM32的优势总结"><a href="#3-STM32的优势总结" class="headerlink" title="3. STM32的优势总结"></a>3. STM32的优势总结</h2><pre><code>1）极高的性能： 主流的Cortex内核。
2）丰富合理的外设，合理的功耗，合理的价格。
3）强大的软件支持：丰富的软件包。
4）全面丰富的技术文档。
5）芯片型号种类多，覆盖面广。
6）强大的用户基础：最先成功试水CM3芯片的公司，积累了大批的用户群体，为其领先做铺垫。
</code></pre>
<h1 id="STM32-芯片解读"><a href="#STM32-芯片解读" class="headerlink" title="STM32 芯片解读"></a>STM32 芯片解读</h1><pre><code>STM32F1数据手册：STM32F103ZET6.pdf
STM32F1中文手册：STM32F1xx中文参考手册.pdf
开发板原理图：XXX STM32F1_Vxx_SCH.pdf
</code></pre>
<h2 id="1-芯片有哪些资源？"><a href="#1-芯片有哪些资源？" class="headerlink" title="1.芯片有哪些资源？"></a>1.芯片有哪些资源？</h2><pre><code>STM32F103ZET6
内核：
 32位 高性能ARM Cortex-M3处理器
 时钟：高达72M,实际还可以超频一点点
 单周期乘法和硬件除法

IO口：
 STM32F103ZET6: 144引脚  112个IO（16×7可以分为7组，PA~PG）
 大部分IO口都耐5V(模拟通道除外)
 支持调试：SWD和JTAG，SWD只要2根数据线

存储器容量：
 STM32F103ZET6:  512K FLASH，64K SRAM

时钟，复位和电源管理：
 ①：2.0~3.6V电源和IO电压（一般用3.3V）
 ②：上电复位，掉电复位和可编程的电压监控
 ③：强大的时钟系统：
   4~16M的外部高速晶振(一般用8M)
   内部8MHz的高速RC振荡器
   内部40KHz低速RC振荡器，看门狗时钟
   内部锁相环（PLL，倍频），一般系统时钟都是外部或者内部高速时钟经过PLL倍频后得到（8M不够就倍频）
   外部低速32.768K的晶振，主要做RTC时钟源

低功耗：
 睡眠，停止和待机三种低功耗模式
 可用电池为RTC和备份寄存器供电

AD:
 3个12位AD【多达21个外部测量通道】
 转换范围：0~3.6(电源电压）（一般用3.3V）
 内部通道可以用于内部温度测量
 内置参考电压  

DA:
 2个12位DA

DMA（直接存储器访问）：
 12个DMA通道（7+5=12; 7通道DMA1,5通道DMA2)支持外设：定时器，ADC,DAC，SDIO,I2S,SPI,I2C,和USART

定时器（11个）：
 4个通用定时器
 2个基本定时器
 2个高级定时器
 1个系统定时器
 2个看门狗定时器

通信接口（13个）：
 2个I2C接口
 5个串口
 3个SPI接口
 1个CAN2.0
 1个USB FS
 1个SDIO
</code></pre>
<h2 id="2-芯片的内部结构"><a href="#2-芯片的内部结构" class="headerlink" title="2. 芯片的内部结构"></a>2. 芯片的内部结构</h2><pre><code>看PPT
</code></pre>
<h2 id="3-STM32的最小系统"><a href="#3-STM32的最小系统" class="headerlink" title="3. STM32的最小系统"></a>3. STM32的最小系统</h2><pre><code> 供电（VDD VSS VDDA VSSA都是3.3V VDDA和VSSA都是模拟的，对纹波的处理要求较高）
 复位（一般是一个按键一个电容，按键没按的时候通过上拉电阻，保持高电压3.3V，有按键按下的时候接地变为0V，可以通过电容充电）
 时钟：外部晶振（2个）（有两个晶振；一个是外部高速晶振，另一个是低速晶振）
 Boot启动模式选择 （BOOT1和BOOT2两个引脚通过一个段子连接在一起，跳线帽，通过一键下载电路可以跳过这个步骤）
 下载电路（串口（串口1,通过PA9和PA10接到USB转232的口再下载）/JTAG/SWD)
 后备电池

 其他地方还有一些滤波电容，一般选104
</code></pre>
<h1 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h1><h2 id="MDK安装"><a href="#MDK安装" class="headerlink" title="MDK安装"></a>MDK安装</h2><pre><code>MDK是什么？
RealView MDK是Keil公司开发的，为基于Cortex 、ARM7、ARM9等处理器设备提供的一个完整的开发环境。
参考资料：
ALIENTEK xxSTM32开发板入门资料\MDK5安装手册.pdf
</code></pre>
<h2 id="USB串口作用："><a href="#USB串口作用：" class="headerlink" title="USB串口作用："></a>USB串口作用：</h2><pre><code>（1）可以当串口使用。
（2）如果USB串口连接到STM32的串口1(STM32ISP下载只能是串口1)的话，那么可以用来串口下载程序。
（3）因为要连接到USB，所以可以用来USB供电。
</code></pre>
<h2 id="USB串口驱动安装"><a href="#USB串口驱动安装" class="headerlink" title="USB串口驱动安装"></a>USB串口驱动安装</h2><pre><code>USB串口驱动芯片型号：CH340
串口下载工具：mcuisp(FlyMcu)
</code></pre>
<h2 id="STM32的ISP下载"><a href="#STM32的ISP下载" class="headerlink" title="STM32的ISP下载"></a>STM32的ISP下载</h2><pre><code>只能使用串口1，也就是对应串口发送接收引脚PA9,PA10。不能使用其他串口（例如串口2：PA2,PA3)用来ISP下载。
</code></pre>
<h1 id="GPIO基本原理与寄存器配置"><a href="#GPIO基本原理与寄存器配置" class="headerlink" title="GPIO基本原理与寄存器配置"></a>GPIO基本原理与寄存器配置</h1><h2 id="GPIO基本结构和工作方式"><a href="#GPIO基本结构和工作方式" class="headerlink" title="GPIO基本结构和工作方式"></a>GPIO基本结构和工作方式</h2><pre><code>STM32F103ZET6
- 一共有7组IO口
- 每组IO口有16个IO
- 一共16X7=112个IO
- 分别是GPIOA GPIOB GPIOC GPIOD GPIOE GPIOF GPIOG
- GPIOA有 PA0 PA1 PA2 PA3 PA4 PA5 PA6 PA7 PA8 PA9 PA10 PA11 PA12 PA13 PA14 PA15

STM32的大部分引脚除了当GPIO使用外，还可以复用为外设功能引脚（比如串口）。

GPIO的工作方式：

4种输入模式：
   输入浮空
   输入上拉 
   输入下拉
   模拟输入
4种输出模式：
  开漏输出：只可以输出强低电平，高电平得靠外部电阻拉高。输出端相当于三极管的集电极. 要得到高电平状态需要上拉电阻才行. 适合于做电流型的驱动,其吸收电流的能力相对强(一般20ma以内)
  开漏复用功能
  推挽式输出：可以输出强高低电平，连接数字器件 
  推挽式复用功能
3种最大翻转速度：
   -2MHZ
   -10MHz
   -50MHz
</code></pre>
<h2 id="每组GPIO端口的寄存器"><a href="#每组GPIO端口的寄存器" class="headerlink" title="每组GPIO端口的寄存器"></a>每组GPIO端口的寄存器</h2><pre><code>包括：

两个32位配置寄存器(GPIOx_CRL ，GPIOx_CRH) ，
两个32位数据寄存器 (GPIOx_IDR和GPIOx_ODR)，
一个32位置位/ 复位寄存器(GPIOx_BSRR)，
一个16位复位寄存器(GPIOx_BRR)，
一个32位锁定寄存器(GPIOx_LCKR)。

每个I/O端口位可以自由编程，然而I/O端口寄存器必须按32位字被访问(不允许半字或字节访问) 。

每组IO口含下面7个寄存器。也就是7个寄存器，一共可以控制一组GPIO的16个IO口。
    - GPIOx_CRL :端口配置低寄存器
    - GPIOx_CRH:端口配置高寄存器
    - GPIOx_IDR:端口输入寄存器
    - GPIOx_ODR:端口输出寄存器
    - GPIOx_BSRR:端口位设置/清除寄存器
    - GPIOx_BRR :端口位清除寄存器
    - GPIOx_LCKR:端口配置锁存寄存器
</code></pre>
<h2 id="端口复用功能"><a href="#端口复用功能" class="headerlink" title="端口复用功能"></a>端口复用功能</h2><p>   STM32的大部分端口都具有复用功能。<br>   所谓复用，就是一些端口不仅仅可以做为通用IO口，还可以复用为一<br>   些外设引脚，比如PA9,PA10可以复用为STM32的串口1引脚。<br>   作用：最大限度的利用端口资源</p>
<h2 id="端口重映射功能"><a href="#端口重映射功能" class="headerlink" title="端口重映射功能"></a>端口重映射功能</h2><p>   就是可以把某些功能引脚映射到其他引脚。<br>   比如串口1默认引脚是PA9,PA10可以通过配置重映射映<br>   射到PB6,PB7<br>   作用：方便布线</p>
<h1 id="跑马灯程序"><a href="#跑马灯程序" class="headerlink" title="跑马灯程序"></a>跑马灯程序</h1><h2 id="硬件连接及GPIO库函数说明"><a href="#硬件连接及GPIO库函数说明" class="headerlink" title="硬件连接及GPIO库函数说明"></a>硬件连接及GPIO库函数说明</h2><pre><code> LED0接PB5
 LED1接PE5
 GPIO采用推挽输出的方式（可以输出高低电平）

 头文件：stm32f10x_gpio.h
 源文件：stm32f10x_gpio.c

 要使用GPIO的话 
 stm32f10x_gpio.c 
 stm32f10x_rcc.c 
 misc.c
 是必要的文件
</code></pre>
<h2 id="初始化函数："><a href="#初始化函数：" class="headerlink" title="初始化函数："></a>初始化函数：</h2><p>void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);<br>第一个参数 GPIO_TypeDef* GPIOx 表示选择第几个GPIO<br>第二个参数 GPIO_InitTypeDef* GPIO_InitStruct 中的GPIO_InitTypeDef结构体中的成员有：</p>
<p>GPIO_Pin用来指定IO口<br>GPIO_Speed用来指定速度<br>GPIO_Mode用来指定模式   </p>
<p>GPIO_Init函数初始化样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitTypeDef  GPIO_InitStructure;	            //定义结构体</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;          //LED0--&gt;PB.5 端口配置</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;   //推挽输出</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  //IO口速度为50MHz</span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);	            //根据设定参数初始化GPIOB.5</span><br></pre></td></tr></table></figure>

<h2 id="2个读取输入电平函数："><a href="#2个读取输入电平函数：" class="headerlink" title="2个读取输入电平函数："></a>2个读取输入电平函数：</h2><p>uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);<br>作用：读取某<strong>个</strong>GPIO的输入电平。实际操作的是GPIOx_IDR寄存器。<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_5);//读取GPIOA.5的输入电平</span><br></pre></td></tr></table></figure>
<p>uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx);<br>作用：读取某<strong>组</strong>GPIO的输入电平。实际操作的是GPIOx_IDR寄存器。<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO_ReadInputData(GPIOA);//读取GPIOA组中所有io口输入电平</span><br></pre></td></tr></table></figure>

<h2 id="2个读取输出电平函数："><a href="#2个读取输出电平函数：" class="headerlink" title="2个读取输出电平函数："></a>2个读取输出电平函数：</h2><p>uint8_t GPIO_ReadOutputDataBit (GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);<br>作用：读取某个GPIO的输出电平。实际操作的是GPIO_ODR寄存器。<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_5);//读取GPIOA.5的输出电平</span><br></pre></td></tr></table></figure>

<p>uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx);<br>作用：读取某组GPIO的输出电平。实际操作的是GPIO_ODR寄存器。<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO_ReadOutputData(GPIOA);//读取GPIOA组中所有io口输出电平</span><br></pre></td></tr></table></figure>
<h2 id="4个设置输出电平函数："><a href="#4个设置输出电平函数：" class="headerlink" title="4个设置输出电平函数："></a>4个设置输出电平函数：</h2><p>void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);<br>作用：设置某个IO口输出为高电平（1）。实际操作BSRR寄存器</p>
<p>void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);<br>作用：设置某个IO口输出为低电平（0）。实际操作的BRR寄存器。</p>
<p>void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal);<br>void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal);<br> 这两个函数不常用，也是用来设置IO口输出电平。</p>
<h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>步骤：<br> 使能IO口时钟。调用函数RCC_APB2PeriphColckCmd();<br>     不同的IO组，调用的时钟使能函数不一样。<br> 初始化IO口模式。调用函数GPIO_Init();<br> 操作IO口，输出高低电平。<br>     GPIO_SetBits();<br>     GPIO_ResetBits();</p>
<h3 id="1-在template模板中新建HARDWARE（硬件）分组；"><a href="#1-在template模板中新建HARDWARE（硬件）分组；" class="headerlink" title="1.在template模板中新建HARDWARE（硬件）分组；"></a>1.在template模板中新建HARDWARE（硬件）分组；</h3><h3 id="2-在相应的目录中新建HARDWARE文件夹；"><a href="#2-在相应的目录中新建HARDWARE文件夹；" class="headerlink" title="2.在相应的目录中新建HARDWARE文件夹；"></a>2.在相应的目录中新建HARDWARE文件夹；</h3><h3 id="3-在HARDWARE文件夹中再新建LED等外设文件夹"><a href="#3-在HARDWARE文件夹中再新建LED等外设文件夹" class="headerlink" title="3.在HARDWARE文件夹中再新建LED等外设文件夹"></a>3.在HARDWARE文件夹中再新建LED等外设文件夹</h3><h3 id="4-每个外设文件夹中建立一个对应的-h和-c的文件"><a href="#4-每个外设文件夹中建立一个对应的-h和-c的文件" class="headerlink" title="4.每个外设文件夹中建立一个对应的.h和.c的文件"></a>4.每个外设文件夹中建立一个对应的.h和.c的文件</h3><h3 id="5-在-h中预编译防止重新引用"><a href="#5-在-h中预编译防止重新引用" class="headerlink" title="5.在.h中预编译防止重新引用"></a>5.在.h中预编译防止重新引用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __LED_H</span><br><span class="line">#define __LED_H</span><br><span class="line">void LED_Init(void);    //声明LED初始化函数</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<h3 id="6-在-c（源文件）中定义函数"><a href="#6-在-c（源文件）中定义函数" class="headerlink" title="6.在.c（源文件）中定义函数"></a>6.在.c（源文件）中定义函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;led.h&quot;</span><br><span class="line">void LED_Init(void)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-按步骤调用函数RCC-APB2PeriphColckCmd"><a href="#7-按步骤调用函数RCC-APB2PeriphColckCmd" class="headerlink" title="7.按步骤调用函数RCC_APB2PeriphColckCmd();"></a>7.按步骤调用函数RCC_APB2PeriphColckCmd();</h3><p>写入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;led.h&quot;</span><br><span class="line">void LED_Init(void)</span><br><span class="line">&#123;</span><br><span class="line"> RCC_APB2PeriphClockCmd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后右键RCC_APB2PeriphClockCmd();点击go to definition<br>找到定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)</span><br><span class="line">&#123;</span><br><span class="line">  /* Check the parameters */</span><br><span class="line">  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));</span><br><span class="line">  assert_param(IS_FUNCTIONAL_STATE(NewState));</span><br><span class="line">  if (NewState != DISABLE)</span><br><span class="line">  &#123;</span><br><span class="line">    RCC-&gt;APB2ENR |= RCC_APB2Periph;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    RCC-&gt;APB2ENR &amp;= ~RCC_APB2Periph;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个参数RCC_APB2Periph 第二个参数NewState<br>右键IS_RCC_APB2_PERIPH点击go to definition查看有效值<br>找到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#define RCC_APB2Periph_AFIO              ((uint32_t)0x00000001)</span><br><span class="line">#define RCC_APB2Periph_GPIOA             ((uint32_t)0x00000004)</span><br><span class="line">#define RCC_APB2Periph_GPIOB             ((uint32_t)0x00000008)</span><br><span class="line">#define RCC_APB2Periph_GPIOC             ((uint32_t)0x00000010)</span><br><span class="line">#define RCC_APB2Periph_GPIOD             ((uint32_t)0x00000020)</span><br><span class="line">#define RCC_APB2Periph_GPIOE             ((uint32_t)0x00000040)</span><br><span class="line">#define RCC_APB2Periph_GPIOF             ((uint32_t)0x00000080)</span><br><span class="line">#define RCC_APB2Periph_GPIOG             ((uint32_t)0x00000100)</span><br><span class="line">#define RCC_APB2Periph_ADC1              ((uint32_t)0x00000200)</span><br><span class="line">#define RCC_APB2Periph_ADC2              ((uint32_t)0x00000400)</span><br><span class="line">#define RCC_APB2Periph_TIM1              ((uint32_t)0x00000800)</span><br><span class="line">#define RCC_APB2Periph_SPI1              ((uint32_t)0x00001000)</span><br><span class="line">#define RCC_APB2Periph_TIM8              ((uint32_t)0x00002000)</span><br><span class="line">#define RCC_APB2Periph_USART1            ((uint32_t)0x00004000)</span><br><span class="line">#define RCC_APB2Periph_ADC3              ((uint32_t)0x00008000)</span><br><span class="line">#define RCC_APB2Periph_TIM15             ((uint32_t)0x00010000)</span><br><span class="line">#define RCC_APB2Periph_TIM16             ((uint32_t)0x00020000)</span><br><span class="line">#define RCC_APB2Periph_TIM17             ((uint32_t)0x00040000)</span><br><span class="line">#define RCC_APB2Periph_TIM9              ((uint32_t)0x00080000)</span><br><span class="line">#define RCC_APB2Periph_TIM10             ((uint32_t)0x00100000)</span><br><span class="line">#define RCC_APB2Periph_TIM11             ((uint32_t)0x00200000)</span><br><span class="line"></span><br><span class="line">#define IS_RCC_APB2_PERIPH(PERIPH) ((((PERIPH) &amp; 0xFFC00002) == 0x00) &amp;&amp; ((PERIPH) != 0x00))</span><br></pre></td></tr></table></figure>
<p>即可查看有效值<br>我们所使用的是GPIOB和GPIOE，所以<br>RCC_APB2PeriphColckCmd()的第一个输入参数是RCC_APB2Periph_GPIOB</p>
<p>同理右键IS_FUNCTIONAL_STATE点击go to definition查看有效值<br>找到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))</span><br></pre></td></tr></table></figure>
<p>发现有效值是DISABLE或者ENABLE<br>我们选择ENABLE，所以<br>RCC_APB2PeriphColckCmd()的第一个输入参数是ENABLE</p>
<p>此时的led.h内容为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;led.h&quot;</span><br><span class="line">void LED_Init(void)</span><br><span class="line">&#123;</span><br><span class="line"> RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编译后有两个error显示RCC_APB2Periph_GPIOB和ENABLE未定义<br>我们引用固件头文件stm32f10x.h后就OK了<br>此时的led.h内容为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;led.h&quot;</span><br><span class="line">#include &quot;stm32f10x.h&quot;</span><br><span class="line">void LED_Init(void)</span><br><span class="line">&#123;</span><br><span class="line"> RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此时GPIOB的时钟就已经启动了；</p>
<h3 id="8-初始化IO口模式。调用函数GPIO-Init"><a href="#8-初始化IO口模式。调用函数GPIO-Init" class="headerlink" title="8.初始化IO口模式。调用函数GPIO_Init();"></a>8.初始化IO口模式。调用函数GPIO_Init();</h3><p>复制GPIO_Init()到led.c中；右键go to definition查看具体参数<br>或者到gpio.h中找声明<br>声明中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);	</span><br></pre></td></tr></table></figure>
<p>有两个个参数分别是GPIOx和GPIO_InitStruct<br>GPIOx此时是GPIOB和GPIOE<br>GPIO_InitStruct是一个GPIO_InitTypeDef类型的结构体；<br>所以我们在前面先定义这个结构体</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStruct;</span><br></pre></td></tr></table></figure>
<p>定义完后注意赋值,发现结构体有<br> GPIO_InitStruct.GPIO_Mode<br> GPIO_InitStruct.GPIO_Pin<br> GPIO_InitStruct.GPIO_Speed<br>三个变量；通过上面的方法找到有效值如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br></pre></td></tr></table></figure>

<p><strong>注意在引用的时候要加&amp;符号</strong></p>
<p>即</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO_Init(GPIOB,&amp;GPIO_InitStruct);</span><br></pre></td></tr></table></figure>
<p>同理可设置GPIOB的值，这一步完成后的led.c代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;led.h&quot;</span><br><span class="line">#include &quot;stm32f10x.h&quot;</span><br><span class="line">void LED_Init(void)</span><br><span class="line">&#123;</span><br><span class="line"> GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">	</span><br><span class="line"> RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line"> RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE,ENABLE);</span><br><span class="line">	</span><br><span class="line"> GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line"> GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;</span><br><span class="line"> GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"> GPIO_Init(GPIOB,&amp;GPIO_InitStruct);</span><br><span class="line">	</span><br><span class="line"> GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line"> GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;</span><br><span class="line"> GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"> GPIO_Init(GPIOE,&amp;GPIO_InitStruct);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-操作IO口，输出高低电平"><a href="#9-操作IO口，输出高低电平" class="headerlink" title="9.操作IO口，输出高低电平"></a>9.操作IO口，输出高低电平</h3><p>一般默认初始化之后灯先不点亮，所以需要设置为高电平，需要用到<br>    GPIO_SetBits();<br>    GPIO_ResetBits();</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GPIO_SetBits(GPIOB,GPIO_Pin_5);</span><br><span class="line">GPIO_SetBits(GPIOE,GPIO_Pin_5);</span><br></pre></td></tr></table></figure>
<p>此时led.c的内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;led.h&quot;</span><br><span class="line">#include &quot;stm32f10x.h&quot;</span><br><span class="line">void LED_Init(void)</span><br><span class="line">&#123;</span><br><span class="line"> GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">	</span><br><span class="line"> RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line"> RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE,ENABLE);</span><br><span class="line">	</span><br><span class="line"> GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line"> GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;</span><br><span class="line"> GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"> GPIO_Init(GPIOB,&amp;GPIO_InitStruct);</span><br><span class="line"> GPIO_SetBits(GPIOB,GPIO_Pin_5);</span><br><span class="line">	</span><br><span class="line"> GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line"> GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;</span><br><span class="line"> GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"> GPIO_Init(GPIOE,&amp;GPIO_InitStruct);</span><br><span class="line"> GPIO_SetBits(GPIOE,GPIO_Pin_5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="从主函数开始写程序"><a href="#从主函数开始写程序" class="headerlink" title="从主函数开始写程序"></a>从主函数开始写程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;stm32f10x.h&quot;</span><br><span class="line">#include&quot;led.h&quot;</span><br><span class="line">#include&quot;delay.h&quot;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    LED_Init();</span><br><span class="line">    delay_init();</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        GPIO_SetBits(GPIOB,GPIO_Pin_5);</span><br><span class="line">        GPIO_SetBits(GPIOE,GPIO_Pin_5);     //设为高电平</span><br><span class="line"></span><br><span class="line">        delay_ms(500);</span><br><span class="line"></span><br><span class="line">        GPIO_ResetBits(GPIOB,GPIO_Pin_5);</span><br><span class="line">        GPIO_ResetBits(GPIOE,GPIO_Pin_5);     //设为低电平</span><br><span class="line"></span><br><span class="line">        delay_ms(500);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="蜂鸣器实验"><a href="#蜂鸣器实验" class="headerlink" title="蜂鸣器实验"></a>蜂鸣器实验</h1><p>蜂鸣器是一种一体化结构的电子讯响器，采用直流电压供电，广泛应用于计算机、打印机、<br>复印机、报警器、电子玩具、汽车电子设备、电话机、定时器等电子产品中作发声器件。蜂鸣<br>器主要分为压电式蜂鸣器和电磁式蜂鸣器两种类型。<br>这里的有源不是指电源的“源”，而是指有没有自带震荡电路，有源蜂鸣器自带了震荡电路，<br>一通电就会发声；无源蜂鸣器则没有自带震荡电路，必须外部提供 2~5Khz 左右的方波驱动，<br>才能发声。<br>我们用到一个 NPN 三极管（S8050）来驱动蜂鸣器，R33 主要用于防止蜂鸣器的误发<br>声。当 PB.8 输出高电平的时候，蜂鸣器将发声，当 PB.8 输出低电平的时候，蜂鸣器停止发声。<br>电流从三极管基极进入放大后才能驱动蜂鸣器。由于STM32单片机复位后BEEP位是浮空的，即该IO口的状态是不确定的，所以我们需要接一个R38（10KΩ）再接地，把小电流引到地，这样可以防止误发声。</p>
<h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><p>使能IO口时钟。调用函数RCC_APB2PeriphColckCmd();<br>    不同的IO组，调用的时钟使能函数不一样。<br>初始化IO口模式。调用函数BEEP_Init();<br>操作IO口，输出高低电平。</p>
<h1 id="按键输入实验"><a href="#按键输入实验" class="headerlink" title="按键输入实验"></a>按键输入实验</h1><h2 id="按键的硬件连接"><a href="#按键的硬件连接" class="headerlink" title="按键的硬件连接"></a>按键的硬件连接</h2><p>有三个按键 WK UP、KEY_0、KEY_1<br>WK UP接PA0 另一端接Vcc<br>KEY_0接PE4 另一端接GND<br>KEY_1接PE3 另一端接GND</p>
<h2 id="按键输入操作说明"><a href="#按键输入操作说明" class="headerlink" title="按键输入操作说明"></a>按键输入操作说明</h2><p>读取IO口输入电平调用库函数为：<br>uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);</p>
<p>读取IO口输入电平操作寄存器为<br>GPIOx_IDR:端口输入寄存器</p>
<p>使用位带操作读取IO口输入电平：<br>PEin(4)          -读取GPIOE.4口电平<br>PEin(n)          -读取GPIOE.n口电平</p>
<h2 id="按键输入实验步骤"><a href="#按键输入实验步骤" class="headerlink" title="按键输入实验步骤"></a>按键输入实验步骤</h2><p>使能按键对应IO口时钟。调用函数：<br>    RCC_APB2PeriphClockCmd();<br>初始化IO模式：上拉/下拉输入。调用函数：<br>    GPIO_Init();<br>扫描IO口电平（库函数/寄存器/位操作）  </p>
<h2 id="C语言关键字-：static"><a href="#C语言关键字-：static" class="headerlink" title="C语言关键字 ：static"></a>C语言关键字 ：static</h2><p>Static申明的局部变量，存储在静态存储区。<br>它在函数调用结束之后，不会被释放。它的值会一直保留下来。<br>所以可以说static申明的局部变量，具有记忆功能。<br>比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int getValue(void)</span><br><span class="line">&#123;</span><br><span class="line">  int  flag=0;</span><br><span class="line">  flag++;</span><br><span class="line">  return flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int getValue(void)</span><br><span class="line">&#123;</span><br><span class="line">  static int  flag=0;</span><br><span class="line">  flag++;</span><br><span class="line">  return flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="按键扫描（支持连续按）的一般思路"><a href="#按键扫描（支持连续按）的一般思路" class="headerlink" title="按键扫描（支持连续按）的一般思路"></a>按键扫描（支持连续按）的一般思路</h2><p>如果我要实现：按键按下，没有松开，只能算按下一次，这个函数无法实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">u8 KEY_Scan(void)</span><br><span class="line">   &#123;</span><br><span class="line">     if(KEY按下）</span><br><span class="line">    &#123;</span><br><span class="line">          delay_ms(10)；//延时10-20ms，防抖。</span><br><span class="line">          if(KEY确实按下)</span><br><span class="line">           &#123;</span><br><span class="line">              return KEY_Value；</span><br><span class="line">            &#125;</span><br><span class="line">         return 无效值；</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="按键扫描（不支持连续按）的一般思路"><a href="#按键扫描（不支持连续按）的一般思路" class="headerlink" title="按键扫描（不支持连续按）的一般思路"></a>按键扫描（不支持连续按）的一般思路</h2><p>不支持连续按：就是说，按键按下了，没有松开，只能算一次。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">u8 KEY_Scan(void)</span><br><span class="line">    &#123;</span><br><span class="line">     static u8 key_up=1;  //key_up==1表示前一次是松开的；key_up==0表示前一次是闭合的</span><br><span class="line">      if（key_up &amp;&amp;  KEY按下）</span><br><span class="line">      &#123;</span><br><span class="line">        delay_ms(10);//延时，防抖</span><br><span class="line">        key_up=0;//标记这次key已经按下</span><br><span class="line">        if(KEY确实按下)</span><br><span class="line">          &#123;</span><br><span class="line">           return KEY_VALUE;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;else if(KEY没有按下)  key_up=1;</span><br><span class="line">       return 没有按下</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="按键扫描（两种模式合二为一）的一般思路"><a href="#按键扫描（两种模式合二为一）的一般思路" class="headerlink" title="按键扫描（两种模式合二为一）的一般思路"></a>按键扫描（两种模式合二为一）的一般思路</h2><p>多了一个入口参数mode；mode==1表示支持连续按 mode==0表示不支持连续按 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">u8 KEY_Scan(u8 mode)</span><br><span class="line">   &#123;</span><br><span class="line">    static u8 key_up=1;</span><br><span class="line">    if(mode==1) key_up=1;//支持连续按</span><br><span class="line">     if（key_up &amp;&amp;  KEY按下）</span><br><span class="line">     &#123;</span><br><span class="line">       delay_ms(10);//延时，防抖</span><br><span class="line">       key_up=0;//标记这次key已经按下</span><br><span class="line">       if(KEY确实按下)</span><br><span class="line">         &#123;</span><br><span class="line">          return KEY_VALUE;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;else if(KEY没有按下)  key_up=1;</span><br><span class="line">      return 没有按下</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="C语言复习和MDK中寄存器地址名称映射分析"><a href="#C语言复习和MDK中寄存器地址名称映射分析" class="headerlink" title="C语言复习和MDK中寄存器地址名称映射分析"></a>C语言复习和MDK中寄存器地址名称映射分析</h1><h2 id="位操作：6种位操作运算符"><a href="#位操作：6种位操作运算符" class="headerlink" title="位操作：6种位操作运算符"></a>位操作：6种位操作运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
<th>运算符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>按位与</td>
<td>~</td>
<td>取反</td>
</tr>
<tr>
<td>|</td>
<td>按位或</td>
<td>&lt;&lt;</td>
<td>左移</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
<td>&gt;&gt;</td>
<td>右移</td>
</tr>
</tbody></table>
<p>GPIOA-&gt;CRL&amp;=0XFFFFFF0F;    //将第4-7位清0<br>GPIOA-&gt;CRL|=0X00000040;    //设置相应位的值，不改变其他位的值<br>GPIOA-&gt;ODR|=1&lt;&lt;5;<br>TIMx-&gt;SR = (uint16_t)~TIM_FLAG;</p>
<p>左移和右移都是补0</p>
<h2 id="define宏定义关键词"><a href="#define宏定义关键词" class="headerlink" title="define宏定义关键词"></a>define宏定义关键词</h2><p>define是C语言中的预处理命令，它用于宏定义，可以提高源代码的可读性，为编程提供方便。<br>常见的格式：<br>#define 标识符 字符串<br>“标识符”为所定义的宏名。“字符串”可以是常数、表达式、格式串等。<br>例如：<br>#define SYSCLK_FREQ_72MHz  72000000<br>定义标识符SYSCLK_FREQ_72MHz的值为72000000。</p>
<h2 id="ifdef条件编译"><a href="#ifdef条件编译" class="headerlink" title="ifdef条件编译"></a>ifdef条件编译</h2><p>单片机程序开发过程中，经常会遇到一种情况，当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句。条件编译命令最常见的形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef 标识符 </span><br><span class="line">程序段1 </span><br><span class="line">#else </span><br><span class="line">程序段2 </span><br><span class="line">#endif </span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifdef STM32F10X_HD</span><br><span class="line">大容量芯片需要的一些变量定义</span><br><span class="line">#end</span><br></pre></td></tr></table></figure>

<h2 id="extern变量申明"><a href="#extern变量申明" class="headerlink" title="extern变量申明"></a>extern变量申明</h2><p>Main.c文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">u8 id;//定义只允许一次</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">id=1;</span><br><span class="line">printf(&quot;d%&quot;,id);//id=1</span><br><span class="line">test();</span><br><span class="line">printf(&quot;d%&quot;,id);//id=2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>test.c文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extern u8 id;//此处声明id这个变量，不是定义</span><br><span class="line">void test(void)&#123;</span><br><span class="line">id=2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="typedef类型别名"><a href="#typedef类型别名" class="headerlink" title="typedef类型别名"></a>typedef类型别名</h2><p>定义一种类型的别名，而不只是简单的宏替换。可以用作同时声明指针型的多个对象。</p>
<p>typedef unsigned          char uint8_t;<br>typedef unsigned short     int uint16_t;<br>typedef unsigned           int uint32_t;<br>typedef unsigned       __int64 uint64_t;</p>
<h2 id="结构体：构造类型"><a href="#结构体：构造类型" class="headerlink" title="结构体：构造类型"></a>结构体：构造类型</h2><p>Struct 结构体名{<br>成员列表1;<br>成员变量2；<br>…<br>}变量名列表；</p>
<p>在结构体申明的时候可以定义变量，也可以申明之后定义，方法是：<br>Struct 结构体名字   结构体变量列表 ;</p>
<p>结构体作用：<br>    同一个类型可以用数组，不同类型可以用结构体组织。</p>
<pre><code>结构体可扩展性强。

举例说明：
    void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
</code></pre>
<h2 id="STM32中操作："><a href="#STM32中操作：" class="headerlink" title="STM32中操作："></a>STM32中操作：</h2><p>GPIOA-&gt;ODR=0x00000000; </p>
<p>值0x00000000是怎么赋值给了GPIOA的ODR寄存器地址的呢？</p>
<p>也就是说GPIOA-&gt;ODR这种写法，是怎么与GPIOA的ODR寄存器地址映射起来的？<br>#define PERIPH_BASE           ((uint32_t)0x40000000)<br>#define APB2PERIPH_BASE       (PERIPH_BASE + 0x10000)<br>#define GPIOA_BASE            (APB2PERIPH_BASE + 0x0800)<br>#define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)<br>typedef struct<br>{<br>  __IO uint32_t CRL;<br>  __IO uint32_t CRH;<br>  __IO uint32_t IDR;<br>  __IO uint32_t ODR;<br>  __IO uint32_t BSRR;<br>  __IO uint32_t BRR;<br>  __IO uint32_t LCKR;<br>} GPIO_TypeDef;</p>
<h1 id="时钟系统"><a href="#时钟系统" class="headerlink" title="时钟系统"></a>时钟系统</h1><p>几个重要的时钟：</p>
<p>SYSCLK(系统时钟) :<br> AHB总线时钟<br> APB1总线时钟(低速): 速度最高36MHz<br> APB2总线时钟(高速): 速度最高72MHz<br> PLL时钟</p>
<p>参考资料：<br><a target="_blank" rel="noopener" href="http://www.openedv.com/posts/list/302.htm">http://www.openedv.com/posts/list/302.htm</a></p>
<ol>
<li><p>STM32 有5个时钟源:HSI、HSE、LSI、LSE、PLL。<br> ①、HSI是高速内部时钟，RC振荡器，频率为8MHz，精度不高。<br> ②、HSE是高速外部时钟，可接石英/陶瓷谐振器，或者接外部时钟源，频率范围为4MHz<del>16MHz。③、LSI是低速内部时钟，RC振荡器，频率为40kHz，提供低功耗时钟。<br> ④、LSE是低速外部时钟，接频率为32.768kHz的石英晶体。<br> ⑤、PLL为锁相环倍频输出，其时钟输入源可选择为HSI/2、HSE或者HSE/2。倍频可选择为2</del>16倍，但是其输出频率最大不得超过72MHz。</p>
</li>
<li><p>系统时钟SYSCLK可来源于三个时钟源：<br> ①、HSI振荡器时钟<br> ②、HSE振荡器时钟<br> ③、PLL时钟</p>
</li>
<li><p>STM32可以选择一个时钟信号输出到MCO脚(PA8)上，可以选择为PLL<br> 输出的2分频、HSI、HSE、或者系统时钟。</p>
</li>
<li><p>任何一个外设在使用之前，必须首先使能其相应的时钟。</p>
</li>
</ol>
<h2 id="系统时钟初始化函数："><a href="#系统时钟初始化函数：" class="headerlink" title="系统时钟初始化函数："></a>系统时钟初始化函数：</h2><pre><code>SystemInit();
</code></pre>
<p>  使用V3.5版本的库函数，该函数在系统启动之后会自动调用：<br>    startup_stm32f10x_xx.s文件中：<br>            ; Reset handler<br>                Reset_Handler   PROC<br>                 EXPORT  Reset_Handler             [WEAK]<br>                 IMPORT  __main<br>                 IMPORT  SystemInit<br>                 LDR     R0, =SystemInit<br>                 BLX     R0<br>                 LDR     R0, =__main<br>                 BX      R0<br>                 ENDP</p>
<h1 id="SysTick定时器"><a href="#SysTick定时器" class="headerlink" title="SysTick定时器"></a>SysTick定时器</h1><p>Systick定时器，是一个简单的定时器，对于CM3,CM4内核芯片，都有Systick定时器。</p>
<p>Systick定时器常用来做延时，或者实时系统的心跳时钟。这样可以节省MCU资源，不用浪费一个定时器。比如UCOS中，分时复用，需要一个最小的时间戳，一般在STM32+UCOS系统中，都采用Systick做UCOS心跳时钟。</p>
<p>Systick定时器就是系统滴答定时器，一个24 位的倒计数定时器，计到0 时，将从RELOAD 寄存器中自动重装载定时初值。只要不把它在SysTick 控制及状态寄存器中的使能位清除，就永不停息，即使在睡眠模式下也能工作。</p>
<p>SysTick定时器被捆绑在NVIC中，用于产生SYSTICK异常（异常号：15）。<br>Systick中断的优先级也可以设置。</p>
<p>4个Systick寄存器</p>
<pre><code>CTRL             SysTick 控制和状态寄存器  
LOAD             SysTick 自动重装载除值寄存器 
VAL              SysTick 当前值寄存器  
CALIB            SysTick 校准值寄存器
</code></pre>
<p>对于STM32，<br>    外部时钟源是 HCLK(AHB总线时钟）的1/8<br>    内核时钟是 HCLK时钟<br>    配置函数：SysTick_CLKSourceConfig();</p>
<p>固件库中的Systick相关函数：</p>
<p>SysTick_CLKSourceConfig()    //Systick时钟源选择  misc.c文件中</p>
<p>SysTick_Config(uint32_t ticks) //初始化systick,时钟为HCLK,并开启中断<br>                               //core_cm3.h/core_cm4.h文件中<br>Systick中断服务函数：</p>
<p>   void SysTick_Handler(void);</p>
<h1 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h1><p>STM32有很多的内置外设，这些外设的外部引脚都是与GPIO复用的。也就是说，一个GPIO如果可以复用为内置外设的功能引脚，那么当这个GPIO作为内置外设使用的时候，就叫做复用。</p>
<p>例如串口1 的发送接收引脚是PA9,PA10，当我们把PA9,PA10不用作GPIO，而用做复用功能串口1的发送接收引脚的时候，叫端口复用。</p>
<p>端口复用配置过程：<br>以PA9,PA10配置为串口1为例<br>1.GPIO端口时钟使能。<br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</p>
<p>2.复用外设时钟使能。<br>    比如你要将端口PA9,PA10复用为串口，所以要使能串口时钟。<br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);</p>
<p>3.端口模式配置。 GPIO_Init（）函数。<br>    查表：<br>   《STM32中文参考手册V10》P110的表格“8.1.11外设的GPIO配置”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);  //①IO时钟使能</span><br><span class="line"></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE); //②外设时钟使能</span><br><span class="line"></span><br><span class="line">//③初始化IO为对应的模式</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //PA.9//复用推挽输出</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; </span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">  </span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;//PA10 PA.10 浮空输入</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);  </span><br></pre></td></tr></table></figure>

<h1 id="中断优先级管理NVIC"><a href="#中断优先级管理NVIC" class="headerlink" title="中断优先级管理NVIC"></a>中断优先级管理NVIC</h1><p>CM3内核支持256个中断，其中包含了16个内核中断和240个外部中断，并且具有256级的可编程中断设置。<br>STM32并没有使用CM3内核的全部东西，而是只用了它的一部分。<br>STM32有84个中断，包括16个内核中断和68个可屏蔽中断，具有16级可编程的中断优先级。<br>STM32F103系列上面，又只有60个可屏蔽中断（在107系列才有68个）</p>
<h2 id="中断管理方法："><a href="#中断管理方法：" class="headerlink" title="中断管理方法："></a>中断管理方法：</h2><p>首先，对STM32中断进行分组，组0~4。同时，对每个中断设置一个抢占优先级和一个响应优先级值。</p>
<p>分组配置是在寄存器SCB-&gt;AIRCR中配置：</p>
<h2 id="抢占优先级-amp-响应优先级区别："><a href="#抢占优先级-amp-响应优先级区别：" class="headerlink" title="抢占优先级 &amp; 响应优先级区别："></a>抢占优先级 &amp; 响应优先级区别：</h2><p>高抢占优先级可以打断正在进行的低抢占优先级中断的。<br>抢占优先级相同的中断，高响应优先级不可以打断低响应优先级的中断。<br>抢占优先级相同的中断，当两个中断同时发生的情况下，哪个响应优先级高，哪个先执行。<br>如果两个中断的抢占优先级和响应优先级都是一样的话，则看哪个中断先发生就先执行；</p>
<p>假定设置中断优先级组为2，然后设置中断3(RTC中断)的抢占优先级为2，响应优先级为1。  中断6（外部中断0）的抢占优先级为3，响应优先级为0。中断7（外部中断1）的抢占优先级为2，响应优先级为0。<br>那么这3个中断的优先级顺序为：中断7&gt;中断3&gt;中断6.</p>
<h2 id="特别说明："><a href="#特别说明：" class="headerlink" title="特别说明："></a>特别说明：</h2><p>一般情况下，系统代码执行过程中，只设置一次中断优先级分组，比如分组2，设置好分组之后一般不会再改变分组。随意改变分组会导致中断管理混乱，程序出现意想不到的执行结果。</p>
<h2 id="中断优先级分组函数"><a href="#中断优先级分组函数" class="headerlink" title="中断优先级分组函数:"></a>中断优先级分组函数:</h2><p>void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup);</p>
<p>void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup)<br>{<br>  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));<br>  SCB-&gt;AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;<br>}</p>
<p>NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</p>
<h2 id="怎么设置单个中断的抢占优先级和响应优先级？"><a href="#怎么设置单个中断的抢占优先级和响应优先级？" class="headerlink" title="怎么设置单个中断的抢占优先级和响应优先级？"></a>怎么设置单个中断的抢占优先级和响应优先级？</h2><p>中断设置相关寄存器<br>__IO uint8_t  IP[240]; //中断优先级控制的寄存器组</p>
<p>__IO uint32_t ISER[8]; //中断使能寄存器组<br>__IO uint32_t ICER[8]; //中断失能寄存器组<br>__IO uint32_t ISPR[8]; //中断挂起寄存器组<br>__IO uint32_t ICPR[8]; //中断解挂寄存器组<br>__IO uint32_t IABR[8]; //中断激活标志位寄存器组</p>
<p>MDK中NVIC寄存器结构体:<br>typedef struct<br>{<br>  __IO uint32_t ISER[8];<br>       uint32_t RESERVED0[24];<br>  __IO uint32_t ICER[8];<br>       uint32_t RSERVED1[24];<br>  __IO uint32_t ISPR[8];<br>       uint32_t RESERVED2[24];<br>  __IO uint32_t ICPR[8];<br>       uint32_t RESERVED3[24];<br>  __IO uint32_t IABR[8];<br>       uint32_t RESERVED4[56];<br>  __IO uint8_t  IP[240];<br>       uint32_t RESERVED5[644];<br>  __O  uint32_t STIR;<br>}  NVIC_Type; </p>
<h2 id="对于每个中断怎么设置优先级？"><a href="#对于每个中断怎么设置优先级？" class="headerlink" title="对于每个中断怎么设置优先级？"></a>对于每个中断怎么设置优先级？</h2><p>中断优先级控制的寄存器组：IP[240]<br>全称是：Interrupt Priority Registers</p>
<p>240个8位寄存器，每个中断使用一个寄存器来确定优先级。STM32F10x系列一共60个可屏蔽中断，使用IP[59]~IP[0]。</p>
<p>每个IP寄存器的高4位用来设置抢占和响应优先级（根据分组），低4位没有用到。</p>
<p>void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);</p>
<h2 id="中断使能寄存器组：ISER-8"><a href="#中断使能寄存器组：ISER-8" class="headerlink" title="中断使能寄存器组：ISER[8]"></a>中断使能寄存器组：ISER[8]</h2><p>作用：用来使能中断<br>32位寄存器，每个位控制一个中断的使能。STM32F10x只有60个可屏蔽中断，所以只使用了其中的ISER[0]和ISER[1]。</p>
<p>ISER[0]的bit0<del>bit31分别对应中断0</del>31。ISER[1]的bit0<del>27对应中断32</del>59；</p>
<p>void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);</p>
<h2 id="中断失能寄存器组：ICER-8"><a href="#中断失能寄存器组：ICER-8" class="headerlink" title="中断失能寄存器组：ICER[8]"></a>中断失能寄存器组：ICER[8]</h2><p>作用：用来失能中断<br>32位寄存器，每个位控制一个中断的失能。STM32F10x只有60个可屏蔽中断，所以只使用了其中的ICER[0]和ICER[1]。</p>
<p>ICER[0]的bit0<del>bit31分别对应中断0</del>31。ICER[1]的bit0<del>27对应中断32</del>59；</p>
<p>配置方法跟ISER一样。</p>
<p>void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);</p>
<h2 id="中断挂起控制寄存器组：ISPR-8"><a href="#中断挂起控制寄存器组：ISPR-8" class="headerlink" title="中断挂起控制寄存器组：ISPR[8]"></a>中断挂起控制寄存器组：ISPR[8]</h2><p>作用：用来挂起中断</p>
<h2 id="中断解挂控制寄存器组：ICPR-8"><a href="#中断解挂控制寄存器组：ICPR-8" class="headerlink" title="中断解挂控制寄存器组：ICPR[8]"></a>中断解挂控制寄存器组：ICPR[8]</h2><p>作用：用来解挂中断<br>static __INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)；<br>static __INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)；<br>static __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)</p>
<h2 id="中断参数初始化函数"><a href="#中断参数初始化函数" class="headerlink" title="中断参数初始化函数"></a>中断参数初始化函数</h2><p>void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);</p>
<p>typedef struct<br>{<br>  uint8_t NVIC_IRQChannel; //设置中断通道<br>  uint8_t NVIC_IRQChannelPreemptionPriority;//设置响应优先级<br>  uint8_t NVIC_IRQChannelSubPriority; //设置抢占优先级<br>  FunctionalState NVIC_IRQChannelCmd; //使能/使能<br>} NVIC_InitTypeDef;</p>
<p>NVIC_InitTypeDef   NVIC_InitStructure;<br>NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;//串口1中断<br>NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=1 ;// 抢占优先级为1<br>NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;// 子优先级位2<br>NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;//IRQ通道使能<br>NVIC_Init(&amp;NVIC_InitStructure);    //根据上面指定的参数初始化NVIC寄存器</p>
<h2 id="中断优先级设置步骤"><a href="#中断优先级设置步骤" class="headerlink" title="中断优先级设置步骤"></a>中断优先级设置步骤</h2><p>系统运行后先设置中断优先级分组。调用函数：</p>
<ol>
<li>void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup);<br>整个系统执行过程中，只设置一次中断分组。</li>
<li>针对每个中断，设置对应的抢占优先级和响应优先级：<br>void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);</li>
<li>如果需要挂起/解挂，查看中断当前激活状态，分别调用相关函数即可</li>
</ol>
<h1 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h1><h2 id="通信接口背景知识"><a href="#通信接口背景知识" class="headerlink" title="通信接口背景知识"></a>通信接口背景知识</h2><p>处理器与外部设备通信的两种方式：<br>并行通信<br>   -传输原理：数据各个位同时传输。<br>   -优点：速度快<br>   -缺点：占用引脚资源多</p>
<p>串行通信<br>   -传输原理：数据按位顺序传输。<br>   -优点：占用引脚资源少<br>   -缺点：速度相对较慢</p>
<p>串行通信：<br>按照数据传送方向，分为：<br>单工：<br>         数据传输只支持数据在一个方向上传输<br>半双工：<br>        允许数据在两个方向上传输，但是，在某一时刻，只允许数<br>        据在一个方向上传输，它实际上是一种切换方向的单工通信；<br>全双工：<br>        允许数据同时在两个方向上传输，因此，全双工通信是两个<br>        单工通信方式的结合，它要求发送设备和接收设备都有独立<br>        的接收和发送能力。 </p>
<p>同步通信：带时钟同步信号传输。<br>    SPI，IIC通信接口<br>异步通信：不带时钟同步信号。<br>    UART(通用异步收发器),单总线(要约定波特率)</p>
<p>常见的串行通信接口：</p>
<table>
<thead>
<tr>
<th>通信标准</th>
<th>引脚说明</th>
<th>通信方式</th>
<th>通信方向</th>
</tr>
</thead>
<tbody><tr>
<td>UART(通用异步收发器)</td>
<td>TXD:发送端 RXD:接受端 GND:公共地</td>
<td>异步通信</td>
<td>全双工</td>
</tr>
<tr>
<td>单总线（1-wire)</td>
<td>DQ:发送/接受端</td>
<td>异步通信</td>
<td>半双工</td>
</tr>
<tr>
<td>SPI</td>
<td>SCK:同步时钟 MISO:主机输入，从机输出 MOSI:主机输出，从机输入</td>
<td>同步通信</td>
<td>全双工</td>
</tr>
<tr>
<td>I²C</td>
<td>SCL:同步时钟 SDA:数据输入/输出端</td>
<td>同步通信</td>
<td>半双工</td>
</tr>
</tbody></table>
<p>STM32的串口通信接口：</p>
<p>UART:通用异步收发器<br>USART:通用同步异步收发器<br>大容量STM32F10x系列芯片，包含3个USART和2个UART</p>
<p>UART异步通信方式引脚：<br>-RXD:数据输入引脚。数据接受。<br>-TXD:数据发送引脚。数据发送。</p>
<table>
<thead>
<tr>
<th>串口号</th>
<th>RXD</th>
<th>TXD</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>PA10</td>
<td>PA9</td>
</tr>
<tr>
<td>2</td>
<td>PA3</td>
<td>PA2</td>
</tr>
<tr>
<td>3</td>
<td>PB11</td>
<td>PB10</td>
</tr>
<tr>
<td>4</td>
<td>PC11</td>
<td>PC10</td>
</tr>
<tr>
<td>5</td>
<td>PD2</td>
<td>PC12</td>
</tr>
</tbody></table>
<p>UART异步通信方式特点：<br>全双工异步通信。<br>分数波特率发生器系统，提供精确的波特率。<br>-发送和接受共用的可编程波特率，最高可达4.5Mbits/s<br>可编程的数据字长度（8位或者9位）；<br>可配置的停止位（支持1或者2位停止位）；<br>可配置的使用DMA多缓冲器通信。<br>单独的发送器和接收器使能位。<br>检测标志：① 接受缓冲器  ②发送缓冲器空 ③传输结束标志<br>多个带标志的中断源。触发中断。<br>其他：校验控制，四个错误检测标志。</p>
<p>STM32串口异步通信需要定义的参数：<br> 起始位<br> 数据位（8位或者9位）<br> 奇偶校验位（第9位）<br> 停止位（1,15,2位）<br> 波特率设置</p>
<h2 id="STM32串口常用寄存器和库函数"><a href="#STM32串口常用寄存器和库函数" class="headerlink" title="STM32串口常用寄存器和库函数"></a>STM32串口常用寄存器和库函数</h2><p>常用的串口相关寄存器:<br>USART_SR状态寄存器<br>USART_DR数据寄存器<br>USART_BRR波特率寄存器<br>串口操作相关库函数（省略入口参数）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void USART_Init(); //串口初始化：波特率，数据字长，奇偶校验，硬件流控以及收发使能</span><br><span class="line">void USART_Cmd();//使能串口</span><br><span class="line">void USART_ITConfig();//使能相关中断</span><br><span class="line"></span><br><span class="line">void USART_SendData();//发送数据到串口，DR</span><br><span class="line">uint16_t USART_ReceiveData();//接受数据，从DR读取接受到的数据</span><br><span class="line"></span><br><span class="line">FlagStatus USART_GetFlagStatus();//获取状态标志位</span><br><span class="line">void USART_ClearFlag();//清除状态标志位</span><br><span class="line">ITStatus USART_GetITStatus();//获取中断状态标志位</span><br><span class="line">void USART_ClearITPendingBit();//清除中断状态标志位</span><br></pre></td></tr></table></figure>
<h3 id="串口初始化函数"><a href="#串口初始化函数" class="headerlink" title="串口初始化函数"></a>串口初始化函数</h3><p>找到初始化函数的声明：<br>void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)<br>两个入口参数分别是<br>串口标号USARTx和一个结构体USART_InitStruct 找到结构体的定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  uint32_t USART_BaudRate;     //波特率       </span><br><span class="line"></span><br><span class="line">  uint16_t USART_WordLength;   //字长     </span><br><span class="line">  uint16_t USART_StopBits;     //停止位       </span><br><span class="line"></span><br><span class="line">  uint16_t USART_Parity;      //奇偶校验位        </span><br><span class="line">  uint16_t USART_Mode;        //发送接收使能位</span><br><span class="line"></span><br><span class="line">  uint16_t USART_HardwareFlowControl;   //硬件流设置</span><br><span class="line">&#125; USART_InitTypeDef;</span><br></pre></td></tr></table></figure>
<h3 id="串口配置的一般步骤"><a href="#串口配置的一般步骤" class="headerlink" title="串口配置的一般步骤"></a>串口配置的一般步骤</h3><p>串口时钟使能，GPIO时钟使能:RCC_APB2PeriphClockCmd();<br>串口复位:USART_DeInit(); 这一步不是必须的<br>GPIO端口模式设置:GPIO_Init(); 模式设置为GPIO_Mode_AF_PP<br>串口参数初始化：USART_Init();<br>开启中断并且初始化NVIC（如果需要开启中断才需要这个步骤）<br>      NVIC_Init();<br>      USART_ITConfig();<br>⑥使能串口:USART_Cmd();<br>⑦编写中断处理函数：USARTx_IRQHandler();<br>⑧串口数据收发：<br>void USART_SendData();//发送数据到串口，DR<br>uint16_t USART_ReceiveData();//接受数据，从DR读取接受到的数据<br>⑨串口传输状态获取：<br>FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG);<br>void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);</p>
<p>PA9 PA10复用为串口1</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">void My_USART1_Init(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStruct;				//定义一个GPIO结构体</span><br><span class="line">	USART_InitTypeDef USART_InitStruct;				//定义一个串口结构体</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStruct;				//定义一个中断结构体</span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);		//GPIO时钟使能</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);		//串口时钟使能</span><br><span class="line">	</span><br><span class="line">	//初始化GPIO结构体和GPIO引脚</span><br><span class="line">	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;    //推挽输出</span><br><span class="line">	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_9;			//输出引脚</span><br><span class="line">	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_10MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStruct);				//GPIOA9初始化</span><br><span class="line">	/*************************************************************************/</span><br><span class="line">	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;		//浮空输入</span><br><span class="line">	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_10;					//输出引脚</span><br><span class="line">	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_10MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStruct);						//GPIOA10初始化</span><br><span class="line">	/*************************************************************************/</span><br><span class="line">	</span><br><span class="line">	//初始化串口</span><br><span class="line">	USART_InitStruct.USART_BaudRate = 115200;				//设置波特率</span><br><span class="line">	USART_InitStruct.USART_HardwareFlowControl =	USART_HardwareFlowControl_None; //不使用硬件流</span><br><span class="line">	USART_InitStruct.USART_Mode = USART_Mode_Rx|USART_Mode_Tx; //使能发送和接受</span><br><span class="line">	USART_InitStruct.USART_Parity = USART_Parity_No;     //不用奇偶校验</span><br><span class="line">	USART_InitStruct.USART_StopBits = USART_StopBits_1;  //停止位设为1</span><br><span class="line">	USART_InitStruct.USART_WordLength = USART_WordLength_8b; //字长设为8</span><br><span class="line">	USART_Init(USART1,&amp;USART_InitStruct);</span><br><span class="line">	</span><br><span class="line">	//串口使能函数</span><br><span class="line">	USART_Cmd(USART1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	//打开接收中断</span><br><span class="line">	USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);</span><br><span class="line">	</span><br><span class="line">	//设置相应中断</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannel =	USART1_IRQn;		//设置通道</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;			//开启通道</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 1; //中断优先级分组为2</span><br><span class="line">                                                      //抢占优先级为0.1.2，3都可</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelSubPriority =1;    //子优先级</span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStruct);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void USART1_IRQHandler(void)						//中断服务函数</span><br><span class="line">&#123;</span><br><span class="line">	u8 res;</span><br><span class="line">	if(USART_GetITStatus(USART1,USART_IT_RXNE))		//接收到数据</span><br><span class="line">	&#123;</span><br><span class="line">		res=USART_ReceiveData(USART1);				//读取数据</span><br><span class="line">		USART_SendData(USART1,res);					//发送出去</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	//要使用中断的话要使用NVIC_PriorityGroupConfig函数</span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);	  //设优先级分组为2</span><br><span class="line">	My_USART1_Init();</span><br><span class="line">	while(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>先将程序下载进开发板<br>打开串口调试助手 XCOM V2.6<br>测试成功</p>
<h1 id="外部中断实验"><a href="#外部中断实验" class="headerlink" title="外部中断实验"></a>外部中断实验</h1><h2 id="外部中断概述"><a href="#外部中断概述" class="headerlink" title="外部中断概述"></a>外部中断概述</h2><p>STM32的每个IO都可以作为外部中断输入。<br>STM32的中断控制器支持19个外部中断/事件请求：<br>线0~15：对应外部IO口的输入中断。<br>线16：连接到PVD输出。<br>线17：连接到RTC闹钟事件。<br>线18：连接到USB唤醒事件。</p>
<p>每个外部中断线可以独立的配置触发方式（上升沿，下降沿或者双边沿触发），触发/屏蔽，专用的状态位。</p>
<p>从上面可以看出，STM32供IO使用的中断线只有16个，但是STM32F10x系列的IO口多达上百个，STM32F103ZET6(112),<br>STM32F103RCT6(51)，那么中断线怎么跟io口对应呢？</p>
<p>GPIOx.0映射到EXTI0<br>GPIOx.1映射到EXTI1<br>…<br>GPIOx.15映射到EXTI15</p>
<p>对于每个中断线，我们可以设置相应的触发方式（上升沿触发，下降沿触发，边沿触发）以及使能。</p>
<p>是不是16个中断线就可以分配16个中断服务函数呢？</p>
<p>IO口外部中断在中断向量表中只分配了7个中断向量，也就是只能使用7个中断服务函数<br>外部中断线0<del>4各分配一个中断向量，共五个服务函数<br>外部中断线5</del>9分配一个中断向量，共用一个服务函数<br>外部中断线10~15分配一个中断向量，共用一个中断服务函数。</p>
<p>中断服务函数列表：<br>EXTI0_IRQHandler<br>EXTI1_IRQHandler<br>EXTI2_IRQHandler<br>EXTI3_IRQHandler<br>EXTI4_IRQHandler<br>EXTI9_5_IRQHandler<br>EXTI15_10_IRQHandler    </p>
<h2 id="外部中断常用库函数"><a href="#外部中断常用库函数" class="headerlink" title="外部中断常用库函数"></a>外部中断常用库函数</h2><p>①void GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource);<br>//设置IO口与中断线的映射关系</p>
<p>exp:  GPIO_EXTILineConfig(GPIO_PortSourceGPIOE,GPIO_PinSource2);</p>
<p>②void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct);<br> //初始化中断线：触发方式等</p>
<p>③ITStatus EXTI_GetITStatus(uint32_t EXTI_Line);<br>//判断中断线中断状态，是否发生</p>
<p>④void EXTI_ClearITPendingBit(uint32_t EXTI_Line);<br>//清除中断线上的中断标志位</p>
<h3 id="EXTI-Init函数"><a href="#EXTI-Init函数" class="headerlink" title="EXTI_Init函数"></a>EXTI_Init函数</h3><p>void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  uint32_t EXTI_Line;   //指定要配置的中断线           </span><br><span class="line">  EXTIMode_TypeDef EXTI_Mode;   //模式：事件 OR中断</span><br><span class="line">  EXTITrigger_TypeDef EXTI_Trigger;//触发方式：上升沿/下降沿/双沿触发</span><br><span class="line">  FunctionalState EXTI_LineCmd;  //使能 OR失能</span><br><span class="line">&#125;EXTI_InitTypeDef;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXTI_InitStructure.EXTI_Line=EXTI_Line2;	 </span><br><span class="line">EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;	</span><br><span class="line">EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;</span><br><span class="line">EXTI_InitStructure.EXTI_LineCmd = ENABLE;</span><br><span class="line">EXTI_Init(&amp;EXTI_InitStructure);</span><br></pre></td></tr></table></figure>
<h2 id="外部中断的一般配置步骤："><a href="#外部中断的一般配置步骤：" class="headerlink" title="外部中断的一般配置步骤："></a>外部中断的一般配置步骤：</h2><p>1.初始化IO口为输入。<br>    GPIO_Init();</p>
<p>2.开启IO口复用时钟。<br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);</p>
<p>3.设置IO口与中断线的映射关系。<br>    void GPIO_EXTILineConfig();</p>
<p>4.初始化线上中断，设置触发条件等。<br>    EXTI_Init();</p>
<p>5.配置中断分组（NVIC），并使能中断。<br>    NVIC_Init();</p>
<p>6.编写中断服务函数。<br>    EXTIx_IRQHandler();</p>
<p>7.清除中断标志位<br>    EXTI_ClearITPendingBit();</p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;led.h&quot;</span><br><span class="line">#include &quot;delay.h&quot;</span><br><span class="line">#include &quot;key.h&quot;</span><br><span class="line">#include &quot;sys.h&quot;</span><br><span class="line">#include &quot;beep.h&quot;</span><br><span class="line">#include &quot;usart.h&quot;</span><br><span class="line">#include &quot;exti.h&quot;</span><br><span class="line"></span><br><span class="line"> int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	delay_init();</span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">	uart_init(115200);	//串口初始化为115200</span><br><span class="line">	LED_Init();					//初始化LED</span><br><span class="line">	BEEP_Init();				//初始化蜂鸣器</span><br><span class="line">	KEY_Init();					//初始化按键</span><br><span class="line">	EXTIX_Init();				//初始化外部中断</span><br><span class="line">	LED0=0;							//点亮LED</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">				printf(&quot;OK\n\r&quot;);</span><br><span class="line">				delay_ms(1000);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="看门狗实验"><a href="#看门狗实验" class="headerlink" title="看门狗实验"></a>看门狗实验</h1><h2 id="独立看门狗概述"><a href="#独立看门狗概述" class="headerlink" title="独立看门狗概述"></a>独立看门狗概述</h2><p>为什么要看门狗？<br>在由单片机构成的微型计算机系统中，由于单片机的工作常常会受到来自外界电磁场的干扰，造成程序的跑飞，而陷入死循环，程序的正常运行被打断，由单片机控制的系统无法继续工作，会造成整个系统的陷入停滞状态，发生不可预料的后果，所以出于对单片机运行状态进行实时监测的考虑，便产生了一种专门用于监测单片机程序运行状态的模块或者芯片，俗称“看门狗”(watchdog) 。</p>
<p>看门狗解决的问题是什么？<br>在启动正常运行的时候，系统不能复位。<br>在系统跑飞（程序异常执行）的情况，系统复位，程序重新执行。</p>
<p>STM32内置两个看门狗，提供了更高的安全性，时间的精确性和使用的灵活性。两个看门狗设备（独立看门狗/窗口看门狗)可以用来检测和解决由软件错误引起的故障。当计数器达到给定的超时值时，触发一个中断（仅适用窗口看门狗）或者产生系统复位。<br>独立看门狗（IWDG)由专用的低速时钟（LSI)驱动，即使主时钟发生故障它仍有效。<br>独立看门狗适合应用于需要看门狗作为一个在主程序之外 能够完全独立工作，并且对时间精度要求低的场合。<br>窗口看门狗由从APB1时钟分频后得到时钟驱动。通过可配置的时间窗口来检测应用程序非正常的过迟或过早操作。<br>窗口看门狗最适合那些要求看门狗在精确计时窗口起作用的程序。</p>
<p>独立看门狗功能描述：<br>1.在键值寄存器（IWDG_KR)中写入0xCCCC，开始启用独立看门狗。此时计数器开始从其复位值0xFFF递减，当计数器值计数到尾值0x000时会产生一个复位信号（IWDG_RESET)。<br>2.无论何时，只要在键值寄存器IWDG_KR中写入0xAAAA（通常说的喂狗）, 自动重装载寄存器IWDG_RLR的值就会重新加载到计数器，从而避免看门狗复位。<br>3.如果程序异常，就无法正常喂狗，从而系统复位。</p>
<p>键值寄存器IWDG_KR: 0<del>15位有效<br>预分频寄存器IWDG_PR：0</del>2位有效。具有写保护功能，要操作先取消写保护<br>重装载寄存器IWDG_RLR：0<del>11位有效。具有写保护功能，要操作先取消写保护。<br>状态寄存器IWDG_SR：0</del>1位有效</p>
<p>取消写保护：写入0x5555表示允许访问IWDG_PR和IWDG_RLR寄存器</p>
<h3 id="独立看门狗超时时间"><a href="#独立看门狗超时时间" class="headerlink" title="独立看门狗超时时间"></a>独立看门狗超时时间</h3><p>溢出时间计算：<br>   Tout=((4×2^prer) ×rlr) /40 （M3)</p>
<h2 id="IWDG独立看门狗操作库函数"><a href="#IWDG独立看门狗操作库函数" class="headerlink" title="IWDG独立看门狗操作库函数"></a>IWDG独立看门狗操作库函数</h2><p>void IWDG_WriteAccessCmd(uint16_t IWDG_WriteAccess);//取消写保护：0x5555使能<br>void IWDG_SetPrescaler(uint8_t IWDG_Prescaler);     //设置预分频系数：写PR<br>void IWDG_SetReload(uint16_t Reload);               //设置重装载值：写RLR<br>void IWDG_ReloadCounter(void);                      //喂狗：写0xAAAA到KR<br>void IWDG_Enable(void);                             //使能看门狗：写0xCCCC到KR<br>FlagStatus IWDG_GetFlagStatus(uint16_t IWDG_FLAG);  //状态：重装载/预分频 更新</p>
<p>独立看门狗操作步骤：<br>①  取消寄存器写保护：<br>      IWDG_WriteAccessCmd();<br>②  设置独立看门狗的预分频系数，确定时钟:<br>     IWDG_SetPrescaler();<br>③  设置看门狗重装载值，确定溢出时间:<br>    IWDG_SetReload();<br>④  使能看门狗<br>    IWDG_Enable();<br>⑤  应用程序喂狗:<br>   IWDG_ReloadCounter();</p>
<p>溢出时间计算：<br>   Tout=((4×2^prer) ×rlr) /40 （M3)</p>
<h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><p>#include “led.h”<br>#include “delay.h”<br>#include “key.h”<br>#include “sys.h”<br>#include “beep.h”<br>#include “usart.h”<br>#include “exti.h”<br>#include “wdg.h”<br> int main(void)<br>{<br>    delay_init();<br>    LED_Init();<br>    KEY_Init();<br>    BEEP_Init();</p>
<pre><code>IWDG_Init(4,625);//1s

delay_ms(200);
LED0=0;

while(1)
&#123;
    if(KEY_Scan(0)==WKUP_PRES)
    &#123;
        IWDG_ReloadCounter();
    &#125;
&#125;
</code></pre>
<p>}</p>
<h1 id="TFTLCD显示实验"><a href="#TFTLCD显示实验" class="headerlink" title="TFTLCD显示实验"></a>TFTLCD显示实验</h1><h2 id="TFTLCD驱动原理-TFTLCD简介"><a href="#TFTLCD驱动原理-TFTLCD简介" class="headerlink" title="TFTLCD驱动原理-TFTLCD简介"></a>TFTLCD驱动原理-TFTLCD简介</h2><p>TFTLCD即薄膜晶体管液晶显示器。它与无源TN-LCD、STN-LCD的简单矩阵不同，它在液晶显示屏的每一个像素上都设置有一个薄膜晶体管（TFT），可有效地克服非选通时的串扰，使显示液晶屏的静态特性与扫描线数无关，因此大大提高了图像质量。</p>
<p>TFTLCD具有：亮度好、对比度高、层次感强、颜色鲜艳等特点。是目前最主流的LCD显示器。广泛应用于电视、手机、电脑、平板等各种电子产品。</p>
<p>ATK-4.3寸 TFTLCD模块<br>分辨率：480*800，驱动IC：NT35510，电容触摸屏，16位并口驱动</p>
<h3 id="ALINETEK-2-8寸-TFTLCD接口说明（16位80并口）："><a href="#ALINETEK-2-8寸-TFTLCD接口说明（16位80并口）：" class="headerlink" title="ALINETEK 2.8寸 TFTLCD接口说明（16位80并口）："></a>ALINETEK 2.8寸 TFTLCD接口说明（16位80并口）：</h3><p>注意：DB1<del>DB8，DB10</del>DB17，总是按顺序连接MCU的D0~D15</p>
<p>LCD_CS：LCD片选信号<br>LCD_WR：LCD写信号<br>LCD_RD：LCD读信号<br>DB[17：1]：16位双向数据线。<br>LCD_RST：硬复位LCD信号<br>LCD_RS：命令/数据标志<br>        (0:命令,1:数据)<br>BL_CTR：背光控制信号<br>T_MISO/T_MOSI/T_PEN/T_CS/T_CLK，触摸屏接口信号</p>
<h3 id="ALINETEK-2-8寸-TFTLCD-16位80并口驱动简介"><a href="#ALINETEK-2-8寸-TFTLCD-16位80并口驱动简介" class="headerlink" title="ALINETEK 2.8寸 TFTLCD 16位80并口驱动简介"></a>ALINETEK 2.8寸 TFTLCD 16位80并口驱动简介</h3><p>模块的8080并口读/写的过程为：<br>先根据要写入/读取的数据的类型，设置RS为高（数据）/低（命令），然后拉低片选，选中ILI9341，接着我们根据是读数据，还是要写数据置RD/WR为低，然后：<br>1.读数据：在RD的上升沿， 读取数据线上的数据（D[15:0]）;<br>2.写数据：在WR的上升沿，使数据写入到ILI9341里面</p>
<h3 id="ILI9341-驱动时序"><a href="#ILI9341-驱动时序" class="headerlink" title="ILI9341 驱动时序"></a>ILI9341 驱动时序</h3><p>右图为：ILI9341 8080并口时序，详见：ILI9341_DS.pdf，232页<br>重点时序：<br>读ID低电平脉宽(trdl)<br>读ID高电平脉宽(trdh)<br>读FM低电平脉宽(trdlfm)<br>读FM高电平脉宽(trdhfm)<br>写控制低电平脉宽(twrl)<br>写控制高电平脉宽(twrh)</p>
<p>注意：ID指LCD的ID号<br>FM指帧缓存，即:GRAM </p>
<h3 id="驱动流程"><a href="#驱动流程" class="headerlink" title="驱动流程"></a>驱动流程</h3><p>1.硬复位 LCD_RST=0; delay_ms(100); LCD_RST=1;<br>2.初始化序列→设置坐标<br>2.1写GRAM指令→写入颜色数据→LCD显示<br>2.3读GRAM指令→读出颜色数据→单片机处理</p>
<h3 id="RGB565格式说明"><a href="#RGB565格式说明" class="headerlink" title="RGB565格式说明"></a>RGB565格式说明</h3><p>模块对外接口采用16位并口，颜色深度为16位，格式为RGB565</p>
<table>
<thead>
<tr>
<th>数据线</th>
<th>D15</th>
<th>D14</th>
<th>D13</th>
<th>D12</th>
<th>D11</th>
<th>D10</th>
<th>D9</th>
<th>D8</th>
<th>D7</th>
<th>D6</th>
<th>D5</th>
<th>D4</th>
<th>D3</th>
<th>D2</th>
<th>D1</th>
<th>D0</th>
</tr>
</thead>
<tbody><tr>
<td>LCD GRAM</td>
<td>R[4]</td>
<td>R[3]</td>
<td>R[2]</td>
<td>R[1]</td>
<td>R[0]</td>
<td>G[5]</td>
<td>G[4]</td>
<td>G[3]</td>
<td>G[2]</td>
<td>G[1]</td>
<td>G[0]</td>
<td>B[4]</td>
<td>B[3]</td>
<td>B[2]</td>
<td>B[1]</td>
<td>B[0]</td>
</tr>
</tbody></table>
<p>0xF800=1111 1000 0000 0000 对应R[4]R[3]R[2]R[1]R[0]为1 其余为0 所以是红色 </p>
<h2 id="ILI9341指令格式说明"><a href="#ILI9341指令格式说明" class="headerlink" title="ILI9341指令格式说明"></a>ILI9341指令格式说明</h2><p>ILI9341所有的指令都是8位的（高8位无效），且参数除了读写GRAM的时候是16位，其他操作参数，都是8位的。</p>
<p>ILI9341的指令很多，这里不一一介绍，仅介绍几个重要的指令，他们是：0XD3，0X36，0X2A，0X2B，0X2C，0X2E等6条指令。</p>
<h3 id="0XD3指令"><a href="#0XD3指令" class="headerlink" title="0XD3指令"></a>0XD3指令</h3><p>该指令为读ID4指令，用于读取LCD控制器的ID 。因此，同一个代码，可以根据ID的不同，执行不同的LCD驱动初始化，以兼容不同的LCD屏幕。</p>
<h3 id="0X36指令"><a href="#0X36指令" class="headerlink" title="0X36指令"></a>0X36指令</h3><p>该指令为存储访问控制指令，可以控制ILI9341存储器的读写方向，简单的说，就是在连续写GRAM的时候，可以控制GRAM指针的增长方向，从而控制显示方式（读GRAM也是一样）。</p>
<h3 id="0X2A指令"><a href="#0X2A指令" class="headerlink" title="0X2A指令"></a>0X2A指令</h3><p>该指令是列地址设置指令，在从左到右，从上到下的扫描方式（默认）下面，该指令用于设置横坐标（x坐标）</p>
<h3 id="0X2B指令"><a href="#0X2B指令" class="headerlink" title="0X2B指令"></a>0X2B指令</h3><p>该指令是页地址设置指令，在从左到右，从上到下的扫描方式（默认）下面，该指令用于设置纵坐标（y坐标）</p>
<h3 id="0X2C指令"><a href="#0X2C指令" class="headerlink" title="0X2C指令"></a>0X2C指令</h3><p>该指令是写GRAM指令，在发送该指令之后，我们便可以往LCD的GRAM里面写入颜色数据了，该指令支持连续写 (地址自动递增)</p>
<h3 id="0X2E指令"><a href="#0X2E指令" class="headerlink" title="0X2E指令"></a>0X2E指令</h3><p>该指令是读GRAM指令，用于读取ILI9341的显存（GRAM），同0X2C指令，该指令支持连续读 (地址自动递增)</p>
<h2 id="FSMC简介-FSMC介绍"><a href="#FSMC简介-FSMC介绍" class="headerlink" title="FSMC简介-FSMC介绍"></a>FSMC简介-FSMC介绍</h2><p>FSMC，即灵活的静态存储控制器，能够与同步或异步存储器和16位PC存储器卡连接，STM32的FSMC接口支持包括SRAM、NAND FLASH、NOR FLASH和PSRAM等存储器。FSMC的框图如下图所示：</p>
<p>FSMC驱动外部SRAM时，外部SRAM的控制一般有：地址线（如A0<del>A25）、数据线（如D0</del>D15）、写信号（WE，即WR）、读信号（OE，即RD）、片选信号（CS），如果SRAM支持字节控制，那么还有UB/LB信号。</p>
<h3 id="FSMC驱动LCD的原理"><a href="#FSMC驱动LCD的原理" class="headerlink" title="FSMC驱动LCD的原理"></a>FSMC驱动LCD的原理</h3><p>而TFTLCD的信号我们在前面介绍过，包括：RS、D0<del>D15、WR、RD、CS、RST和BL等，其中真正在操作LCD的时候需要用到的就只有：RS、D0</del>D15、WR、RD和CS。其操作时序和SRAM的控制完全类似，唯一不同就是TFTLCD有RS信号，但是没有地址信号。</p>
<p>TFTLCD通过RS信号来决定传送的数据是数据还是命令，本质上可以理解为一个地址信号，比如我们把RS接在A0上面，那么当FSMC控制器写地址0的时候，会使得A0变为0，对TFTLCD来说，就是写命令。而FSMC写地址1的时候，A0将会变为1，对TFTLCD来说，就是写数据了。这样，就把数据和命令区分开了，他们其实就是对应SRAM操作的两个连续地址。当然RS也可以接在其他地址线上，战舰V3和精英板开发板都是把RS连接在A10上面，而探索者STM32F4把RS接在A6上面。</p>
<p>因此，可以把TFTLCD当成一个SRAM来用，只不过这个SRAM有2个地址，这就是FSMC可以驱动LCD的原理。</p>
<h3 id="存储块1-操作简介"><a href="#存储块1-操作简介" class="headerlink" title="存储块1 操作简介"></a>存储块1 操作简介</h3><p>STM32的FSMC存储块1（Bank1）用于驱动NOR FLASH/SRAM/PSRAM，被分为4个区，每个区管理64M字节空间，每个区都有独立的寄存器对所连接的存储器进行配置。Bank1的256M字节空间由28根地址线（HADDR[27:0]）寻址。<br>这里HADDR，是内部AHB地址总线，其中，HADDR[25:0]来自外部存储器地址FSMC_A[25:0]，而HADDR[26:27]对4个区进行寻址。<br>当Bank1接的是16位宽度存储器的时候：HADDR[25:1] FSMC_A[24:0]<br>当Bank1接的是8位宽度存储器的时候：HADDR[25:0] FSMC_A[25:0]</p>
<p>不论外部接8位/16位宽设备，FSMC_A[0]永远接在外部设备地址A[0]</p>
<p>STM32的FSMC存储块1 支持的异步突发访问模式包括：模式1、模式A~D等多种时序模型，驱动SRAM时一般使用模式1或者模式 A，这里我们使用模式A来驱动LCD（当SRAM用）</p>
<p>模式A支持读写时序分开设置！ 对STM32F4仅写时序DATAST需要+1</p>
<h3 id="FSMC简介-寄存器介绍"><a href="#FSMC简介-寄存器介绍" class="headerlink" title="FSMC简介-寄存器介绍"></a>FSMC简介-寄存器介绍</h3><p>对于NOR FLASH/PSRAM控制器(存储块1)，通过FSMC_BCRx、FSMC_BTRx和FSMC_BWTRx寄存器设置（其中x=1~4，对应4个区）。通过这3个寄存器，可以设置FSMC访问外部存储器的时序参数，拓宽了可选用的外部存储器的速度范围。  </p>
<h4 id="SRAM-NOR闪存片选控制寄存器（FSMC-BCRx）"><a href="#SRAM-NOR闪存片选控制寄存器（FSMC-BCRx）" class="headerlink" title="SRAM/NOR闪存片选控制寄存器（FSMC_BCRx）"></a>SRAM/NOR闪存片选控制寄存器（FSMC_BCRx）</h4><p>EXTMOD：扩展模式使能位，控制是否允许读写不同的时序，需设置为1<br>WREN：写使能位。我们需要向TFTLCD写数据，故该位必须设置为1<br>MWID[1:0]：存储器数据总线宽度。00，表示8位数据模式；01表示16位数据模式；10和11保留。我们的TFTLCD是16位数据线，所以设置WMID[1:0]=01。<br>MTYP[1:0]：存储器类型。00表示SRAM、ROM；01表示PSRAM；10表示NOR FLASH;11保留。我们把LCD当成SRAM用，所以需要设置MTYP[1:0]=00。<br>MBKEN：存储块使能位。需设置为1</p>
<h4 id="SRAM-NOR闪存片选时序寄存器（FSMC-BTRx）"><a href="#SRAM-NOR闪存片选时序寄存器（FSMC-BTRx）" class="headerlink" title="SRAM/NOR闪存片选时序寄存器（FSMC_BTRx）"></a>SRAM/NOR闪存片选时序寄存器（FSMC_BTRx）</h4><p>ACCMOD[1:0]：访问模式。00:模式A；01:模式B；10:模式C；11:模式D。<br>DATAST[7:0]：数据保持时间，等于: DATAST(+1)个HCLK时钟周期，DATAST最大为255。对ILI9341来说，其实就是RD低电平持续时间，最大为355ns。对STM32F1，一个HCLK=13.8ns (1/72M)，设置为15；对STM32F4，一个HCLK=6ns(1/168M) ，设置为60。<br>ADDSET[3:0]：地址建立时间。表示：ADDSET (+1)个HCLK周期，ADDSET最大为15。对ILI9341来说，这里相当于RD高电平持续时间，为90ns。STM32F1的FSMC性能存在问题，即便设置为0，RD也有190ns的高电平，我们这里设置为1。而对STM32F4，则设置为15。 </p>
<h4 id="SRAM-NOR闪存写时序寄存器（FSMC-BWTRx）"><a href="#SRAM-NOR闪存写时序寄存器（FSMC-BWTRx）" class="headerlink" title="SRAM/NOR闪存写时序寄存器（FSMC_BWTRx）"></a>SRAM/NOR闪存写时序寄存器（FSMC_BWTRx）</h4><p>ACCMOD[1:0]：访问模式。00:模式A；01:模式B；10:模式C；11:模式D。<br>DATAST[7:0]：数据保持时间，等于: DATAST(+1)个HCLK时钟周期，DATAST最大为255。对ILI9341来说，其实就是WR低电平持续时间，为15ns，不过ILI9320等则需要50ns。考虑兼容性，对STM32F1，一个HCLK=13.8ns (1/72M)，设置为3；对STM32F4，一个HCLK=6ns(1/168M) ，设置为9。<br>ADDSET[3:0]：地址建立时间。表示：ADDSET+1个HCLK周期，ADDSET最大为15。对ILI9341来说，这里相当于WR高电平持续时间，为15ns。同样考虑兼容ILI9320，对STM32F1，这里即便设置为1，WR也有100ns的高电平，我们这里设置为1。而对STM32F4，则设置为8。 </p>
<h3 id="寄存器组合说明"><a href="#寄存器组合说明" class="headerlink" title="寄存器组合说明"></a>寄存器组合说明</h3><p>在ST官方库提供的的寄存器定义里面，并没有定义FSMC_BCRx、FSMC_BTRx、FSMC_BWTRx等这个单独的寄存器，而是将他们进行了一些组合。规律如下：</p>
<p>FSMC_BCRx和FSMC_BTRx，组合成BTCR[8]寄存器组，他们的对应关系如下：<br>BTCR[0]对应FSMC_BCR1，BTCR[1]对应FSMC_BTR1<br>BTCR[2]对应FSMC_BCR2，BTCR[3]对应FSMC_BTR2<br>BTCR[4]对应FSMC_BCR3，BTCR[5]对应FSMC_BTR3<br>BTCR[6]对应FSMC_BCR4，BTCR[7]对应FSMC_BTR4 </p>
<p>FSMC_BWTRx则组合成BWTR[7]，他们的对应关系如下：<br>BWTR[0]对应FSMC_BWTR1，BWTR[2]对应FSMC_BWTR2，<br>BWTR[4]对应FSMC_BWTR3，BWTR[6]对应FSMC_BWTR4，<br>BWTR[1]、BWTR[3]和BWTR[5]保留，没有用到。</p>
<h2 id="程序函数"><a href="#程序函数" class="headerlink" title="程序函数"></a>程序函数</h2><h3 id="硬件连接"><a href="#硬件连接" class="headerlink" title="硬件连接"></a>硬件连接</h3><p>LCD_BL(背光控制)对应 PB0;<br>LCD_CS 对应 PG12 即 FSMC_NE4;<br>LCD _RS 对应 PG0 即 FSMC_A10;<br>LCD _WR 对应 PD5 即 FSMC_NWE;<br>LCD _RD 对应 PD4 即 FSMC_NOE;<br>LCD _D[15:0]则直接连接在 FSMC_D15~FSMC_D0;</p>
<h3 id="LCD结构体"><a href="#LCD结构体" class="headerlink" title="LCD结构体"></a>LCD结构体</h3><p>//LCD地址结构体<br>typedef struct<br>{<br>        vu16 LCD_REG;<br>        vu16 LCD_RAM;<br>} LCD_TypeDef;<br>//使用NOR/SRAM的 Bank1.sector4,地址位HADDR[27,26]=11 A10作为数据命令区分线<br>//注意设置时STM32内部会右移一位对其!<br>#define LCD_BASE        ((u32)(0x6C000000 | 0x000007FE))<br>#define LCD             ((LCD_TypeDef *) LCD_BASE)</p>
<p>LCD_BASE，须根据外部电路的连接来确定，如Bank1.sector4就是从地址0X6C000000开<br>始，而0X000007FE，则是A10的偏移量。以A10为例，7FE换成二进制为：111 1111 1110<br>，而16位数据时，地址右移一位对齐，对应到地址引脚，就是：A10:A0=011 1111 1111，<br>此时A10是0，但是如果16位地址再加1（对应到8位地址是加2，即7FE+0X02），那么：<br>A10:A0=100 0000 0000，此时A10就是1了，即实现了对RS的0和1的控制。</p>
<p>我们将这个地址强制转换为LCD_TypeDef结构体地址，那么可以得到LCD-&gt;LCD_REG的<br>地址就是0X6C00,07FE，对应A10的状态为0(即RS=0)，而LCD-&gt; LCD_RAM的地址就是<br>0X6C00,0800（结构体地址自增），对应A10的状态为1（即RS=1），从而实现对RS的控<br>制。 </p>
<p>//LCD 重要参数集<br>typedef struct<br>{<br>u16 width; //LCD 宽度<br>u16 height; //LCD 高度<br>u16 id; //LCD ID<br>u8 dir; //横屏还是竖屏控制：0，竖屏；1，横屏。<br>u16 wramcmd; //开始写 gram 指令<br>u16 setxcmd; //设置 x 坐标指令<br>u16 setycmd; //设置 y 坐标指令<br>}_lcd_dev;<br>//LCD 参数<br>extern _lcd_dev lcddev; //管理 LCD 重要参数</p>
<p>cddev结构体参数的赋值，基本上都是在LCD_Display_Dir函数完成</p>
<h3 id="7个底层接口函数："><a href="#7个底层接口函数：" class="headerlink" title="7个底层接口函数："></a>7个底层接口函数：</h3><p>1，写寄存器值函数 ：void LCD_WR_REG(u16 regval)<br>2，写数据函数：void LCD_WR_DATA(u16 data)<br>3，读数据函数：u16 LCD_RD_DATA(void)<br>4，写寄存器内容函数： void LCD_WriteReg(u16 LCD_Reg, u16 LCD_RegValue)<br>5，读寄存器内容函数： u16 LCD_ReadReg(u16 LCD_Reg)<br>6，开始写GRAM函数： void LCD_WriteRAM_Prepare(void)<br>7，写GRAM函数： void LCD_WriteRAM(u16 RGB_Code)</p>
<h3 id="LCD初始化函数伪代码："><a href="#LCD初始化函数伪代码：" class="headerlink" title="LCD初始化函数伪代码："></a>LCD初始化函数伪代码：</h3><p>//LCD初始化<br>void LCD_Init(void)<br>{<br>    初始化GPIO;<br>    初始化FSMC;<br>    读取LCD ID;<br>    printf(“LCD ID:%x\r\n”,lcddev.id);//打印LCD ID，用到了串口1<br>                                        //所以必须初始化串口1，否则黑屏<br>    根据不同的ID执行LCD初始化代码;<br>    LCD_Display_Dir(0);             //默认为竖屏<br>    LCD_LED=1;                 //点亮背光<br>    LCD_Clear(WHITE);            //清屏<br>}</p>
<h3 id="LCD坐标设置函数"><a href="#LCD坐标设置函数" class="headerlink" title="LCD坐标设置函数"></a>LCD坐标设置函数</h3><p>//设置光标位置<br>//Xpos:横坐标<br>//Ypos:纵坐标<br>void LCD_SetCursor(u16 Xpos, u16 Ypos)<br>{<br>     if(lcddev.id==0X9341||lcddev.id==0X5310)<br>     {<br>          LCD_WR_REG(lcddev.setxcmd);<br>          LCD_WR_DATA(Xpos&gt;&gt;8);<br>          LCD_WR_DATA(Xpos&amp;0XFF);<br>          LCD_WR_REG(lcddev.setycmd);<br>     LCD_WR_DATA(Ypos&gt;&gt;8);<br>     LCD_WR_DATA(Ypos&amp;0XFF);<br>     }else if(lcddev.id==XXXX)    //根据不同的LCD型号，执行不同的代码<br>     {<br>     ……//省略部分代码<br>     }<br>}</p>
<h3 id="LCD画点函数"><a href="#LCD画点函数" class="headerlink" title="LCD画点函数"></a>LCD画点函数</h3><p>//画点<br>//x,y:坐标<br>//POINT_COLOR:此点的颜色<br>void LCD_DrawPoint(u16 x,u16 y)<br>{<br>    LCD_SetCursor(x,y);        //设置光标位置<br>    LCD_WriteRAM_Prepare();    //开始写入GRAM<br>    LCD-&gt;LCD_RAM=POINT_COLOR;     //非Mini板的操作方式<br>}</p>
<h3 id="LCD读点函数："><a href="#LCD读点函数：" class="headerlink" title="LCD读点函数："></a>LCD读点函数：</h3><p>u16 LCD_ReadPoint(u16 x,u16 y)</p>
<h3 id="字符显示函数"><a href="#字符显示函数" class="headerlink" title="字符显示函数"></a>字符显示函数</h3><p>//在指定位置显示一个字符<br>//x,y:起始坐标<br>//num:要显示的字符:” “—&gt;”~”<br>//size:字体大小 12/16/24<br>//mode:叠加方式(1)还是非叠加方式(0) 叠加方式的意思是保持底色不变<br>void LCD_ShowChar(u16 x,u16 y,u8 num,u8 size,u8 mode)<br>{<br>       u8 temp,t1,t;<br>       u16 y0=y;<br>       u8 csize=(size/8+((size%8)?1:0))*(size/2);    //得到字体一个字符对应点阵集所占的字节数<br>       num=num-‘ ‘;    //得到偏移后的值（ASCII字库是从空格开始取模，所以-‘ ‘就是对应字符的字库）<br>       for(t=0;t&lt;csize;t++)<br>       {<br>if(size==12)temp=asc2_1206[num][t];         //调用1206字体<br>             else if(size==16)temp=asc2_1608[num][t];    //调用1608字体<br>             else if(size==24)temp=asc2_2412[num][t];    //调用2412字体<br>             else return;            //没有的字库<br>             for(t1=0;t1&lt;8;t1++)<br>             {<br>      if(temp&amp;0x80)LCD_Fast_DrawPoint(x,y,POINT_COLOR);<br>      else if(mode==0)LCD_Fast_DrawPoint(x,y,BACK_COLOR);<br>                    temp&lt;&lt;=1;<br>                    y++;<br>                    if(y&gt;=lcddev.height)return;        //超区域了<br>                    if((y-y0)==size)<br>                    {<br>    y=y0;<br>    x++;<br>    if(x&gt;=lcddev.width)return;        //超区域了<br>    break;<br>                     }<br>              }<br>        }<br>} </p>
<h3 id="字符码表"><a href="#字符码表" class="headerlink" title="字符码表"></a>字符码表</h3><p>const unsigned char oled_asc2_1206[95][12]={<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/<em>“ “,0</em>/<br>{0x00,0x00,0x00,0x00,0x3F,0x40,0x00,0x00,0x00,0x00,0x00,0x00},/<em>“!”,1</em>/<br>……<br>{0x40,0x00,0x80,0x00,0x40,0x00,0x20,0x00,0x20,0x00,0x40,0x00},/<em>“~”,94</em>/<br>};</p>
<p>const unsigned char oled_asc2_1608[95][16]={<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/<em>“ “,0</em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xCC,0x00,0x0C,0x00,0x00,0x00,0x00,0x00,0x00},/<em>“!”,1</em>/<br>……<br>{0x00,0x00,0x60,0x00,0x80,0x00,0x80,0x00,0x40,0x00,0x40,0x00,0x20,0x00,0x20,0x00},/<em>“~”,94</em>/<br>}</p>
<p>const unsigned char oled_asc2_2412[95][36]={<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/<em>“ “,0</em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x80,0x38,0x0F,0xFE,0x38,0x0F,0x80,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/<em>“!”,1</em>/<br>……<br>{0x00,0x00,0x00,0x18,0x00,0x00,0x60,0x00,0x00,0x40,0x00,0x00,0x40,0x00,0x00,0x20,0x00,0x00,0x10,0x00,0x00,0x08,0x00,0x00,0x04,0x00,0x00,0x04,0x00,0x00,0x0C,0x00,0x00,0x10,0x00,0x00},/<em>“~”,94</em>/<br>}</p>
<h2 id="字符生产方式"><a href="#字符生产方式" class="headerlink" title="字符生产方式"></a>字符生产方式</h2><p>用软件PCtoLCD软件<br>配置：<br>点阵格式：阴码<br>取模方式：逐列式<br>取模走向：顺向<br>自定义格式： C51格式</p>
<p>输出方式是从上到下从左到右</p>
<h1 id="温度传感器实验"><a href="#温度传感器实验" class="headerlink" title="温度传感器实验"></a>温度传感器实验</h1><h2 id="DS18B20介绍"><a href="#DS18B20介绍" class="headerlink" title="DS18B20介绍"></a>DS18B20介绍</h2><h3 id="DS18B20技术性能特征："><a href="#DS18B20技术性能特征：" class="headerlink" title="DS18B20技术性能特征："></a>DS18B20技术性能特征：</h3><p>①独特的单总线接口方式，DS18B20在与微处理器连接时仅需要一条口线即可实现微处理器与DS18B20的双向通讯。大大提高了系统的抗干扰性。<br>②测温范围 －55℃～+125℃，精度为±0．5℃。<br>③支持多点组网功能，多个DS18B20可以并联在唯一的三线上，最多只能并联8个，<br>实现多点测温，如果数量过多，会使供电电源电压过低，从而造成信号传输的不稳定。<br>④工作电源: 3.0<del>5.5V/DC （可以数据线寄生电源）。<br>⑤在使用中不需要任何外围元件。<br>⑥测量结果以9</del>12位数字量方式串行传送。</p>
<h3 id="DS18B20封装"><a href="#DS18B20封装" class="headerlink" title="DS18B20封装"></a>DS18B20封装</h3><p>见PPT</p>
<h1 id="光敏传感器实验"><a href="#光敏传感器实验" class="headerlink" title="光敏传感器实验"></a>光敏传感器实验</h1><h2 id="光敏传感器简介"><a href="#光敏传感器简介" class="headerlink" title="光敏传感器简介"></a>光敏传感器简介</h2><p>光敏传感器是最常见的传感器之一，它的种类繁多，主要有：光电管、光电倍增管、光敏电阻、光敏三极管、太阳能电池、红外线传感器、紫外线传感器、光纤式光电传感器、色彩传感器、CCD和CMOS图像传感器等。光传感器是目前产量最多、应用最广的传感器之一，它在自动控制和非电量电测技术中占有非常重要的地位。</p>
<p>光敏传感器是利用光敏元件将光信号转换为电信号的传感器，它的敏感波长在可见光波长附近，包括红外线波长和紫外线波长。光传感器不只局限于对光的探测，它还可以作为探测元件组成其他传感器，对许多非电量进行检测，只要将这些非电量转换为光信号的变化即可</p>
<p>光敏二极管也叫光电二极管。光敏二极管与半导体二极管在结构上是类似的,其管芯是一个具有光敏特征的PN结，具有单向导电性，因此工作时需加上反向电压。无光照时，有很小的饱和反向漏电流，即暗电流，此时光敏二极管截止。当受到光照时,饱和反向漏电流大大增加，形成光电流,它随入射光强度的变化而变化。当光线照射PN结时，可以使PN结中产生电子一空穴对，使少数载流子的密度增加。这些载流子在反向电压下漂移，使反向电流增加。因此可以利用光照强弱来改变电路中的电流。<br>简而言之：照射光敏二极管的光强不同，通过光敏二极管的电流大小就不同，所以可以通过检测电流大小，达到检测光强的目的。</p>
<p>利用这个电流变化，我们串接一个电阻，就可以转换成电压的变化，从而通过ADC读取电压值，判断外部光线的强弱。</p>
<h2 id="硬件连接-1"><a href="#硬件连接-1" class="headerlink" title="硬件连接"></a>硬件连接</h2><p>光敏二极管串联一个电阻连接到VCC，一端接地<br>无光照时，光敏二极管两端无电流通过，电阻左边结点的电压V节点=Vcc<br>有光照时，设通过光么二极管的电流为I，光敏二极管电阻为R，电阻左边结点的电压V节点=Vcc-IR<br>可以看出，V节点与I成反比，即光强越小,I越小，V节点越大<br>我们通过ADC来测量V节点的大小，从而达到检测光强的目的。<br>ADC连接到PF8（ADC3的通道6）</p>
<h1 id="触摸屏实验"><a href="#触摸屏实验" class="headerlink" title="触摸屏实验"></a>触摸屏实验</h1><p>触摸屏（touch screen）又称为“触控屏”、“触控面板”，是一种可接收触头等输入讯号的感应式装置。作为一种新型的电脑输入设备，可以用来取代传统的机械按键等输入设备。它是目前最简单、方便、自然的一种人机交互方式。主要应用于公共信息的查询、领导办公、工业控制、军事指挥、电子游戏、点歌点菜、多媒体教学、房地产预售等。</p>
<p>触摸屏本质上与液晶是分离的。触摸屏负责的是检测触摸点，液晶屏负责的是显示。区别开来。<br>触摸屏一般覆盖在液晶屏上</p>
<p>按照触摸屏的工作原理和传输信息的介质，把触摸屏分为四种，它们分别为<br>电阻式：定位准确，单点触摸。<br>电容感应式：支持多点触摸，价格偏贵。工业应用最广泛<br>红外线式：价格低廉，但其外框易碎，容易产生光干扰，曲面情况下失真。<br>表面声波式：解决各种缺点，但是屏幕表面如果有水滴和尘土会使触摸屏变的迟钝。</p>
<h2 id="电容触摸屏"><a href="#电容触摸屏" class="headerlink" title="电容触摸屏"></a>电容触摸屏</h2><p>电容屏是利用人体感应进行触点检测控制，只需要轻微接触，通过检测感应电流来定位触摸坐标。现在几乎所有智能手机，包括平板电脑都是采用电容屏作为触摸屏。</p>
<p>电容型触摸屏分类<br>表面电容式电容触摸屏：<br>    表面电容式触摸屏技术是利用ITO(铟锡氧化物，是一种透明的导电材料)导电膜，通过电场感应方式感测屏幕表面的触摸行为进行。但是表面电容式触摸屏有一些局限性，它只能识别一个手指或者一次触摸。</p>
<p>投射式电容触摸屏<br>   投射电容式触摸屏是传感器利用触摸屏电极发射出静电场线。一般用于投射电容传感技术的电容类型有两种：自我电容和交互电容。</p>
<p>自我电容式<br>自我电容又称绝对电容，是最广为采用的一种方法，自我电容通常是指扫描电极与地构成的电容。在玻璃表面有用ITO制成的横向与纵向的扫描电极，这些电极和地之间就构成一个电容的两极。当用手或触摸笔触摸的时候就会并联一个电容到电路中去，从而使在该条扫描线上的总体的电容量有所改变。在扫描的时候，控制IC依次扫描纵向和横向电极，并根据扫描前后的电容变化来确定触摸点坐标位置。笔记本电脑触摸输入板就是采用的这种方式，笔记本电脑的输入板采用X*Y的传感电极阵列形成一个传感格子，当手指靠近触摸输入板时，在手指和传感电极之间产生一个小量电荷。采用特定的运算法则处理来自行、列传感器的信号来确定手指的位置。 </p>
<p>交互电容式<br>交互电容又叫做跨越电容，它是在玻璃表面的横向和纵向的ITO电极的交叉处形成电容。交互电容的扫描方式就是扫描每个交叉处的电容变化，来判定触摸点的位置。当触摸的时候就会影响到相邻电极的耦合，从而改变交叉处的电容量，交互电容的扫面方法可以侦测到每个交叉点的电容值和触摸后电容变化，因而它需要的扫描时间与自我电容的扫描方式相比要长一些，需要扫描检测X*Y根电极。目前智能手机/平板电脑等的触摸屏，都是采用交互电容技术。</p>
<p>本实验所选择的电容触摸屏，也是采用的是投射式电容屏（交互电容类型）。<br>透射式电容触摸屏采用纵横两列电极组成感应矩阵，来感应触摸。以两个交叉的电极矩阵，即： X轴电极和Y轴电极，来检测每一格感应单元的电容变化</p>
<h2 id="电阻屏与电容屏的区别"><a href="#电阻屏与电容屏的区别" class="headerlink" title="电阻屏与电容屏的区别"></a>电阻屏与电容屏的区别</h2><p>电阻屏在触模时需要轻触压按，而电容屏只需轻微的手指触碰就能激活</p>
<p>电阻屏可以用任何物体来触摸，而电容屏是人体热感应工作原理，只能用手指的热感区来触摸，指甲和手写笔均无效。由于手指头的面积比手写笔大很多，因此电容屏的手机，触摸比较小图标或者菜单的时候，触摸精度无法做到电阻屏那么高。</p>
<p>电容屏可以很容易进行多点触摸，电阻屏一般不能实现多点触摸的。</p>
<p>电阻屏内部是软的，一般是在4到5层超薄的钢化玻璃中间夹杂细微的炭粒（显微镜下才能看见），通过按压导致上下两层的炭粒相互接触而接通触屏电路，产生触摸反应，容易产生划痕，易坏，容易触屏不灵，而电容屏都是采用单层加厚钢化玻璃，硬度大，耐旧，使用寿长</p>
<p>电阻屏在阳光下可视性稍差，电容屏则非常好，在阳光下可视性很强</p>
<p>电容触摸屏对工作环境的要求是比较高的，在潮湿、多尘、高低温环境下面，都是不适合使用电容屏的。</p>
<p>电容屏优缺点总结</p>
<p>优点：<br>       手感好，无需校准，支持多点触摸，透光性好。<br>缺点：<br>       成本高，精度不高，抗干扰能力差。</p>
<h2 id="触摸屏原理"><a href="#触摸屏原理" class="headerlink" title="触摸屏原理"></a>触摸屏原理</h2><p>电容触摸屏一般都需要一个驱动IC来检测电容触摸，且一般是通过IIC接口输出触摸数据的<br>常见的2种电容触摸屏驱动IC<br>GT9147：采用17<em>10的驱动结构（10个感应通道，17个驱动通道）。（用这个）<br>OTT2001A：采用13</em>8的驱动结构（8个感应通道，13个驱动通道）<br>它们与MCU连接通过4根线：SDA、SCL、RST和INT</p>
<p>GT9147的IIC地址，可以是0X14或者0X5D，当复位结束后的5ms内，如果INT是高电平，则使用0X14作为地址，否则使用0X5D作为地址，具体的设置过程，请看：GT9147数据手册.pdf这个文档。本章我们使用0X14作为器件地址（不含最低位，换算成读写命令则是读：0X29，写：0X28）</p>
<p>GT9147关键寄存器：</p>
<p>控制命令寄存器（0X8040）<br>该寄存器可以写入不同值，实现不同的控制，我们一般使用0和2这两个值，写入2，即可软复位GT9147，在硬复位之后，一般要往该寄存器写2，实行软复位。然后，写入0，即可正常读取坐标数据（并且会结束软复位）。</p>
<p>配置寄存器组（0X8047~0X8100）<br>这里共186个寄存器，用于配置GT9147的各个参数，这些配置一般由厂家提供给我们（一个数组），所以我们只需要将厂家给我们的配置，写入到这些寄存器里面，即可完成GT9147的配置。</p>
<p>产品ID寄存器（0X8140~0X8143）<br>     这里总共由4个寄存器组成，用于保存产品ID，对于GT9147，这4个寄存器读出来就是：9，1，4，7四个字符（ASCII码格式）。因此，我们可以通过这4个寄存器的值，来判断驱动IC的型号，从而判断是OTT2001A还是GT9147，以便执行不同的初始化。</p>
<p>状态寄存器（0X814E）</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>bit7</th>
<th>bit6</th>
<th>bit5</th>
<th>bit4</th>
<th>bit3</th>
<th>bit2</th>
<th>bit1</th>
<th>bit0</th>
</tr>
</thead>
<tbody><tr>
<td>0X814E</td>
<td>buffer状态</td>
<td>大点</td>
<td>接近有效</td>
<td>按键</td>
<td>有效触点个数</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>我们仅关心最高位和最低4位，最高位用于表示buffer状态，如果有数据（坐标/按键），buffer就会是1，最低4位用于表示有效触点的个数，范围是：0~5，0，表示没有触摸，5表示有5点触摸。</p>
<p>坐标数据寄存器（共30个）<br>这里共分成5组（5个点），每组6个寄存器存储数据，以触点1的坐标数据寄存器组为例，</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>bit7~0</th>
<th>寄存器</th>
<th>bit7~0</th>
</tr>
</thead>
<tbody><tr>
<td>0X8150</td>
<td>触点1 x坐标低8位</td>
<td>0X8151</td>
<td>触点1 x坐标高8位</td>
</tr>
<tr>
<td>0X8152</td>
<td>触点1 y坐标低8位</td>
<td>0X8153</td>
<td>触点1 y坐标高8位</td>
</tr>
<tr>
<td>0X8154</td>
<td>触点1 触摸尺寸低8位</td>
<td>0X8155</td>
<td>触点1 触摸尺寸高8位</td>
</tr>
</tbody></table>
<h2 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h2><p>ctiic.c是电容触摸屏的底层驱动结构，基本和myiic.c中内容差不多<br>touch.c是电容触摸屏的入口，会根据入口参数判断型号进行初始化<br>gt9147.c是驱动ic的</p>
<h3 id="touch-c中"><a href="#touch-c中" class="headerlink" title="touch.c中"></a>touch.c中</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">u8 TP_Init(void)</span><br><span class="line">&#123;	</span><br><span class="line">	if(lcddev.id==0X5510)				//4.3寸电容触摸屏</span><br><span class="line">	&#123;</span><br><span class="line">		if(GT9147_Init()==0)			//是GT9147</span><br><span class="line">		&#123; </span><br><span class="line">			tp_dev.scan=GT9147_Scan;	//扫描函数指向GT9147触摸屏扫描</span><br><span class="line">		&#125;else</span><br><span class="line">		&#123;</span><br><span class="line">			OTT2001A_Init();</span><br><span class="line">			tp_dev.scan=OTT2001A_Scan;	//扫描函数指向OTT2001A触摸屏扫描</span><br><span class="line">		&#125;</span><br><span class="line">		tp_dev.touchtype|=0X80;			//电容屏 </span><br><span class="line">		tp_dev.touchtype|=lcddev.dir&amp;0X01;//横屏还是竖屏 </span><br><span class="line">		return 0;</span><br><span class="line">	&#125;else if(lcddev.id==0X1963)			//7寸电容触摸屏</span><br><span class="line">	&#123;</span><br><span class="line">		FT5206_Init();</span><br><span class="line">		tp_dev.scan=FT5206_Scan;		//扫描函数指向GT9147触摸屏扫描		</span><br><span class="line">		tp_dev.touchtype|=0X80;			//电容屏 </span><br><span class="line">		tp_dev.touchtype|=lcddev.dir&amp;0X01;//横屏还是竖屏 </span><br><span class="line">		return 0;</span><br><span class="line">	&#125;else</span><br><span class="line">	&#123;</span><br><span class="line">		GPIO_InitTypeDef GPIO_Initure;</span><br><span class="line"></span><br><span class="line">		__HAL_RCC_GPIOB_CLK_ENABLE();           	//开启GPIOB时钟</span><br><span class="line">		__HAL_RCC_GPIOF_CLK_ENABLE();           	//开启GPIOF时钟</span><br><span class="line">		</span><br><span class="line">		//PB1</span><br><span class="line">		GPIO_Initure.Pin=GPIO_PIN_1; 				//PB1</span><br><span class="line">		GPIO_Initure.Mode=GPIO_MODE_OUTPUT_PP;  	//推挽输出</span><br><span class="line">		GPIO_Initure.Pull=GPIO_PULLUP;          	//上拉</span><br><span class="line">		GPIO_Initure.Speed=GPIO_SPEED_FREQ_HIGH;    //高速</span><br><span class="line">		HAL_GPIO_Init(GPIOB,&amp;GPIO_Initure);</span><br><span class="line">	</span><br><span class="line">		//PB2</span><br><span class="line">		GPIO_Initure.Pin=GPIO_PIN_2; 				//PB2</span><br><span class="line">		GPIO_Initure.Mode=GPIO_MODE_INPUT;  		//上拉输入</span><br><span class="line">		HAL_GPIO_Init(GPIOB,&amp;GPIO_Initure);</span><br><span class="line">		</span><br><span class="line">		//PF9,11</span><br><span class="line">		GPIO_Initure.Pin=GPIO_PIN_9|GPIO_PIN_11; 	//PF9,11</span><br><span class="line">		GPIO_Initure.Mode=GPIO_MODE_OUTPUT_PP;  	//推挽输出</span><br><span class="line">		HAL_GPIO_Init(GPIOF,&amp;GPIO_Initure);</span><br><span class="line">		</span><br><span class="line">		//PF10</span><br><span class="line">		GPIO_Initure.Pin=GPIO_PIN_10; 				//PF10</span><br><span class="line">		GPIO_Initure.Mode=GPIO_MODE_INPUT;  		//输入</span><br><span class="line">		GPIO_Initure.Pull=GPIO_PULLUP;          	//上拉</span><br><span class="line">		HAL_GPIO_Init(GPIOF,&amp;GPIO_Initure);</span><br><span class="line"></span><br><span class="line">		TP_Read_XY(&amp;tp_dev.x[0],&amp;tp_dev.y[0]);//第一次读取初始化	 </span><br><span class="line">		AT24CXX_Init();			//初始化24CXX</span><br><span class="line">		if(TP_Get_Adjdata())return 0;//已经校准</span><br><span class="line">		else			  		//未校准?</span><br><span class="line">		&#123; 										    </span><br><span class="line">			LCD_Clear(WHITE);	//清屏</span><br><span class="line">			TP_Adjust();  		//屏幕校准  </span><br><span class="line">		&#125;			</span><br><span class="line">		TP_Get_Adjdata();	</span><br><span class="line">	&#125;</span><br><span class="line">	return 1; 									 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中if(<br>lcddev.id==0X5510)是来判断是否是4.3寸电容触摸屏<br>if(GT9147_Init()==0)以9147的方法初始化，看能否正确运行<br>能正确运行的话执行tp_dev.scan=GT9147_Scan;<br>tp_dev是一个_m_tp_dev类型的结构体<br>这个结构体很重要，看一下它的定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">typedef struct </span><br><span class="line">&#123;</span><br><span class="line">	u8 (*init)(void);			//初始化触摸屏控制器</span><br><span class="line">	u8 (*scan)(u8);				//扫描触摸屏.0,屏幕扫描;1,物理坐标;	 </span><br><span class="line">	void (*adjust)(void);		//触摸屏校准 </span><br><span class="line">	u16 x[CT_MAX_TOUCH]; 		//当前坐标</span><br><span class="line">	u16 y[CT_MAX_TOUCH];		//电容屏有最多5组坐标,电阻屏则用x[0],y[0]代表:此次扫描时,触屏的坐标,用</span><br><span class="line">								//x[4],y[4]存储第一次按下时的坐标. </span><br><span class="line">	u8  sta;					//笔的状态 </span><br><span class="line">								//b7:按下1/松开0; </span><br><span class="line">	                            //b6:0,没有按键按下;1,有按键按下. </span><br><span class="line">								//b5:保留</span><br><span class="line">								//b4~b0:电容触摸屏按下的点数(0,表示未按下,1表示按下)</span><br><span class="line">/////////////////以下为电阻触摸屏校准参数(电容屏不需要校准)//////////////////////								</span><br><span class="line">	float xfac;					</span><br><span class="line">	float yfac;</span><br><span class="line">	short xoff;</span><br><span class="line">	short yoff;	   </span><br><span class="line">//新增的参数,当触摸屏的左右上下完全颠倒时需要用到.</span><br><span class="line">//b0:0,竖屏(适合左右为X坐标,上下为Y坐标的TP)</span><br><span class="line">//   1,横屏(适合左右为Y坐标,上下为X坐标的TP) </span><br><span class="line">//b1~6:保留.</span><br><span class="line">//b7:0,电阻屏</span><br><span class="line">//   1,电容屏 </span><br><span class="line">	u8 touchtype;</span><br><span class="line">&#125;_m_tp_dev;</span><br></pre></td></tr></table></figure>
<p>CT_MAX_TOUCH是允许同时触摸的最大点数<br>tp_dev的具体定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_m_tp_dev tp_dev=</span><br><span class="line">&#123;</span><br><span class="line">	TP_Init,                //初始化函数</span><br><span class="line">	TP_Scan,                //扫描函数</span><br><span class="line">	TP_Adjust,              //校准函数</span><br><span class="line">	0,</span><br><span class="line">	0, </span><br><span class="line">	0,</span><br><span class="line">	0,</span><br><span class="line">	0,</span><br><span class="line">	0,	  	 		</span><br><span class="line">	0,</span><br><span class="line">	0,	  	 		</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以tp_dev.scan=GT9147_Scan;的实际作用是： 扫描函数指向GT9147触摸屏扫描函数</p>
<h3 id="gt9147-c中"><a href="#gt9147-c中" class="headerlink" title="gt9147.c中"></a>gt9147.c中</h3><p>u8 GT9147_Send_Cfg(u8 mode)                 写配置文件<br>u8 GT9147_WR_Reg(u16 reg,u8 *buf,u8 len)    读寄存器<br>gt9147中比较重要的是扫描函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">u8 GT9147_Scan(u8 mode)</span><br><span class="line">&#123;</span><br><span class="line">	u8 buf[4];</span><br><span class="line">	u8 i=0;</span><br><span class="line">	u8 res=0;</span><br><span class="line">	u8 temp;</span><br><span class="line">	u8 tempsta;</span><br><span class="line"> 	static u8 t=0;//控制查询间隔,从而降低CPU占用率   </span><br><span class="line">	t++;</span><br><span class="line">	if((t%10)==0||t&lt;10)//空闲时,每进入10次TP_Scan函数才检测1次,从而节省CPU使用率</span><br><span class="line">	&#123;</span><br><span class="line">		GT9147_RD_Reg(GT_GSTID_REG,&amp;mode,1);	//读取触摸点的状态  </span><br><span class="line"> 		if(mode&amp;0X80&amp;&amp;((mode&amp;0XF)&lt;6))</span><br><span class="line">		&#123;</span><br><span class="line">			temp=0;</span><br><span class="line">			GT9147_WR_Reg(GT_GSTID_REG,&amp;temp,1);//清标志 		</span><br><span class="line">		&#125;		</span><br><span class="line">		if((mode&amp;0XF)&amp;&amp;((mode&amp;0XF)&lt;6))</span><br><span class="line">		&#123;</span><br><span class="line">			temp=0XFF&lt;&lt;(mode&amp;0XF);		//将点的个数转换为1的位数,匹配tp_dev.sta定义 </span><br><span class="line">			tempsta=tp_dev.sta;			//保存当前的tp_dev.sta值</span><br><span class="line">			tp_dev.sta=(~temp)|TP_PRES_DOWN|TP_CATH_PRES; </span><br><span class="line">			tp_dev.x[4]=tp_dev.x[0];	//保存触点0的数据</span><br><span class="line">			tp_dev.y[4]=tp_dev.y[0];</span><br><span class="line">			for(i=0;i&lt;5;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				if(tp_dev.sta&amp;(1&lt;&lt;i))	//触摸有效?</span><br><span class="line">				&#123;</span><br><span class="line">					GT9147_RD_Reg(GT9147_TPX_TBL[i],buf,4);	//读取XY坐标值</span><br><span class="line">					if(tp_dev.touchtype&amp;0X01)//横屏</span><br><span class="line">					&#123;</span><br><span class="line">						tp_dev.y[i]=((u16)buf[1]&lt;&lt;8)+buf[0];</span><br><span class="line">						tp_dev.x[i]=800-(((u16)buf[3]&lt;&lt;8)+buf[2]);</span><br><span class="line">					&#125;else</span><br><span class="line">					&#123;</span><br><span class="line">						tp_dev.x[i]=((u16)buf[1]&lt;&lt;8)+buf[0];</span><br><span class="line">						tp_dev.y[i]=((u16)buf[3]&lt;&lt;8)+buf[2];</span><br><span class="line">					&#125;  </span><br><span class="line">					//printf(&quot;x[%d]:%d,y[%d]:%d\r\n&quot;,i,tp_dev.x[i],i,tp_dev.y[i]);</span><br><span class="line">				&#125;			</span><br><span class="line">			&#125; </span><br><span class="line">			res=1;</span><br><span class="line">			if(tp_dev.x[0]&gt;lcddev.width||tp_dev.y[0]&gt;lcddev.height)//非法数据(坐标超出了)</span><br><span class="line">			&#123; </span><br><span class="line">				if((mode&amp;0XF)&gt;1)		//有其他点有数据,则复第二个触点的数据到第一个触点.</span><br><span class="line">				&#123;</span><br><span class="line">					tp_dev.x[0]=tp_dev.x[1];</span><br><span class="line">					tp_dev.y[0]=tp_dev.y[1];</span><br><span class="line">					t=0;				//触发一次,则会最少连续监测10次,从而提高命中率</span><br><span class="line">				&#125;else					//非法数据,则忽略此次数据(还原原来的)  </span><br><span class="line">				&#123;</span><br><span class="line">					tp_dev.x[0]=tp_dev.x[4];</span><br><span class="line">					tp_dev.y[0]=tp_dev.y[4];</span><br><span class="line">					mode=0X80;		</span><br><span class="line">					tp_dev.sta=tempsta;	//恢复tp_dev.sta</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;else t=0;					//触发一次,则会最少连续监测10次,从而提高命中率</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if((mode&amp;0X8F)==0X80)//无触摸点按下</span><br><span class="line">	&#123; </span><br><span class="line">		if(tp_dev.sta&amp;TP_PRES_DOWN)	//之前是被按下的</span><br><span class="line">		&#123;</span><br><span class="line">			tp_dev.sta&amp;=~(1&lt;&lt;7);	//标记按键松开</span><br><span class="line">		&#125;else						//之前就没有被按下</span><br><span class="line">		&#123; </span><br><span class="line">			tp_dev.x[0]=0xffff;</span><br><span class="line">			tp_dev.y[0]=0xffff;</span><br><span class="line">			tp_dev.sta&amp;=0XE0;	//清除点有效标记	</span><br><span class="line">		&#125;	 </span><br><span class="line">	&#125; 	</span><br><span class="line">	if(t&gt;240)t=10;//重新从10开始计数</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先状态寄存器的bit7会置1表示启用了<br>bit4~bit0表示有效触点个数范围是0个(00000)到5个(11111)</p>
<p>由于头文件中已经宏定义<br>#define GT_GSTID_REG     0X814E<br>0X814E又是状态寄存器<br>所以<br>GT9147_RD_Reg(GT_GSTID_REG,&amp;mode,1);<br>的作用是读取触点的状态<br>if(mode&amp;0X80&amp;&amp;((mode&amp;0XF)&lt;6))中<br>mode&amp;0X80得到最高位<br>mode&amp;0XF可以得到低四位 表示最高位有1，且有触摸</p>
<p>具体处理过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">temp=0XFF&lt;&lt;(mode&amp;0XF);		//将点的个  数转换为1的位数,匹配tp_dev.sta定义 </span><br><span class="line">                            //mode取低四位，假入取了后转化为十进制是5，然后1111 1111左移5位</span><br><span class="line">                            //得到tempt==1110 0000</span><br><span class="line"></span><br><span class="line">tempsta=tp_dev.sta;			//保存当前的tp_dev.sta值 sta表示笔的状态</span><br><span class="line">                            //bit4~bit0 哪一位为1就表示按下</span><br><span class="line">                            //比如00010表示bit1被按下</span><br><span class="line"></span><br><span class="line">tp_dev.sta=(~temp)|TP_PRES_DOWN|TP_CATH_PRES; </span><br><span class="line">                            //取反temp得到 0001 1111</span><br><span class="line">                            //同如有4个点按下会得到 0000 1111</span><br><span class="line">                            //3个点0000 0111 ····</span><br><span class="line">// #define TP_PRES_DOWN 0x80  	表示触屏被按下	  </span><br><span class="line">// #define TP_CATH_PRES 0x40  	表示按键被按下 </span><br><span class="line">//则tp_dev.sta==0001 1111|1000 0000|0100 0000</span><br><span class="line">//保证了最高位和次高位都是1</span><br><span class="line">//此时笔的状态是tp_dev.sta==1101 1111</span><br><span class="line">//参考刚刚结构体中的定义看看具体含义</span><br><span class="line">//u8  sta;					    //笔的状态 </span><br><span class="line">								//b7:按下1/松开0; </span><br><span class="line">	                            //b6:0,没有按键按下;1,有按键按下. </span><br><span class="line">								//b5:保留</span><br><span class="line">								//b4~b0:电容触摸屏按下的点数(0,表示未按下,1表示按下)</span><br><span class="line"></span><br><span class="line">tp_dev.x[4]=tp_dev.x[0];	//保存触点0的数据</span><br><span class="line">tp_dev.y[4]=tp_dev.y[0];</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">for(i=0;i&lt;5;i++)</span><br><span class="line">&#123;</span><br><span class="line">    if(tp_dev.sta&amp;(1&lt;&lt;i))	//sta触摸有效?sta是低5位的</span><br><span class="line">                            //1&lt;&lt;i可以分别得到 00001 00010 00100 01000 10000</span><br><span class="line">                            //再和tp_dev.sta相与可以判断该位置的触点是否按下</span><br><span class="line">    &#123;</span><br><span class="line">		GT9147_RD_Reg(GT9147_TPX_TBL[i],buf,4);	//读取XY坐标值</span><br><span class="line">                            //数组GT9147_TPX_TBL[5]中分别存储了</span><br><span class="line">                            //第一个到第五个触摸点数据地址</span><br><span class="line">		if(tp_dev.touchtype&amp;0X01)//横屏</span><br><span class="line">		&#123;</span><br><span class="line">			tp_dev.y[i]=((u16)buf[1]&lt;&lt;8)+buf[0];</span><br><span class="line">			tp_dev.x[i]=800-(((u16)buf[3]&lt;&lt;8)+buf[2]);</span><br><span class="line">		&#125;</span><br><span class="line">        else</span><br><span class="line">		&#123;</span><br><span class="line">			tp_dev.x[i]=((u16)buf[1]&lt;&lt;8)+buf[0];</span><br><span class="line">			tp_dev.y[i]=((u16)buf[3]&lt;&lt;8)+buf[2];</span><br><span class="line">		&#125;</span><br><span class="line">        //上面这个if else分支作用是在确定有出点按下后找到该触点的横纵坐标</span><br><span class="line">        //然后存储到结构体tp_dev的数组中</span><br><span class="line"></span><br><span class="line">		//printf(&quot;x[%d]:%d,y[%d]:%d\r\n&quot;,i,tp_dev.x[i],i,tp_dev.y[i]);</span><br><span class="line">	&#125;			</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if(tp_dev.x[0]&gt;lcddev.width||tp_dev.y[0]&gt;lcddev.height)//非法数据(坐标超出了)</span><br><span class="line">	&#123; </span><br><span class="line">		if((mode&amp;0XF)&gt;1)		//有其他点有数据,则复第二个触点的数据到第一个触点.</span><br><span class="line">		    &#123;</span><br><span class="line">				tp_dev.x[0]=tp_dev.x[1];</span><br><span class="line">				tp_dev.y[0]=tp_dev.y[1];</span><br><span class="line">				t=0;				//触发一次,则会最少连续监测10次,从而提高命中率	</span><br><span class="line">            &#125;</span><br><span class="line">        else					    //非法数据,则忽略此次数据(还原原来的)  </span><br><span class="line">	        &#123;</span><br><span class="line">				tp_dev.x[0]=tp_dev.x[4];</span><br><span class="line">				tp_dev.y[0]=tp_dev.y[4];</span><br><span class="line">				mode=0X80;		</span><br><span class="line">				tp_dev.sta=tempsta;	//恢复tp_dev.sta</span><br><span class="line">    &#125;</span><br><span class="line">else</span><br><span class="line">t=0;           //触发一次,则会最少连续监测10次,从而提高命中率</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if((mode&amp;0X8F)==0X80)//无触摸点按下</span><br><span class="line">	&#123; </span><br><span class="line">		if(tp_dev.sta&amp;TP_PRES_DOWN)	//之前是被按下的</span><br><span class="line">		&#123;</span><br><span class="line">			tp_dev.sta&amp;=~(1&lt;&lt;7);	//标记按键松开</span><br><span class="line">		&#125;else						//之前就没有被按下</span><br><span class="line">		&#123; </span><br><span class="line">			tp_dev.x[0]=0xffff;</span><br><span class="line">			tp_dev.y[0]=0xffff;</span><br><span class="line">			tp_dev.sta&amp;=0XE0;	//清除点有效标记	</span><br><span class="line">		&#125;	 </span><br><span class="line">	&#125; 	</span><br></pre></td></tr></table></figure>
<h3 id="main函数中"><a href="#main函数中" class="headerlink" title="main函数中"></a>main函数中</h3><p>//电容触摸屏测试函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">void ctp_test(void)</span><br><span class="line">&#123;</span><br><span class="line">	u8 t=0;</span><br><span class="line">	u8 i=0;	  	    </span><br><span class="line"> 	u16 lastpos[5][2];		//最后一次的数据 </span><br><span class="line">	while(1)                //循环扫描</span><br><span class="line">	&#123;</span><br><span class="line">		tp_dev.scan(0);     </span><br><span class="line">                //tp_dev.scan函数会根据型号不同调用不同的函数，这里是9147的扫描函数</span><br><span class="line">    </span><br><span class="line">		for(t=0;t&lt;5;t++)</span><br><span class="line">		&#123;</span><br><span class="line">			if((tp_dev.sta)&amp;(1&lt;&lt;t))</span><br><span class="line">                //前文说过这个语句可以判断触点是否按下，是哪个触点</span><br><span class="line">			&#123;</span><br><span class="line">                //printf(&quot;X坐标:%d,Y坐标:%d\r\n&quot;,tp_dev.x[0],tp_dev.y[0]);</span><br><span class="line">				if(tp_dev.x[t]&lt;lcddev.width&amp;&amp;tp_dev.y[t]&lt;lcddev.height)</span><br><span class="line">				&#123;</span><br><span class="line">					if(lastpos[t][0]==0XFFFF)</span><br><span class="line">					&#123;</span><br><span class="line">						lastpos[t][0] = tp_dev.x[t];    //写入坐标</span><br><span class="line">						lastpos[t][1] = tp_dev.y[t];    </span><br><span class="line">					&#125;</span><br><span class="line">                    </span><br><span class="line">					lcd_draw_bline(lastpos[t][0],lastpos[t][1],tp_dev.x[t],tp_dev.y[t],2,POINT_COLOR_TBL[t]);//画线</span><br><span class="line">					lastpos[t][0]=tp_dev.x[t];</span><br><span class="line">					lastpos[t][1]=tp_dev.y[t];</span><br><span class="line">					if(tp_dev.x[t]&gt;(lcddev.width-24)&amp;&amp;tp_dev.y[t]&lt;20)</span><br><span class="line">					&#123;</span><br><span class="line">						Load_Drow_Dialog();//清除</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;else lastpos[t][0]=0XFFFF;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		delay_ms(5);i++;</span><br><span class="line">		if(i%20==0)LED0=!LED0;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单地说原理就是快速读入两次触点的坐标，并且画出两点间的直线，接着再画下一段直线<br>由于每次读入触点坐标的间隔时间非常段，所以总体上看像是连续的笔画</p>

      
    </div>
    
    
    

    

    

    

    <div>
      
        
  <div style="text-align:center;color: #ccc;font-size:14px;">
   ------ 本文结束 ------</div>

      
   </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/STM32/" rel="tag"># STM32</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/04/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87%E7%BB%8F%E6%B5%8E%E5%AD%A6%E4%BA%BA/" rel="next" title="每日一篇经济学人">
                <i class="fa fa-chevron-left"></i> 每日一篇经济学人
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2022/06/17/%E7%94%9F%E8%AF%8D/" rel="prev" title="生词">
                生词 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/ying.png"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            
 
            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Ahdhvs" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="1206963575@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://space.bilibili.com/7494207" target="_blank" title="bilibili">
                      
                        <i class="fa fa-fw fa-globe"></i>bilibili</a>
                  </span>
                
            </div>
          

          
          

          
          

          <div id="days"></div>
<script>
function show_date_time(){
window.setTimeout("show_date_time()",1000);
BirthDay=new Date("01/25/2022 19:07:00");
today=new Date();
timeold=(today.getTime()-BirthDay.getTime());
sectimeold=timeold/1000
secondsold=Math.floor(sectimeold);
msPerDay=24*60*60*1000
e_daysold=timeold/msPerDay
daysold=Math.floor(e_daysold);
e_hrsold=(e_daysold-daysold)*24;
hrsold=setzero(Math.floor(e_hrsold));
e_minsold=(e_hrsold-hrsold)*60;
minsold=setzero(Math.floor((e_hrsold-hrsold)*60));
seconds=setzero(Math.floor((e_minsold-minsold)*60));
document.getElementById('days').innerHTML="已运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒";
}
function setzero(i){
if (i<10)
{i="0" + i};
return i;
}
show_date_time();
</script>


        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E6%9D%BF%E8%B5%84%E6%BA%90"><span class="nav-number">1.</span> <span class="nav-text">开发板资源</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-WIRELESS-%E6%A8%A1%E5%9D%97%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.1.</span> <span class="nav-text">1. WIRELESS 模块接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-W25Q128-128Mbit-FLASH"><span class="nav-number">1.2.</span> <span class="nav-text">2. W25Q128 128Mbit FLASH</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-SD%E5%8D%A1%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.3.</span> <span class="nav-text">3. SD卡接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-CAN-USB-%E9%80%89%E6%8B%A9%E5%8F%A3"><span class="nav-number">1.4.</span> <span class="nav-text">4. CAN&#x2F;USB 选择口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-USB-%E4%B8%B2%E5%8F%A3-%E4%B8%B2%E5%8F%A3-1"><span class="nav-number">1.5.</span> <span class="nav-text">5.USB 串口&#x2F;串口 1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-JTAG-SWD-%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.6.</span> <span class="nav-text">6. JTAG&#x2F;SWD 接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-24C02-EEPROM"><span class="nav-number">1.7.</span> <span class="nav-text">7. 24C02 EEPROM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-USB-SLAVE"><span class="nav-number">1.8.</span> <span class="nav-text">8. USB SLAVE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-USB-%E8%BD%AC%E4%B8%B2%E5%8F%A3"><span class="nav-number">1.9.</span> <span class="nav-text">9. USB 转串口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E5%90%8E%E5%A4%87%E7%94%B5%E6%B1%A0%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.10.</span> <span class="nav-text">10. 后备电池接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-OLED-%E6%91%84%E5%83%8F%E5%A4%B4%E6%A8%A1%E5%9D%97%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.11.</span> <span class="nav-text">11. OLED&#x2F;摄像头模块接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E6%9C%89%E6%BA%90%E8%9C%82%E9%B8%A3%E5%99%A8"><span class="nav-number">1.12.</span> <span class="nav-text">12. 有源蜂鸣器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-%E7%BA%A2%E5%A4%96%E6%8E%A5%E6%94%B6%E5%99%A8"><span class="nav-number">1.13.</span> <span class="nav-text">13. 红外接收器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-DS18B20-DHT11-%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.14.</span> <span class="nav-text">14. DS18B20&#x2F;DHT11 接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-2-%E4%B8%AA-LED"><span class="nav-number">1.15.</span> <span class="nav-text">15. 2 个 LED</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-%E5%90%AF%E5%8A%A8%E9%80%89%E6%8B%A9%E7%AB%AF%E5%8F%A3"><span class="nav-number">1.16.</span> <span class="nav-text">16. 启动选择端口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-%E8%A7%A6%E6%91%B8%E6%8C%89%E9%92%AE"><span class="nav-number">1.17.</span> <span class="nav-text">17. 触摸按钮</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-%E7%94%B5%E6%BA%90%E6%8C%87%E7%A4%BA%E7%81%AF"><span class="nav-number">1.18.</span> <span class="nav-text">18. 电源指示灯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-%E5%A4%8D%E4%BD%8D%E6%8C%89%E9%92%AE"><span class="nav-number">1.19.</span> <span class="nav-text">19. 复位按钮</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-3%E4%B8%AA%E6%8C%89%E9%94%AE"><span class="nav-number">1.20.</span> <span class="nav-text">20. 3个按键</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-STM32F103ZET6"><span class="nav-number">1.21.</span> <span class="nav-text">21. STM32F103ZET6</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-AD-DA-%E7%BB%84%E5%90%88%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.22.</span> <span class="nav-text">22. AD&#x2F;DA 组合接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-ATK-%E6%A8%A1%E5%9D%97%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.23.</span> <span class="nav-text">23. ATK 模块接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-3-3V-%E7%94%B5%E6%BA%90%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA"><span class="nav-number">1.24.</span> <span class="nav-text">24. 3.3V 电源输入&#x2F;输出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-5V-%E7%94%B5%E6%BA%90%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA"><span class="nav-number">1.25.</span> <span class="nav-text">25. 5V 电源输入&#x2F;输出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-%E7%94%B5%E6%BA%90%E5%BC%80%E5%85%B3"><span class="nav-number">1.26.</span> <span class="nav-text">26. 电源开关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27-DC6-24V-%E7%94%B5%E6%BA%90%E8%BE%93%E5%85%A5"><span class="nav-number">1.27.</span> <span class="nav-text">27. DC6~24V 电源输入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28-RS485-%E9%80%89%E6%8B%A9%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.28.</span> <span class="nav-text">28. RS485 选择接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-%E5%BC%95%E5%87%BA-IO-%E5%8F%A3%EF%BC%88%E5%85%B1-2-%E7%BB%84%EF%BC%89"><span class="nav-number">1.29.</span> <span class="nav-text">29. 引出 IO 口（共 2 组）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#30-LCD-%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.30.</span> <span class="nav-text">30. LCD 接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#31-%E5%85%89%E6%95%8F%E4%BC%A0%E6%84%9F%E5%99%A8"><span class="nav-number">1.31.</span> <span class="nav-text">31. 光敏传感器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-RS485-%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.32.</span> <span class="nav-text">32. RS485 接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33-CAN-%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.33.</span> <span class="nav-text">33. CAN 接口</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STM32-%E5%88%9D%E6%8E%A2"><span class="nav-number">2.</span> <span class="nav-text">STM32 初探</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9STM32"><span class="nav-number">2.1.</span> <span class="nav-text">1. 为什么选择STM32</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-M3%E7%B3%BB%E5%88%97%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">2.2.</span> <span class="nav-text">3. M3系列的优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-STM32%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="nav-number">2.3.</span> <span class="nav-text">2. STM32的命名规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-STM32%E7%9A%84%E4%BC%98%E5%8A%BF%E6%80%BB%E7%BB%93"><span class="nav-number">2.4.</span> <span class="nav-text">3. STM32的优势总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STM32-%E8%8A%AF%E7%89%87%E8%A7%A3%E8%AF%BB"><span class="nav-number">3.</span> <span class="nav-text">STM32 芯片解读</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%8A%AF%E7%89%87%E6%9C%89%E5%93%AA%E4%BA%9B%E8%B5%84%E6%BA%90%EF%BC%9F"><span class="nav-number">3.1.</span> <span class="nav-text">1.芯片有哪些资源？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%8A%AF%E7%89%87%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.</span> <span class="nav-text">2. 芯片的内部结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-STM32%E7%9A%84%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.3.</span> <span class="nav-text">3. STM32的最小系统</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="nav-number">4.</span> <span class="nav-text">开发环境搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MDK%E5%AE%89%E8%A3%85"><span class="nav-number">4.1.</span> <span class="nav-text">MDK安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#USB%E4%B8%B2%E5%8F%A3%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="nav-number">4.2.</span> <span class="nav-text">USB串口作用：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#USB%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85"><span class="nav-number">4.3.</span> <span class="nav-text">USB串口驱动安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#STM32%E7%9A%84ISP%E4%B8%8B%E8%BD%BD"><span class="nav-number">4.4.</span> <span class="nav-text">STM32的ISP下载</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GPIO%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AF%84%E5%AD%98%E5%99%A8%E9%85%8D%E7%BD%AE"><span class="nav-number">5.</span> <span class="nav-text">GPIO基本原理与寄存器配置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#GPIO%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="nav-number">5.1.</span> <span class="nav-text">GPIO基本结构和工作方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AF%8F%E7%BB%84GPIO%E7%AB%AF%E5%8F%A3%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">5.2.</span> <span class="nav-text">每组GPIO端口的寄存器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8%E5%8A%9F%E8%83%BD"><span class="nav-number">5.3.</span> <span class="nav-text">端口复用功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AB%AF%E5%8F%A3%E9%87%8D%E6%98%A0%E5%B0%84%E5%8A%9F%E8%83%BD"><span class="nav-number">5.4.</span> <span class="nav-text">端口重映射功能</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B7%91%E9%A9%AC%E7%81%AF%E7%A8%8B%E5%BA%8F"><span class="nav-number">6.</span> <span class="nav-text">跑马灯程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E8%BF%9E%E6%8E%A5%E5%8F%8AGPIO%E5%BA%93%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="nav-number">6.1.</span> <span class="nav-text">硬件连接及GPIO库函数说明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="nav-number">6.2.</span> <span class="nav-text">初始化函数：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E4%B8%AA%E8%AF%BB%E5%8F%96%E8%BE%93%E5%85%A5%E7%94%B5%E5%B9%B3%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="nav-number">6.3.</span> <span class="nav-text">2个读取输入电平函数：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E4%B8%AA%E8%AF%BB%E5%8F%96%E8%BE%93%E5%87%BA%E7%94%B5%E5%B9%B3%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="nav-number">6.4.</span> <span class="nav-text">2个读取输出电平函数：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E4%B8%AA%E8%AE%BE%E7%BD%AE%E8%BE%93%E5%87%BA%E7%94%B5%E5%B9%B3%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="nav-number">6.5.</span> <span class="nav-text">4个设置输出电平函数：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F"><span class="nav-number">6.6.</span> <span class="nav-text">程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%9C%A8template%E6%A8%A1%E6%9D%BF%E4%B8%AD%E6%96%B0%E5%BB%BAHARDWARE%EF%BC%88%E7%A1%AC%E4%BB%B6%EF%BC%89%E5%88%86%E7%BB%84%EF%BC%9B"><span class="nav-number">6.6.1.</span> <span class="nav-text">1.在template模板中新建HARDWARE（硬件）分组；</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%9C%A8%E7%9B%B8%E5%BA%94%E7%9A%84%E7%9B%AE%E5%BD%95%E4%B8%AD%E6%96%B0%E5%BB%BAHARDWARE%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%9B"><span class="nav-number">6.6.2.</span> <span class="nav-text">2.在相应的目录中新建HARDWARE文件夹；</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%9C%A8HARDWARE%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%AD%E5%86%8D%E6%96%B0%E5%BB%BALED%E7%AD%89%E5%A4%96%E8%AE%BE%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="nav-number">6.6.3.</span> <span class="nav-text">3.在HARDWARE文件夹中再新建LED等外设文件夹</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%AF%8F%E4%B8%AA%E5%A4%96%E8%AE%BE%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%AD%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E5%AF%B9%E5%BA%94%E7%9A%84-h%E5%92%8C-c%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-number">6.6.4.</span> <span class="nav-text">4.每个外设文件夹中建立一个对应的.h和.c的文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%9C%A8-h%E4%B8%AD%E9%A2%84%E7%BC%96%E8%AF%91%E9%98%B2%E6%AD%A2%E9%87%8D%E6%96%B0%E5%BC%95%E7%94%A8"><span class="nav-number">6.6.5.</span> <span class="nav-text">5.在.h中预编译防止重新引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%9C%A8-c%EF%BC%88%E6%BA%90%E6%96%87%E4%BB%B6%EF%BC%89%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="nav-number">6.6.6.</span> <span class="nav-text">6.在.c（源文件）中定义函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E6%8C%89%E6%AD%A5%E9%AA%A4%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0RCC-APB2PeriphColckCmd"><span class="nav-number">6.6.7.</span> <span class="nav-text">7.按步骤调用函数RCC_APB2PeriphColckCmd();</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E5%88%9D%E5%A7%8B%E5%8C%96IO%E5%8F%A3%E6%A8%A1%E5%BC%8F%E3%80%82%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0GPIO-Init"><span class="nav-number">6.6.8.</span> <span class="nav-text">8.初始化IO口模式。调用函数GPIO_Init();</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E6%93%8D%E4%BD%9CIO%E5%8F%A3%EF%BC%8C%E8%BE%93%E5%87%BA%E9%AB%98%E4%BD%8E%E7%94%B5%E5%B9%B3"><span class="nav-number">6.6.9.</span> <span class="nav-text">9.操作IO口，输出高低电平</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E4%B8%BB%E5%87%BD%E6%95%B0%E5%BC%80%E5%A7%8B%E5%86%99%E7%A8%8B%E5%BA%8F"><span class="nav-number">6.7.</span> <span class="nav-text">从主函数开始写程序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%9C%82%E9%B8%A3%E5%99%A8%E5%AE%9E%E9%AA%8C"><span class="nav-number">7.</span> <span class="nav-text">蜂鸣器实验</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4"><span class="nav-number">7.1.</span> <span class="nav-text">实验步骤</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8C%89%E9%94%AE%E8%BE%93%E5%85%A5%E5%AE%9E%E9%AA%8C"><span class="nav-number">8.</span> <span class="nav-text">按键输入实验</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%89%E9%94%AE%E7%9A%84%E7%A1%AC%E4%BB%B6%E8%BF%9E%E6%8E%A5"><span class="nav-number">8.1.</span> <span class="nav-text">按键的硬件连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%89%E9%94%AE%E8%BE%93%E5%85%A5%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E"><span class="nav-number">8.2.</span> <span class="nav-text">按键输入操作说明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%89%E9%94%AE%E8%BE%93%E5%85%A5%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4"><span class="nav-number">8.3.</span> <span class="nav-text">按键输入实验步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C%E8%AF%AD%E8%A8%80%E5%85%B3%E9%94%AE%E5%AD%97-%EF%BC%9Astatic"><span class="nav-number">8.4.</span> <span class="nav-text">C语言关键字 ：static</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%89%E9%94%AE%E6%89%AB%E6%8F%8F%EF%BC%88%E6%94%AF%E6%8C%81%E8%BF%9E%E7%BB%AD%E6%8C%89%EF%BC%89%E7%9A%84%E4%B8%80%E8%88%AC%E6%80%9D%E8%B7%AF"><span class="nav-number">8.5.</span> <span class="nav-text">按键扫描（支持连续按）的一般思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%89%E9%94%AE%E6%89%AB%E6%8F%8F%EF%BC%88%E4%B8%8D%E6%94%AF%E6%8C%81%E8%BF%9E%E7%BB%AD%E6%8C%89%EF%BC%89%E7%9A%84%E4%B8%80%E8%88%AC%E6%80%9D%E8%B7%AF"><span class="nav-number">8.6.</span> <span class="nav-text">按键扫描（不支持连续按）的一般思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%89%E9%94%AE%E6%89%AB%E6%8F%8F%EF%BC%88%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F%E5%90%88%E4%BA%8C%E4%B8%BA%E4%B8%80%EF%BC%89%E7%9A%84%E4%B8%80%E8%88%AC%E6%80%9D%E8%B7%AF"><span class="nav-number">8.7.</span> <span class="nav-text">按键扫描（两种模式合二为一）的一般思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E5%92%8CMDK%E4%B8%AD%E5%AF%84%E5%AD%98%E5%99%A8%E5%9C%B0%E5%9D%80%E5%90%8D%E7%A7%B0%E6%98%A0%E5%B0%84%E5%88%86%E6%9E%90"><span class="nav-number">9.</span> <span class="nav-text">C语言复习和MDK中寄存器地址名称映射分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E6%93%8D%E4%BD%9C%EF%BC%9A6%E7%A7%8D%E4%BD%8D%E6%93%8D%E4%BD%9C%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">9.1.</span> <span class="nav-text">位操作：6种位操作运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#define%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%85%B3%E9%94%AE%E8%AF%8D"><span class="nav-number">9.2.</span> <span class="nav-text">define宏定义关键词</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ifdef%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91"><span class="nav-number">9.3.</span> <span class="nav-text">ifdef条件编译</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#extern%E5%8F%98%E9%87%8F%E7%94%B3%E6%98%8E"><span class="nav-number">9.4.</span> <span class="nav-text">extern变量申明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#typedef%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="nav-number">9.5.</span> <span class="nav-text">typedef类型别名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9A%E6%9E%84%E9%80%A0%E7%B1%BB%E5%9E%8B"><span class="nav-number">9.6.</span> <span class="nav-text">结构体：构造类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#STM32%E4%B8%AD%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="nav-number">9.7.</span> <span class="nav-text">STM32中操作：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%97%B6%E9%92%9F%E7%B3%BB%E7%BB%9F"><span class="nav-number">10.</span> <span class="nav-text">时钟系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="nav-number">10.1.</span> <span class="nav-text">系统时钟初始化函数：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SysTick%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">11.</span> <span class="nav-text">SysTick定时器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8"><span class="nav-number">12.</span> <span class="nav-text">端口复用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7%E7%AE%A1%E7%90%86NVIC"><span class="nav-number">13.</span> <span class="nav-text">中断优先级管理NVIC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="nav-number">13.1.</span> <span class="nav-text">中断管理方法：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%A2%E5%8D%A0%E4%BC%98%E5%85%88%E7%BA%A7-amp-%E5%93%8D%E5%BA%94%E4%BC%98%E5%85%88%E7%BA%A7%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-number">13.2.</span> <span class="nav-text">抢占优先级 &amp; 响应优先级区别：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E5%88%AB%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="nav-number">13.3.</span> <span class="nav-text">特别说明：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7%E5%88%86%E7%BB%84%E5%87%BD%E6%95%B0"><span class="nav-number">13.4.</span> <span class="nav-text">中断优先级分组函数:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE%E5%8D%95%E4%B8%AA%E4%B8%AD%E6%96%AD%E7%9A%84%E6%8A%A2%E5%8D%A0%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E5%93%8D%E5%BA%94%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F"><span class="nav-number">13.5.</span> <span class="nav-text">怎么设置单个中断的抢占优先级和响应优先级？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8E%E6%AF%8F%E4%B8%AA%E4%B8%AD%E6%96%AD%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F"><span class="nav-number">13.6.</span> <span class="nav-text">对于每个中断怎么设置优先级？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E4%BD%BF%E8%83%BD%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84%EF%BC%9AISER-8"><span class="nav-number">13.7.</span> <span class="nav-text">中断使能寄存器组：ISER[8]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%B1%E8%83%BD%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84%EF%BC%9AICER-8"><span class="nav-number">13.8.</span> <span class="nav-text">中断失能寄存器组：ICER[8]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E6%8C%82%E8%B5%B7%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84%EF%BC%9AISPR-8"><span class="nav-number">13.9.</span> <span class="nav-text">中断挂起控制寄存器组：ISPR[8]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E8%A7%A3%E6%8C%82%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84%EF%BC%9AICPR-8"><span class="nav-number">13.10.</span> <span class="nav-text">中断解挂控制寄存器组：ICPR[8]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%8F%82%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0"><span class="nav-number">13.11.</span> <span class="nav-text">中断参数初始化函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7%E8%AE%BE%E7%BD%AE%E6%AD%A5%E9%AA%A4"><span class="nav-number">13.12.</span> <span class="nav-text">中断优先级设置步骤</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1"><span class="nav-number">14.</span> <span class="nav-text">串口通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86"><span class="nav-number">14.1.</span> <span class="nav-text">通信接口背景知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#STM32%E4%B8%B2%E5%8F%A3%E5%B8%B8%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E5%BA%93%E5%87%BD%E6%95%B0"><span class="nav-number">14.2.</span> <span class="nav-text">STM32串口常用寄存器和库函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E5%8F%A3%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0"><span class="nav-number">14.2.1.</span> <span class="nav-text">串口初始化函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E5%8F%A3%E9%85%8D%E7%BD%AE%E7%9A%84%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4"><span class="nav-number">14.2.2.</span> <span class="nav-text">串口配置的一般步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">14.2.3.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95"><span class="nav-number">14.2.4.</span> <span class="nav-text">测试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C"><span class="nav-number">15.</span> <span class="nav-text">外部中断实验</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E6%A6%82%E8%BF%B0"><span class="nav-number">15.1.</span> <span class="nav-text">外部中断概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0"><span class="nav-number">15.2.</span> <span class="nav-text">外部中断常用库函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#EXTI-Init%E5%87%BD%E6%95%B0"><span class="nav-number">15.2.1.</span> <span class="nav-text">EXTI_Init函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E7%9A%84%E4%B8%80%E8%88%AC%E9%85%8D%E7%BD%AE%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="nav-number">15.3.</span> <span class="nav-text">外部中断的一般配置步骤：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">15.4.</span> <span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9C%8B%E9%97%A8%E7%8B%97%E5%AE%9E%E9%AA%8C"><span class="nav-number">16.</span> <span class="nav-text">看门狗实验</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8B%AC%E7%AB%8B%E7%9C%8B%E9%97%A8%E7%8B%97%E6%A6%82%E8%BF%B0"><span class="nav-number">16.1.</span> <span class="nav-text">独立看门狗概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8B%AC%E7%AB%8B%E7%9C%8B%E9%97%A8%E7%8B%97%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4"><span class="nav-number">16.1.1.</span> <span class="nav-text">独立看门狗超时时间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IWDG%E7%8B%AC%E7%AB%8B%E7%9C%8B%E9%97%A8%E7%8B%97%E6%93%8D%E4%BD%9C%E5%BA%93%E5%87%BD%E6%95%B0"><span class="nav-number">16.2.</span> <span class="nav-text">IWDG独立看门狗操作库函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81"><span class="nav-number">16.3.</span> <span class="nav-text">程序代码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TFTLCD%E6%98%BE%E7%A4%BA%E5%AE%9E%E9%AA%8C"><span class="nav-number">17.</span> <span class="nav-text">TFTLCD显示实验</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TFTLCD%E9%A9%B1%E5%8A%A8%E5%8E%9F%E7%90%86-TFTLCD%E7%AE%80%E4%BB%8B"><span class="nav-number">17.1.</span> <span class="nav-text">TFTLCD驱动原理-TFTLCD简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ALINETEK-2-8%E5%AF%B8-TFTLCD%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E%EF%BC%8816%E4%BD%8D80%E5%B9%B6%E5%8F%A3%EF%BC%89%EF%BC%9A"><span class="nav-number">17.1.1.</span> <span class="nav-text">ALINETEK 2.8寸 TFTLCD接口说明（16位80并口）：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ALINETEK-2-8%E5%AF%B8-TFTLCD-16%E4%BD%8D80%E5%B9%B6%E5%8F%A3%E9%A9%B1%E5%8A%A8%E7%AE%80%E4%BB%8B"><span class="nav-number">17.1.2.</span> <span class="nav-text">ALINETEK 2.8寸 TFTLCD 16位80并口驱动简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ILI9341-%E9%A9%B1%E5%8A%A8%E6%97%B6%E5%BA%8F"><span class="nav-number">17.1.3.</span> <span class="nav-text">ILI9341 驱动时序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">17.1.4.</span> <span class="nav-text">驱动流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RGB565%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E"><span class="nav-number">17.1.5.</span> <span class="nav-text">RGB565格式说明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ILI9341%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E"><span class="nav-number">17.2.</span> <span class="nav-text">ILI9341指令格式说明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0XD3%E6%8C%87%E4%BB%A4"><span class="nav-number">17.2.1.</span> <span class="nav-text">0XD3指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0X36%E6%8C%87%E4%BB%A4"><span class="nav-number">17.2.2.</span> <span class="nav-text">0X36指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0X2A%E6%8C%87%E4%BB%A4"><span class="nav-number">17.2.3.</span> <span class="nav-text">0X2A指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0X2B%E6%8C%87%E4%BB%A4"><span class="nav-number">17.2.4.</span> <span class="nav-text">0X2B指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0X2C%E6%8C%87%E4%BB%A4"><span class="nav-number">17.2.5.</span> <span class="nav-text">0X2C指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0X2E%E6%8C%87%E4%BB%A4"><span class="nav-number">17.2.6.</span> <span class="nav-text">0X2E指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FSMC%E7%AE%80%E4%BB%8B-FSMC%E4%BB%8B%E7%BB%8D"><span class="nav-number">17.3.</span> <span class="nav-text">FSMC简介-FSMC介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FSMC%E9%A9%B1%E5%8A%A8LCD%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">17.3.1.</span> <span class="nav-text">FSMC驱动LCD的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%9D%971-%E6%93%8D%E4%BD%9C%E7%AE%80%E4%BB%8B"><span class="nav-number">17.3.2.</span> <span class="nav-text">存储块1 操作简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FSMC%E7%AE%80%E4%BB%8B-%E5%AF%84%E5%AD%98%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="nav-number">17.3.3.</span> <span class="nav-text">FSMC简介-寄存器介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SRAM-NOR%E9%97%AA%E5%AD%98%E7%89%87%E9%80%89%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88FSMC-BCRx%EF%BC%89"><span class="nav-number">17.3.3.1.</span> <span class="nav-text">SRAM&#x2F;NOR闪存片选控制寄存器（FSMC_BCRx）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SRAM-NOR%E9%97%AA%E5%AD%98%E7%89%87%E9%80%89%E6%97%B6%E5%BA%8F%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88FSMC-BTRx%EF%BC%89"><span class="nav-number">17.3.3.2.</span> <span class="nav-text">SRAM&#x2F;NOR闪存片选时序寄存器（FSMC_BTRx）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SRAM-NOR%E9%97%AA%E5%AD%98%E5%86%99%E6%97%B6%E5%BA%8F%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88FSMC-BWTRx%EF%BC%89"><span class="nav-number">17.3.3.3.</span> <span class="nav-text">SRAM&#x2F;NOR闪存写时序寄存器（FSMC_BWTRx）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84%E5%90%88%E8%AF%B4%E6%98%8E"><span class="nav-number">17.3.4.</span> <span class="nav-text">寄存器组合说明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E5%87%BD%E6%95%B0"><span class="nav-number">17.4.</span> <span class="nav-text">程序函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E8%BF%9E%E6%8E%A5"><span class="nav-number">17.4.1.</span> <span class="nav-text">硬件连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LCD%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">17.4.2.</span> <span class="nav-text">LCD结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E4%B8%AA%E5%BA%95%E5%B1%82%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="nav-number">17.4.3.</span> <span class="nav-text">7个底层接口函数：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LCD%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0%E4%BC%AA%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="nav-number">17.4.4.</span> <span class="nav-text">LCD初始化函数伪代码：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LCD%E5%9D%90%E6%A0%87%E8%AE%BE%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="nav-number">17.4.5.</span> <span class="nav-text">LCD坐标设置函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LCD%E7%94%BB%E7%82%B9%E5%87%BD%E6%95%B0"><span class="nav-number">17.4.6.</span> <span class="nav-text">LCD画点函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LCD%E8%AF%BB%E7%82%B9%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="nav-number">17.4.7.</span> <span class="nav-text">LCD读点函数：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E6%98%BE%E7%A4%BA%E5%87%BD%E6%95%B0"><span class="nav-number">17.4.8.</span> <span class="nav-text">字符显示函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E7%A0%81%E8%A1%A8"><span class="nav-number">17.4.9.</span> <span class="nav-text">字符码表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E7%94%9F%E4%BA%A7%E6%96%B9%E5%BC%8F"><span class="nav-number">17.5.</span> <span class="nav-text">字符生产方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B8%A9%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%E5%AE%9E%E9%AA%8C"><span class="nav-number">18.</span> <span class="nav-text">温度传感器实验</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DS18B20%E4%BB%8B%E7%BB%8D"><span class="nav-number">18.1.</span> <span class="nav-text">DS18B20介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DS18B20%E6%8A%80%E6%9C%AF%E6%80%A7%E8%83%BD%E7%89%B9%E5%BE%81%EF%BC%9A"><span class="nav-number">18.1.1.</span> <span class="nav-text">DS18B20技术性能特征：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DS18B20%E5%B0%81%E8%A3%85"><span class="nav-number">18.1.2.</span> <span class="nav-text">DS18B20封装</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%89%E6%95%8F%E4%BC%A0%E6%84%9F%E5%99%A8%E5%AE%9E%E9%AA%8C"><span class="nav-number">19.</span> <span class="nav-text">光敏传感器实验</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%89%E6%95%8F%E4%BC%A0%E6%84%9F%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="nav-number">19.1.</span> <span class="nav-text">光敏传感器简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E8%BF%9E%E6%8E%A5-1"><span class="nav-number">19.2.</span> <span class="nav-text">硬件连接</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%A6%E6%91%B8%E5%B1%8F%E5%AE%9E%E9%AA%8C"><span class="nav-number">20.</span> <span class="nav-text">触摸屏实验</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%B1%8F"><span class="nav-number">20.1.</span> <span class="nav-text">电容触摸屏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%B5%E9%98%BB%E5%B1%8F%E4%B8%8E%E7%94%B5%E5%AE%B9%E5%B1%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">20.2.</span> <span class="nav-text">电阻屏与电容屏的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A6%E6%91%B8%E5%B1%8F%E5%8E%9F%E7%90%86"><span class="nav-number">20.3.</span> <span class="nav-text">触摸屏原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BB%A3%E7%A0%81"><span class="nav-number">20.4.</span> <span class="nav-text">实验代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#touch-c%E4%B8%AD"><span class="nav-number">20.4.1.</span> <span class="nav-text">touch.c中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gt9147-c%E4%B8%AD"><span class="nav-number">20.4.2.</span> <span class="nav-text">gt9147.c中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#main%E5%87%BD%E6%95%B0%E4%B8%AD"><span class="nav-number">20.4.3.</span> <span class="nav-text">main函数中</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">风雪归心</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>

 

</body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
