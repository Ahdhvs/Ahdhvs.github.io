<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AcWing语法基础课错题记录</title>
    <url>/2022/01/27/AcWing%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE%E9%94%99%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="AcWing-604-圆的面积"><a href="#AcWing-604-圆的面积" class="headerlink" title="AcWing 604. 圆的面积"></a>AcWing 604. 圆的面积</h1><p>错误代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    float PI=3.14159;</span><br><span class="line">    float R;</span><br><span class="line">    cin&gt;&gt;R;</span><br><span class="line">    cout&lt;&lt;&quot;A=&quot;&lt;&lt; PI*R*R&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试输入 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10.16</span><br></pre></td></tr></table></figure>
<p>测试输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A=324.293</span><br></pre></td></tr></table></figure>
<p>标准答案</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A=324.2925</span><br></pre></td></tr></table></figure>
<p>分析原因：题目说了要保留四位小数，不用printf的话，用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fixed&lt;&lt;setprecisions(4)&lt;&lt;PI*R*R</span><br></pre></td></tr></table></figure>
<p>试试，记得加头文件<iomanip><br>答案仍错，把float换为double试试<br>测试成功,下面为正确代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    double PI=3.14159;</span><br><span class="line">    double R;</span><br><span class="line">    cin&gt;&gt;R;</span><br><span class="line">    cout&lt;&lt;&quot;A=&quot;&lt;&lt;fixed&lt;&lt;setprecision(4)&lt;&lt;PI*R*R&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="AcWing-616-两点间的距离"><a href="#AcWing-616-两点间的距离" class="headerlink" title="AcWing 616.两点间的距离"></a>AcWing 616.两点间的距离</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    double x1,y1,x2,y2;</span><br><span class="line">    cin&gt;&gt;x1&gt;&gt;y1;</span><br><span class="line">    cin&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;setprecision(4)&lt;&lt;sqrt((x1-x2)^2+(y1-y2)^2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>报错a.cpp:10:22: error: invalid operands of types ‘float’ and ‘float’ to binary ‘operator^’<br>百度原因是因为cpp不支持平方操作<br>修改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;fixed&lt;&lt;setprecision(4)&lt;&lt;sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));</span><br></pre></td></tr></table></figure>

<h1 id="AcWing-617-距离"><a href="#AcWing-617-距离" class="headerlink" title="AcWing 617. 距离"></a>AcWing 617. 距离</h1><p>题目：两辆汽车在同一地点，同时，沿同一方向前进。<br>一辆车的速度为 60 km/h，另一辆车的速度为 90 km/h。<br>显然，快车与慢车的距离会不断拉开，每过一个小时（60 分钟），两车的距离就拉开 30 公里。<br>现在，告诉你两车之间的距离为 L 公里，请你求出两车已经行驶了多长时间？<br>错误代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    int L;</span><br><span class="line">    cin &gt;&gt; L;</span><br><span class="line">    cout&lt;&lt;L/(90-60)*60&lt;&lt;&quot; minutos&quot;&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误原因：没有考虑到/是整除，L可能不是30的整数倍，此时应该如何解决问题呢？<br>修改：快车与慢车每小时拉开30KM，每分钟拉开0.5KM<br>直接把单位换算到分钟，不用小时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    int L;</span><br><span class="line">    cin &gt;&gt; L;</span><br><span class="line">    cout&lt;&lt;L/0.5&lt;&lt;&quot; minutos&quot;&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仍然错误；此时可以看到除了0.5,变成浮点数了，数字太大的话会变成科学技术法，与标准输出不同，我们强制转换为int;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    int L;</span><br><span class="line">    cin &gt;&gt; L;</span><br><span class="line">    cout&lt;&lt;(int)(L/0.5)&lt;&lt;&quot; minutos&quot;&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成功</p>
<h1 id="AcWing-656-钞票和硬币"><a href="#AcWing-656-钞票和硬币" class="headerlink" title="AcWing 656. 钞票和硬币"></a>AcWing 656. 钞票和硬币</h1><p>错误在于，对小数进行区域操作是不可行的;<br>我们把小数部分扩大数量级至整数部分就能正确地使用取余操作了;<br>但是此处出现了问题<br>源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    double number;</span><br><span class="line">    cin&gt;&gt;number;</span><br><span class="line">    int a,b,c,d,e,f,g,h,i,j,k,l;</span><br><span class="line">    a=number/100;</span><br><span class="line">    b=(number-a*100)/50;</span><br><span class="line">    c=(number-a*100-b*50)/20;</span><br><span class="line">    d=(number-a*100-b*50-c*20)/10;</span><br><span class="line">    e=(number-a*100-b*50-c*20-d*10)/5;</span><br><span class="line">    f=(number-a*100-b*50-c*20-d*10-e*5)/2;</span><br><span class="line">    cout&lt;&lt;&quot;NOTAS:&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;&quot; nota(s) de R$ 100.00&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;b&lt;&lt;&quot; nota(s) de R$ 50.00&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;c&lt;&lt;&quot; nota(s) de R$ 20.00&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;d&lt;&lt;&quot; nota(s) de R$ 10.00&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;e&lt;&lt;&quot; nota(s) de R$ 5.00&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;f&lt;&lt;&quot; nota(s) de R$ 2.00&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;MOEDAS:&quot;&lt;&lt;endl;</span><br><span class="line">    g=(number-a*100-b*50-c*20-d*10-e*5-f*2)/1;</span><br><span class="line">    h=(number-a*100-b*50-c*20-d*10-e*5-f*2-g*1)*100/50;</span><br><span class="line">    i=(number-a*100-b*50-c*20-d*10-e*5-f*2-g*1-h*0.5)*100/25;</span><br><span class="line">    j=(number-a*100-b*50-c*20-d*10-e*5-f*2-g*1-h*0.5-i*0.25)*100/10;</span><br><span class="line">    k=(number-a*100-b*50-c*20-d*10-e*5-f*2-g*1-h*0.5-i*0.25-j*0.1)*100/5;</span><br><span class="line">    l=(number-a*100-b*50-c*20-d*10-e*5-f*2-g*1-h*0.5-i*0.25-j*0.1-k*0.05)*100/1;</span><br><span class="line">    cout&lt;&lt;g&lt;&lt;&quot; moeda(s) de R$ 1.00&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;h&lt;&lt;&quot; moeda(s) de R$ 0.50&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;i&lt;&lt;&quot; moeda(s) de R$ 0.25&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;j&lt;&lt;&quot; moeda(s) de R$ 0.10&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;k&lt;&lt;&quot; moeda(s) de R$ 0.05&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;l&lt;&lt;&quot; moeda(s) de R$ 0.01&quot;&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">463.01</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NOTAS:</span><br><span class="line">4 nota(s) de R$ 100.00</span><br><span class="line">1 nota(s) de R$ 50.00</span><br><span class="line">0 nota(s) de R$ 20.00</span><br><span class="line">1 nota(s) de R$ 10.00</span><br><span class="line">0 nota(s) de R$ 5.00</span><br><span class="line">1 nota(s) de R$ 2.00</span><br><span class="line">MOEDAS:</span><br><span class="line">1 moeda(s) de R$ 1.00</span><br><span class="line">0 moeda(s) de R$ 0.50</span><br><span class="line">0 moeda(s) de R$ 0.25</span><br><span class="line">0 moeda(s) de R$ 0.10</span><br><span class="line">0 moeda(s) de R$ 0.05</span><br><span class="line">0 moeda(s) de R$ 0.01</span><br></pre></td></tr></table></figure>
<p>标准答案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NOTAS:</span><br><span class="line">4 nota(s) de R$ 100.00</span><br><span class="line">1 nota(s) de R$ 50.00</span><br><span class="line">0 nota(s) de R$ 20.00</span><br><span class="line">1 nota(s) de R$ 10.00</span><br><span class="line">0 nota(s) de R$ 5.00</span><br><span class="line">1 nota(s) de R$ 2.00</span><br><span class="line">MOEDAS:</span><br><span class="line">1 moeda(s) de R$ 1.00</span><br><span class="line">0 moeda(s) de R$ 0.50</span><br><span class="line">0 moeda(s) de R$ 0.25</span><br><span class="line">0 moeda(s) de R$ 0.10</span><br><span class="line">0 moeda(s) de R$ 0.05</span><br><span class="line">1 moeda(s) de R$ 0.01</span><br></pre></td></tr></table></figure>
<p>很明显最后一行的值没对上，l的值是有问题的，为啥捏？？<br>单独输出一行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;(number-a*100-b*50-c*20-d*10-e*5-f*2-g*1-h*0.5-i*0.25-j*0.1-k*0.05)*100/1;</span><br></pre></td></tr></table></figure>
<p>结果是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<p><strong>我直接黑人问号????what’s your problem ??</strong><br>想了想，l是int型变量，而(number-a<em>100-b</em>50-c<em>20-d</em>10-e<em>5-f</em>2-g<em>1-h</em>0.5-i<em>0.25-j</em>0.1-k*0.05)*100/1应该是float型；<br>强制转换一下输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;(int)((number-a*100-b*50-c*20-d*10-e*5-f*2-g*1-h*0.5-i*0.25-j*0.1-k*0.05)*100/1);</span><br></pre></td></tr></table></figure>
<p>结果为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>
<p>好家伙，问题果然出在这儿；<br>float的1转换为int居然变成0了？为啥啊？？应该是储存的问题，原谅我不考计组==<br>那么精度丢失只影响最后一位。我们不定义l;直接输出l试试：<br>测试成功<br>这会儿倒是没问题了，但是又有新的问题出现了==<br>样例输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2214.9</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NOTAS:</span><br><span class="line">22 nota(s) de R$ 100.00</span><br><span class="line">0 nota(s) de R$ 50.00</span><br><span class="line">0 nota(s) de R$ 20.00</span><br><span class="line">1 nota(s) de R$ 10.00</span><br><span class="line">0 nota(s) de R$ 5.00</span><br><span class="line">2 nota(s) de R$ 2.00</span><br><span class="line">MOEDAS:</span><br><span class="line">0 moeda(s) de R$ 1.00</span><br><span class="line">1 moeda(s) de R$ 0.50</span><br><span class="line">1 moeda(s) de R$ 0.25</span><br><span class="line">1 moeda(s) de R$ 0.10</span><br><span class="line">1 moeda(s) de R$ 0.05</span><br><span class="line">9.09411e-12 moeda(s) de R$ 0.01</span><br></pre></td></tr></table></figure>
<p>最后一行直接芜湖起飞好吧==一看就是精度的问题<br>人麻了==我直接大换血，整数部分不变，小数部分开刀</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    double number;</span><br><span class="line">    cin&gt;&gt;number;</span><br><span class="line">    int a,b,c,d,e,f,g,h,i,j,k,l;</span><br><span class="line">    a=number/100;</span><br><span class="line">    b=(number-a*100)/50;</span><br><span class="line">    c=(number-a*100-b*50)/20;</span><br><span class="line">    d=(number-a*100-b*50-c*20)/10;</span><br><span class="line">    e=(number-a*100-b*50-c*20-d*10)/5;</span><br><span class="line">    f=(number-a*100-b*50-c*20-d*10-e*5)/2;</span><br><span class="line">    cout&lt;&lt;&quot;NOTAS:&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;&quot; nota(s) de R$ 100.00&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;b&lt;&lt;&quot; nota(s) de R$ 50.00&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;c&lt;&lt;&quot; nota(s) de R$ 20.00&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;d&lt;&lt;&quot; nota(s) de R$ 10.00&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;e&lt;&lt;&quot; nota(s) de R$ 5.00&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;f&lt;&lt;&quot; nota(s) de R$ 2.00&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;MOEDAS:&quot;&lt;&lt;endl;</span><br><span class="line">    g=(number-a*100-b*50-c*20-d*10-e*5-f*2)/1;</span><br><span class="line">    h=(number*100-a*10000-b*5000-c*2000-d*1000-e*500-f*200-g*100)/50;</span><br><span class="line">    i=(number*100-a*10000-b*5000-c*2000-d*1000-e*500-f*200-g*100-h*50)/25;</span><br><span class="line">    j=(number*100-a*10000-b*5000-c*2000-d*1000-e*500-f*200-g*100-h*50-i*25)/10;</span><br><span class="line">    k=(number*100-a*10000-b*5000-c*2000-d*1000-e*500-f*200-g*100-h*50-i*25-j*10)/5;</span><br><span class="line">    l=(number*100-a*10000-b*5000-c*2000-d*1000-e*500-f*200-g*100-h*50-i*25-j*10-k*5)/1;</span><br><span class="line">    cout&lt;&lt;g&lt;&lt;&quot; moeda(s) de R$ 1.00&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;h&lt;&lt;&quot; moeda(s) de R$ 0.50&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;i&lt;&lt;&quot; moeda(s) de R$ 0.25&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;j&lt;&lt;&quot; moeda(s) de R$ 0.10&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;k&lt;&lt;&quot; moeda(s) de R$ 0.05&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;l&lt;&lt;&quot; moeda(s) de R$ 0.01&quot;&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试成功，<em><strong>血的教训！！不要TM玩小数，能用整数的地方坚决避免出现小数！！</strong></em></p>
<h1 id="AcWing-725-完全数"><a href="#AcWing-725-完全数" class="headerlink" title="AcWing 725. 完全数"></a>AcWing 725. 完全数</h1><p>源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,sum=0;</span><br><span class="line">    long long a;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a;</span><br><span class="line">        for(long long j=1;j&lt;a;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(a%j==0)</span><br><span class="line">                sum+=j;</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum==a)</span><br><span class="line">            cout&lt;&lt;a&lt;&lt;&quot; is perfect&quot;&lt;&lt;endl;</span><br><span class="line">        else</span><br><span class="line">            cout&lt;&lt;a&lt;&lt;&quot; is not perfect&quot;&lt;&lt;endl;</span><br><span class="line">        sum=0;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">28</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 is perfect</span><br><span class="line">5 is not perfect</span><br><span class="line">28 is perfect</span><br></pre></td></tr></table></figure>
<p>没毛病，提交后显示Time Limit Exceeded ，超时了，第一次遇到，估计是两层嵌套时间复杂度太高了<br>看看讲解<br>如果d能整除x，即d%x==0;则d/x也能整除x，即d%(d/x)==0;<br>例如12%2==0;12%(12/2)==12%6==0;<br>所以<br>约数从小往大取，3是12的一个约数，12/3==4是另一个约数<br>假设i是一个约数，则n/i&gt;=i<br>即i²&lt;=n<br>即i&lt;=sqrt(n)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a,n,sum=0;</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a;</span><br><span class="line">        if(a==1)</span><br><span class="line">            cout&lt;&lt;&quot;1 is not perfect&quot;&lt;&lt;endl;</span><br><span class="line">        else </span><br><span class="line">        &#123;</span><br><span class="line">        for(int j=1;j*j&lt;=a;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(a%j==0)</span><br><span class="line">                sum=j+(a/j)+sum;</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum==a*2)</span><br><span class="line">            cout&lt;&lt;a&lt;&lt;&quot; is perfect&quot;&lt;&lt;endl;</span><br><span class="line">        else</span><br><span class="line">            cout&lt;&lt;a&lt;&lt;&quot; is not perfect&quot;&lt;&lt;endl;</span><br><span class="line">        sum=0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是正确代码，说一下需要注意的点<br>本题的思想是：找到一个约数就等于找到了两个约数，这样可以减小时间复杂度<br>比如看28是不是完全数，找约数：<br>1,28<br>2,14<br>4,7<br>找三次就能找到所有约数，再加起来，注意这里把所有的约数加上的话把本身28也加上去了，所以最后要除2</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>错题</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing语法基础课笔记</title>
    <url>/2022/01/27/AcWing%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="1、编译环境"><a href="#1、编译环境" class="headerlink" title="1、编译环境"></a><strong>1、编译环境</strong></h1><p>采用线上编译，地址：<br><a href="https://www.acwing.com/file_system/file/content/whole/index/content/172575/">https://www.acwing.com/file_system/file/content/whole/index/content/172575/</a></p>
<p>输出一个hello world</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt;&quot;Hello World&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先保存代码再点调试运行</p>
<h1 id="2、C-代码一般格式"><a href="#2、C-代码一般格式" class="headerlink" title="2、C++代码一般格式"></a><strong>2、C++代码一般格式</strong></h1><h2 id="2-1常用头文件"><a href="#2-1常用头文件" class="headerlink" title="2.1常用头文件"></a><strong>2.1常用头文件</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br></pre></td></tr></table></figure>
<p>cstdio中包含printf和scanf<br>iostream中包含 cin和cout</p>
<h2 id="2-2、using-namespace-std使用std命名空间"><a href="#2-2、using-namespace-std使用std命名空间" class="headerlink" title="2.2、using namespace std使用std命名空间"></a><strong>2.2、using namespace std使用std命名空间</strong></h2><p>删掉这一句编译会报错</p>
<h2 id="2-3、int-main-函数入口"><a href="#2-3、int-main-函数入口" class="headerlink" title="2.3、int main()函数入口"></a><strong>2.3、int main()函数入口</strong></h2><h2 id="2-4、最后要return-0"><a href="#2-4、最后要return-0" class="headerlink" title="2.4、最后要return 0"></a><strong>2.4、最后要return 0</strong></h2><h1 id="3、作业和提交"><a href="#3、作业和提交" class="headerlink" title="3、作业和提交"></a><strong>3、作业和提交</strong></h1><p>作业要刷完嗷<br><a href="https://www.acwing.com/activity/content/punch_the_clock/21/">https://www.acwing.com/activity/content/punch_the_clock/21/</a></p>
<h1 id="4、C-基本语法"><a href="#4、C-基本语法" class="headerlink" title="4、C++基本语法"></a><strong>4、C++基本语法</strong></h1><p>变量类型:<br>bool(true=1和false=0)   1B<br>char ‘c’,’a’,’’,’\n’    1B<br>int (-2^31至+2^31-1)     4B<br>float 1.23 1.23e2(支持科学计数法) 有效位数6~7位 4B<br>double 15至16位有效数字   8B<br>long long (-2^63至263-1) 8B<br>long double 18至19位    12B/16B<br>1Byte=8bit</p>
<h2 id="4-1定义变量"><a href="#4-1定义变量" class="headerlink" title="4.1定义变量"></a>4.1定义变量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a,b=2,c=b;</span><br><span class="line">float d=1.5,e=1,f=1.235;</span><br><span class="line">bool g=true,h=false;</span><br><span class="line">char j=&#x27;a&#x27;,k =&#x27;b&#x27;;</span><br><span class="line">long long 1=1231341;</span><br><span class="line">long double m=123.45;</span><br></pre></td></tr></table></figure>
<h2 id="4-2变量输出"><a href="#4-2变量输出" class="headerlink" title="4.2变量输出"></a>4.2变量输出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a, b;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;//输入</span><br><span class="line">cout &lt;&lt; a+b &lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p>注意，提交的时候要先输入两个数据，再点运行<br>Accepted通过<br>Wrong Answer 答案错误<br>Time Limit Error 超时<br>Memory Limit Error 超内存<br>Segmentation Fault 数组越界<br>Compile Error 编译错误<br>Presentation Error 表示错误<br>注意打卡界面是markdown语法代码前面记得加4个`</p>
<h3 id="4-2-1输出多个变量"><a href="#4-2-1输出多个变量" class="headerlink" title="4.2.1输出多个变量"></a>4.2.1输出多个变量</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a, b;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;//输入</span><br><span class="line">cout &lt;&lt; a+b &lt;&lt; &#x27; &#x27; &lt;&lt; a*b &lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<h2 id="4-3-scanf和printf"><a href="#4-3-scanf和printf" class="headerlink" title="4.3 scanf和printf"></a>4.3 scanf和printf</h2><p>这两个函数是在 cstdio.h中的，记得加头文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    int a,b;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">    printf(&quot;a+b=%d\na*b=%d\n&quot;,a+b,a*b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整数%d,浮点数%f,%.2f表示保留两位小数<br>字符%c，double %lf, long long %ll</p>
<h2 id="4-4关于空格的读入"><a href="#4-4关于空格的读入" class="headerlink" title="4.4关于空格的读入"></a>4.4关于空格的读入</h2><p>1.cin</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">printf (&quot;%c %c&quot;,a,b);</span><br><span class="line">//输入a      c输出a c</span><br></pre></td></tr></table></figure>
<p>2.scanf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scanf(&quot;%c%c&quot;,&amp;a,&amp;b);</span><br><span class="line">printf(&quot;%c %c&quot;,a,b);</span><br><span class="line">//输入ac输出a c</span><br><span class="line">//输入a c输出a </span><br></pre></td></tr></table></figure>
<p>可见cin可以自动过滤空格，且cin、cout的效率比scanf、printf低</p>
<h2 id="4-5四则运算"><a href="#4-5四则运算" class="headerlink" title="4.5四则运算"></a>4.5四则运算</h2><p>加法a+b<br>出发a-b<br>乘法a*b<br>除法a/b<br>取余a%b 注意取余结果的符号只和前面有关 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a=5,b=-2;</span><br><span class="line">printf(&quot;%d&quot;,a%b);</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure>
<p>结果为1</p>
<h2 id="4-6变量类型强制转换"><a href="#4-6变量类型强制转换" class="headerlink" title="4.6变量类型强制转换"></a>4.6变量类型强制转换</h2><p>int→float<br>float→int(下取整，损失精度)<br>int←→char(ASCII码)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char c=&#x27;A&#x27;;</span><br><span class="line">cout &lt;&lt; (char)(c+32)&lt;&lt;endl; </span><br></pre></td></tr></table></figure>
<p>输出结果为a</p>
<p>两个不同类型的变量之间运算，低精度会向精度高的一方转换</p>
<h1 id="5、printf和c-中的判断结构"><a href="#5、printf和c-中的判断结构" class="headerlink" title="5、printf和c++中的判断结构"></a><strong>5、printf和c++中的判断结构</strong></h1><h2 id="5-1-printf的用法"><a href="#5-1-printf的用法" class="headerlink" title="5.1 printf的用法"></a>5.1 printf的用法</h2><p>printf的格式化输出：想让每个输出占的宽度一定该怎么办？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a=1;</span><br><span class="line">    int b=12;</span><br><span class="line">    int c=123;</span><br><span class="line">    int d=123456;</span><br><span class="line">    printf(&quot;%5d\n&quot;,a);</span><br><span class="line">    printf(&quot;%5d\n&quot;,b);</span><br><span class="line">    printf(&quot;%5d\n&quot;,c);</span><br><span class="line">    printf(&quot;%5d\n&quot;,d);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   12</span><br><span class="line">  123</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>
<p>可以发现结果是不足五个字符的话前面补空格，超出了不管，全部输出</p>
<p>如果想要左对齐怎么办？<br>将</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;%5d\n&quot;,a);</span><br></pre></td></tr></table></figure>
<p>修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;%-5d\n&quot;,a);</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1    </span><br><span class="line">12   </span><br><span class="line">123  </span><br><span class="line">123456</span><br></pre></td></tr></table></figure>
<p>现在是不足五位补空格，如果我们想补0该怎么办？<br>把</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;%5d\n&quot;,a);</span><br></pre></td></tr></table></figure>
<p>改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;%05d\n&quot;,a);</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00001</span><br><span class="line">00012</span><br><span class="line">00123</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>
<h2 id="5-2浮点数如何固定长度？"><a href="#5-2浮点数如何固定长度？" class="headerlink" title="5.2浮点数如何固定长度？"></a>5.2浮点数如何固定长度？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double f = 12.34;</span><br><span class="line">printf(&quot;%05.1lf&quot;,f);</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">012.3</span><br></pre></td></tr></table></figure>
<p>%05.1lf中的这一句，0表示的是不足5位的占零；5表示要输出5位；.1表示的是小数点后保留一位，lf是double对应的输出；<br>注意：小数点要占一位</p>
<h2 id="5-3-if语句"><a href="#5-3-if语句" class="headerlink" title="5.3 if语句"></a>5.3 if语句</h2><p>基本的if语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int score;</span><br><span class="line">    cin &gt;&gt; score;</span><br><span class="line">    if (score&gt;=60)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;PASS&quot; &lt;&lt; endl;;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;FAILED&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，if和else之后不要加分号，加了有空语句<br>if和else后面只有一个句子的时候可以省略空格；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (score&gt;=60)</span><br><span class="line">     cout &lt;&lt; &quot;PASS&quot; &lt;&lt; endl;</span><br><span class="line"> else</span><br><span class="line">     cout &lt;&lt; &quot;FAILED&quot; &lt;&lt; endl;</span><br><span class="line"> return 0;</span><br></pre></td></tr></table></figure>
<h2 id="5-4判断语句的表示方式"><a href="#5-4判断语句的表示方式" class="headerlink" title="5.4判断语句的表示方式"></a>5.4判断语句的表示方式</h2><p>大于等于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">大于 &gt;</span><br><span class="line">小于 &lt;</span><br><span class="line">大于等于 &gt;=</span><br><span class="line">小于等于 &lt;=</span><br><span class="line">等于 ==</span><br><span class="line">不等于 ！=</span><br></pre></td></tr></table></figure>
<h2 id="5-5-else-if-的由来"><a href="#5-5-else-if-的由来" class="headerlink" title="5.5 else if 的由来"></a>5.5 else if 的由来</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cin score;</span><br><span class="line">if (a &gt; 90)</span><br><span class="line">    cout &lt;&lt; &quot;great&quot; ;</span><br><span class="line">else</span><br><span class="line">    if (a &gt; 80)</span><br><span class="line">        cout &lt;&lt; &quot;good&quot; ;</span><br><span class="line">    else</span><br><span class="line">        if (a &gt; 70) </span><br><span class="line">            cout &lt;&lt; &quot;normal&quot; ;</span><br><span class="line">        else</span><br><span class="line">            if (a &gt; 60)</span><br><span class="line">                cout &lt;&lt; &quot;pass&quot; ;</span><br><span class="line">            else</span><br><span class="line">                cout &lt;&lt; &quot;failed&quot; ;</span><br></pre></td></tr></table></figure>
<p>删去不必要的空格就能得到 if else</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cin score;</span><br><span class="line">if (a &gt; 90)</span><br><span class="line">    cout &lt;&lt; &quot;great&quot; ;</span><br><span class="line">else if (a &gt; 80)</span><br><span class="line">    cout &lt;&lt; &quot;good&quot; ;</span><br><span class="line">else if (a &gt; 70) </span><br><span class="line">    cout &lt;&lt; &quot;normal&quot; ;</span><br><span class="line">else if (a &gt; 60)</span><br><span class="line">    cout &lt;&lt; &quot;pass&quot; ;</span><br><span class="line">else</span><br><span class="line">    cout &lt;&lt; &quot;failed&quot; ;</span><br></pre></td></tr></table></figure>
<h2 id="5-6-一道练习题"><a href="#5-6-一道练习题" class="headerlink" title="5.6 一道练习题"></a>5.6 一道练习题</h2><pre><code>简单计算器输入两个数，以及一个运算符+-*/
输出两个数运算的结果
运算符为/且被除数为0时输出 Divided by zero !
运算符不是+-*/时输出 Invalid Operator
</code></pre>
<p>源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   double a,b;</span><br><span class="line">   char c;</span><br><span class="line">   cin &gt;&gt; a &gt;&gt; c &gt;&gt; b;</span><br><span class="line">   if (c==&#x27;+&#x27;)</span><br><span class="line">    printf(&quot;%.1lf+%.1lf=%.1lf&quot;,&amp;a,&amp;b,&amp;(a+b));</span><br><span class="line">   else if (c==&#x27;-&#x27;)</span><br><span class="line">    printf(&quot;%.1lf-%.1lf=%.1lf&quot;,&amp;a,&amp;b,&amp;(a-b));</span><br><span class="line">   else if (c==&#x27;*&#x27;)</span><br><span class="line">    printf(&quot;%.1lf*%.1lf=%.1lf&quot;,&amp;a,&amp;b,&amp;(a*b));</span><br><span class="line">   else if (c==&#x27;/&#x27;)</span><br><span class="line">   &#123;</span><br><span class="line">    if (b!=0)</span><br><span class="line">    printf(&quot;%.1lf/%.1lf=%.1lf&quot;,&amp;a,&amp;b,&amp;(a/b));</span><br><span class="line">    else</span><br><span class="line">    printf(&quot;Divided by zero !&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">    printf(&quot;Invalid Operator&quot;);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出现报错：<br>a.cpp:11:43: error: lvalue required as unary ‘&amp;’ operand<br>  11 |     printf(“%.1lf+%.1lf=%.1lf”,&amp;a,&amp;b,&amp;(a+b));<br>报错是因为 &amp; 只能作用在变量上，不能作用在表达式上<br>我们多定义一个变量d来存放运算值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   double a,b,d;</span><br><span class="line">   char c;</span><br><span class="line">   cin &gt;&gt; a &gt;&gt; c &gt;&gt; b;</span><br><span class="line">   if (c==&#x27;+&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        d=a+b;</span><br><span class="line">        printf(&quot;%.1lf+%.1lf=%.1lf&quot;,&amp;a,&amp;b,&amp;d);</span><br><span class="line">    &#125;</span><br><span class="line">   else if (c==&#x27;-&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        d=a-b;</span><br><span class="line">        printf(&quot;%.1lf-%.1lf=%.1lf&quot;,&amp;a,&amp;b,&amp;d);</span><br><span class="line">    &#125;</span><br><span class="line">   else if (c==&#x27;*&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        d=a*b;</span><br><span class="line">        printf(&quot;%.1lf*%.1lf=%.1lf&quot;,&amp;a,&amp;b,&amp;d);</span><br><span class="line">    &#125;</span><br><span class="line">   else if (c==&#x27;/&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        if (b!=0)</span><br><span class="line">            &#123;</span><br><span class="line">                d=a/b;</span><br><span class="line">                printf(&quot;%.1lf/%.1lf=%.1lf&quot;,&amp;a,&amp;b,&amp;d);</span><br><span class="line">            &#125;</span><br><span class="line">        else</span><br><span class="line">        printf(&quot;Divided by zero !&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">   else</span><br><span class="line">    printf(&quot;Invalid Operator&quot;);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12/41</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.0/0.0=0.0</span><br></pre></td></tr></table></figure>
<p>感觉是cin出了问题，用scanf看看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scanf(&quot;%lf%c%lf&quot;,&amp;a,&amp;c,&amp;b);</span><br></pre></td></tr></table></figure>
<p>输出还是一样<br>我们在scanf后面加一句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;a&lt;&lt;c&lt;&lt;b&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12+14</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12+14</span><br><span class="line">0.0+0.0=0.0</span><br></pre></td></tr></table></figure>
<p>那问题知道出在哪儿了，就在printf的语句上，重新看了一下printf语法，···printf的变量不用&amp;，···全部搞忘了，cout害人不浅啊，重新修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   double a,b;</span><br><span class="line">   char c;</span><br><span class="line">   scanf(&quot;%lf%c%lf&quot;,&amp;a,&amp;c,&amp;b);</span><br><span class="line">   if (c==&#x27;+&#x27;)</span><br><span class="line">        printf(&quot;%.1lf+%.1lf=%.1lf&quot;,a,b,a+b);</span><br><span class="line">   else if (c==&#x27;-&#x27;)</span><br><span class="line">        printf(&quot;%.1lf-%.1lf=%.1lf&quot;,a,b,a-b);</span><br><span class="line">   else if (c==&#x27;*&#x27;)</span><br><span class="line">        printf(&quot;%.1lf*%.1lf=%.1lf&quot;,a,b,a*b);</span><br><span class="line">   else if (c==&#x27;/&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        if (b!=0)</span><br><span class="line">                printf(&quot;%.1lf/%.1lf=%.1lf&quot;,a,b,a/b);</span><br><span class="line">        else</span><br><span class="line">        printf(&quot;Divided by zero !&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">   else</span><br><span class="line">    printf(&quot;Invalid Operator&quot;);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.21334*14134.51532</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.2*14134.5=17150.0</span><br></pre></td></tr></table></figure>

<h1 id="6、循环语句"><a href="#6、循环语句" class="headerlink" title="6、循环语句"></a><strong>6、循环语句</strong></h1><p>斐波那契数列<br>f(1)=1,f(2)=1<br>f(n)=f(n-1)+f(n-2)<br>求f(n)<br>令a=f(1),b=f(2),c=f(3)=a+b,b+c作为f(4)的值代替a+b<br>从(a,b)→(b,c)需要：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=b;b=c;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">循环次数</th>
<th align="center">a</th>
<th align="center">b</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">f(1)</td>
<td align="center">f(2)</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">f(2)</td>
<td align="center">f(3)</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">f(3)</td>
<td align="center">f(4)</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">n-1</td>
<td align="center">f(n)</td>
<td align="center">f(n+1)</td>
</tr>
</tbody></table>
<p><strong>求斐波那契数列的第n项</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a=1,b=1;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    int i=0</span><br><span class="line">    while(i&lt;n-1)</span><br><span class="line">    &#123;</span><br><span class="line">        int c=a+b;</span><br><span class="line">        a=b;</span><br><span class="line">        b=c;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>循环的效率比递归更高</p>
<h2 id="6-1-break和continue"><a href="#6-1-break和continue" class="headerlink" title="6.1 break和continue"></a>6.1 break和continue</h2><p>break是直接跳过整个循环开始执行下面的语句，continue是跳过本次循环的后面内容，开始下次循环</p>
<h2 id="6-2-打印菱形程序的快速方法"><a href="#6-2-打印菱形程序的快速方法" class="headerlink" title="6.2 打印菱形程序的快速方法"></a>6.2 打印菱形程序的快速方法</h2><p>打印</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  *  </span><br><span class="line"> *** </span><br><span class="line">*****</span><br><span class="line"> *** </span><br><span class="line">  *  </span><br></pre></td></tr></table></figure>
<p>整个图形其实是一个n*n的正方形，有n²个元素，找到中心点<br>两点之间的距离是sqrt((x1-x2)²+(y1-y2)²)<br>曼哈顿距离：|x1-x2|+|y1-y2| (横坐标差值绝对值+纵坐标差值绝对值)<br>我们可以看到所有要打印的菱形距离中心点的曼哈顿距离都&lt;=(n/2),n为阶数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    int cx = n/2;</span><br><span class="line">    int cy = n/2;</span><br><span class="line">    for(int i = 0; i &lt; n ; i++)</span><br><span class="line">    &#123;    </span><br><span class="line">        for(int j = 0; j &lt; n ; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if ((abs(i-cx)+abs(j-cy))&lt;=n/2)</span><br><span class="line">                cout &lt;&lt; &quot;*&quot; ;</span><br><span class="line">            else </span><br><span class="line">                cout &lt;&lt; &quot; &quot;&gt; ; </span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-4-while-if-for语句的多语句-和cin混搭"><a href="#6-4-while-if-for语句的多语句-和cin混搭" class="headerlink" title="6.4 while;if;for语句的多语句(和cin混搭)"></a>6.4 while;if;for语句的多语句(和cin混搭)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(cin&gt;&gt;n,n&lt;=0&gt;)</span><br><span class="line">if(cin&gt;&gt;n,n&lt;=0&gt;)</span><br><span class="line">for(;cin&gt;&gt;n,n&lt;=0&gt;;)</span><br></pre></td></tr></table></figure>
<p>像这行代码，判断句里面有两个语句，最终是由最后一个语句来判断条件<br>所以可以一直执行输入数据的操作<br>cin只要有输入就会返回true</p>
<h2 id="6-4-scanf在读入数据时不会自动过滤空格"><a href="#6-4-scanf在读入数据时不会自动过滤空格" class="headerlink" title="6.4 scanf在读入数据时不会自动过滤空格"></a>6.4 scanf在读入数据时不会自动过滤空格</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br></pre></td></tr></table></figure>
<p>输入数据为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 1</span><br></pre></td></tr></table></figure>
<p>cin输入的是6和1<br>scanf输入的其实是6和空格，所以需要调整</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scanf(&quot;%d %d&quot;,&amp;a,&amp;b);</span><br></pre></td></tr></table></figure>
<h2 id="6-5scanf的格式化读入"><a href="#6-5scanf的格式化读入" class="headerlink" title="6.5scanf的格式化读入"></a>6.5scanf的格式化读入</h2><p>f是format的意思，例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scanf(&quot;A=%d,B=%d&quot;,&amp;a,&amp;b);</span><br><span class="line">cout&lt;&lt;a&lt;&lt;&quot;&quot;&lt;&lt;b;</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A=3,B=2</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 2</span><br></pre></td></tr></table></figure>
<h1 id="7、数组"><a href="#7、数组" class="headerlink" title="7、数组"></a><strong>7、数组</strong></h1><h2 id="7-1数组初始化"><a href="#7-1数组初始化" class="headerlink" title="7.1数组初始化"></a>7.1数组初始化</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a[3]=&#123;0,1,2&#125;;</span><br><span class="line">int b[]=&#123;0,1,2&#125;;</span><br><span class="line">int c[5]=&#123;0,1,1&#125;;//定义了一个长度为5的数组，前三个为0,1,1后面的为0</span><br><span class="line">char d[]=&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;</span><br><span class="line">int f[10]=&#123;0&#125;;//常用的初始化方式</span><br></pre></td></tr></table></figure>

<h2 id="7-2数组长度过长的问题"><a href="#7-2数组长度过长的问题" class="headerlink" title="7.2数组长度过长的问题"></a>7.2数组长度过长的问题</h2><p>函数内部的变量（数组）会放进栈空间，栈空间一般默认为1M<br>如果在main函数内部定义int a[1000000]<br>则会占用 1000000*4=4000000B≈4000KB≈4MB<br>栈空间不足会报错<br>解决方法：定义在main函数外面，此时占用的是堆空间，没有限制</p>
<h2 id="7-3旋转数组"><a href="#7-3旋转数组" class="headerlink" title="7.3旋转数组"></a>7.3旋转数组</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a[5]=&#123;0,1,2,3,4&#125;;</span><br></pre></td></tr></table></figure>
<p>反转两次后的得到{3,4,0,1,2}<br>如何反转最快？<br>长度为n的数组翻转k次<br>把原数组分为a[0]~a[n-1-k]和a[n-k]到a[n-1]两个部分<br>再把整个数组翻转得到a[n-1] a[n-2] a[n-3]…a[2] a[1] a[0]<br>再分别反转两个部分 得到 a[n-k] a[n-k+1]…a[n-1] a[0] a[1]…a[n-1-k]<br>reverse函数在algorithm头文件里面，reverse(a,b)是翻转从a到b的数    </p>
<h2 id="7-4浮点数的比较"><a href="#7-4浮点数的比较" class="headerlink" title="7.4浮点数的比较"></a>7.4浮点数的比较</h2><p>浮点数的存储不是精确的，一般认为x和y相差小于1e-6则相等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const double eps = 1e-6</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    double x=1.23456789;</span><br><span class="line">    double a=x*x;</span><br><span class="line">    double b=sqrt(a);</span><br><span class="line">    if (fabs(x-b)&lt;eps) puts(&quot;相等&quot;);//fabs是取绝对值的函数</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-5求2的n次方存在数组中"><a href="#7-5求2的n次方存在数组中" class="headerlink" title="7.5求2的n次方存在数组中"></a>7.5求2的n次方存在数组中</h2><p>比如把一个数 1234567891234 存进数组中，一般把从低往高存，这样方便加减乘运算时的进位运算<br>所以实际上应该是对应a[12]…a[4]a[3]a[2]a[1]a[0]<br>假如A[]={4,3,2,1,9,8,7,6,5,4,3,2,1}<br>数组可以很方便的进行大数据的加减乘<br>比如1234567891234<em>2的操作<br>可以对每一位分别</em>2,用一个新数组B[]来存储结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B[0]=A[0]*2%10;</span><br></pre></td></tr></table></figure>
<p>用一个变量t来存储进位 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t=A[0]*2/10；</span><br></pre></td></tr></table></figure>
<p>则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B[1]=(A[1]*2%+t)%10;</span><br><span class="line">   t=(B[1]*2+t)/10;</span><br></pre></td></tr></table></figure>
<p>直到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B[n-1]=(A[n-1]*2%+t)%10;</span><br><span class="line">   t=(B[n-1]*2+t)/10;</span><br></pre></td></tr></table></figure>
<p>最后还有可能会进位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B[n]=t;</span><br></pre></td></tr></table></figure>

<h2 id="7-4-高精度2的N次幂"><a href="#7-4-高精度2的N次幂" class="headerlink" title="7.4 高精度2的N次幂"></a>7.4 高精度2的N次幂</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N =3010</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo,Next主题优化</title>
    <url>/2022/01/26/Hexo-Next%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="设置hexo首页只显示部分摘要（不显示全文）"><a href="#设置hexo首页只显示部分摘要（不显示全文）" class="headerlink" title="设置hexo首页只显示部分摘要（不显示全文）"></a>设置hexo首页只显示部分摘要（不显示全文）</h1><blockquote>
<p>摘自<a href="https://blog.csdn.net/yueyue200830/article/details/104470646?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164319697016780271536156%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164319697016780271536156&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-104470646.first_rank_v2_pc_rank_v29&amp;utm_term=hexo%E9%A6%96%E9%A1%B5%E4%B8%8D%E6%98%BE%E7%A4%BA%E6%96%B0%E6%96%87%E7%AB%A0&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/yueyue200830/article/details/104470646?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164319697016780271536156%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164319697016780271536156&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-104470646.first_rank_v2_pc_rank_v29&amp;utm_term=hexo%E9%A6%96%E9%A1%B5%E4%B8%8D%E6%98%BE%E7%A4%BA%E6%96%B0%E6%96%87%E7%AB%A0&amp;spm=1018.2226.3001.4187</a></p>
</blockquote>
<p>本文针对Next主题，不确保对于其它主题有效（但从修改模式来看，是有效的）<br>Next默认是会显示全文的，这样显然很不方便，因此需要一些方法去只显示前面一部分</p>
<h1 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h1><p>首先需要在Next主题的_config.yml中把设置打开：(默认安装时就打开了)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Automatically excerpt description in homepage as preamble text.</span><br><span class="line">excerpt_description: true</span><br></pre></td></tr></table></figure>
<h1 id="Two-methods"><a href="#Two-methods" class="headerlink" title="Two methods"></a>Two methods</h1><h2 id="方法一：写概述"><a href="#方法一：写概述" class="headerlink" title="方法一：写概述"></a>方法一：写概述</h2><p>在文章的front-matter中添加description，其中description中的内容就会被显示在首页上，其余一律不显示。<br>exp:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 让首页显示部分内容</span><br><span class="line">date: 2020-02-23 22:55:10</span><br><span class="line">description: 这是显示在首页的概述，正文内容均会被隐藏。</span><br></pre></td></tr></table></figure>
<p>测试成功</p>
<h2 id="方法二：文章截断"><a href="#方法二：文章截断" class="headerlink" title="方法二：文章截断"></a>方法二：文章截断</h2><p>在需要截断的地方加入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>
<p>首页就会显示这条以上的所有内容，隐藏接下来的所有内容。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown语法</title>
    <url>/2022/01/25/Markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a><strong>标题</strong></h1><p>有几级标题用几个#</p>
<h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a><strong>字体</strong></h1><h2 id="加粗-要加粗的文字左右分别用两个-号包起来"><a href="#加粗-要加粗的文字左右分别用两个-号包起来" class="headerlink" title="加粗 要加粗的文字左右分别用两个*号包起来"></a>加粗 要加粗的文字左右分别用两个*号包起来</h2><p>未加粗 <strong>加粗</strong> </p>
<h2 id="斜体-要倾斜和加粗的文字左右分别用三个-号包起来"><a href="#斜体-要倾斜和加粗的文字左右分别用三个-号包起来" class="headerlink" title="斜体 要倾斜和加粗的文字左右分别用三个*号包起来"></a>斜体 要倾斜和加粗的文字左右分别用三个*号包起来</h2><p>非斜体  <em>斜体</em></p>
<h2 id="套娃"><a href="#套娃" class="headerlink" title="套娃"></a>套娃</h2><p>三个*号连用就是斜体加粗了 <em><strong>斜体加粗</strong></em></p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>要应用的话前面加个&gt;符号，引用完了空一行<br>Test</p>
<blockquote>
<p>搞咩啊？</p>
</blockquote>
<p>测试成功。但是感觉这个功能有点多余，毕竟我是尊贵的白嫖党，拿来主义</p>
<h1 id="插入代码段"><a href="#插入代码段" class="headerlink" title="插入代码段"></a><strong>插入代码段</strong></h1><p>How to insert a code segement?<br>在Markdown中添加代码只需要在代码的前边一行与后边一行分别添加````，并且在前边一行添加语言标识的关键字。(键盘左上角，ESC下面那个键~)<br>Test:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Printf(&quot;Hello World!&quot;)</span><br></pre></td></tr></table></figure>
<p>测试成功</p>
<h1 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h1><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。</p>
<p>语法格式如下：</p>
<h2 id="极简模式"><a href="#极简模式" class="headerlink" title="极简模式"></a>极简模式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">水果名称| 价格 |  数量  </span><br><span class="line">-|-|-</span><br><span class="line">香蕉 | $1 | 5 |</span><br><span class="line">苹果 | $1 | 6 |</span><br><span class="line">草莓 | $1 | 7 |</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<table>
<thead>
<tr>
<th>水果名称</th>
<th>价格</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>香蕉</td>
<td>$1</td>
<td>5</td>
</tr>
<tr>
<td>苹果</td>
<td>$1</td>
<td>6</td>
</tr>
<tr>
<td>草莓</td>
<td>$1</td>
<td>7</td>
</tr>
</tbody></table>
<h2 id="加上对齐方式"><a href="#加上对齐方式" class="headerlink" title="加上对齐方式"></a>加上对齐方式</h2><p>我们可以设置表格的对齐方式：</p>
<p>-: 设置内容和标题栏居右对齐。<br>:- 设置内容和标题栏居左对齐。<br>:-: 设置内容和标题栏居中对齐。<br>注意前后得有空格<br>测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name | 111 | 222 | 333 | 444</span><br><span class="line">- | :-: | :-: | :-: | -:</span><br><span class="line">aaa | bbb | ccc | ddd | eee| </span><br><span class="line">fff | ggg| hhh | iii | 000|</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<table>
<thead>
<tr>
<th>name</th>
<th align="center">111</th>
<th align="center">222</th>
<th align="center">333</th>
<th align="right">444</th>
</tr>
</thead>
<tbody><tr>
<td>aaa</td>
<td align="center">bbb</td>
<td align="center">ccc</td>
<td align="center">ddd</td>
<td align="right">eee</td>
</tr>
<tr>
<td>fff</td>
<td align="center">ggg</td>
<td align="center">hhh</td>
<td align="center">iii</td>
<td align="right">000</td>
</tr>
</tbody></table>
<p>注意：表格前后一定要空一行<br>测试结果失败；发现还是不能居中居右；暂未解决</p>
<h2 id="表格中如果需要出现-符号怎么办"><a href="#表格中如果需要出现-符号怎么办" class="headerlink" title="表格中如果需要出现|符号怎么办"></a>表格中如果需要出现|符号怎么办</h2><p>在|符号前加一个转义符\</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|test|test|</span><br><span class="line">|-|-|</span><br><span class="line">|\||\||</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<table>
<thead>
<tr>
<th>test</th>
<th>test</th>
</tr>
</thead>
<tbody><tr>
<td>|</td>
<td>|</td>
</tr>
</tbody></table>
<h1 id="更换字体颜色"><a href="#更换字体颜色" class="headerlink" title="更换字体颜色"></a>更换字体颜色</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;font color=blue&gt;此处为文本内容&lt;/font&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32学习</title>
    <url>/2022/04/19/STM32%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="开发板资源"><a href="#开发板资源" class="headerlink" title="开发板资源"></a>开发板资源</h1><p>◆ CPU：STM32F103ZET6，LQFP144，FLASH：512K，SRAM：64K； ◆ 外扩 SPI FLASH：W25Q128，16M 字节<br>◆ 1 个电源指示灯（蓝色）<br>◆ 2 个状态指示灯（DS0：红色，DS1：绿色）<br>◆ 1 个红外接收头，并配备一款小巧的红外遥控器<br>◆ 1 个 EEPROM 芯片，24C02，容量 256 字节<br>◆ 1 个光敏传感器<br>◆ 1 个无线模块接口（可接 NRF24L01/RFID 模块等）<br>◆ 1 路 CAN 接口，采用 TJA1050 芯片<br>◆ 1 路 485 接口，采用 SP3485 芯片<br>◆ 1 路数字温湿度传感器接口，支持 DS18B20 /DHT11 等 ◆ 1 个 ATK 模块接口，支持 ALIENTEK 蓝牙/GPS   模块/MPU6050 模块等<br>◆ 1 个标准的 2.4/2.8/3.5/4.3/7 寸 LCD 接口，支持触摸屏<br>◆ 1 个摄像头模块接口<br>◆ 1 个 OLED 模块接口（与摄像头接口共用）<br>◆ 1 个 USB 串口，可用于程序下载和代码调试（USMART 调试）<br>◆ 1 个 USB SLAVE 接口，用于 USB 通信<br>◆ 1 个有源蜂鸣器<br>◆ 1 个 RS485 选择接口<br>◆ 1 个 CAN/USB 选择接口<br>◆ 1 个串口选择接口<br>◆ 1 个 SD 卡接口（在板子背面，SDIO 接口）<br>◆ 1 个标准的 JTAG/SWD 调试下载口<br>◆ 1 组 AD/DA 组合接口（DAC/ADC/ TPAD） ◆ 1 组 5V 电源供应/接入口<br>◆ 1 组 3.3V 电源供应/接入口<br>◆ 1 个直流电源输入接口（输入电压范围：6~24V） ◆ 1 个启动模式选择配置接口<br>◆ 1 个 RTC 后备电池座，并带电池<br>◆ 1 个复位按钮，可用于复位 MCU 和 LCD<br>◆ 3 个功能按钮，其中 KEY_UP 兼具唤醒功能<br>◆ 1 个电容触摸按键<br>◆ 1 个电源开关，控制整个板的电源<br>◆ 独创的一键下载功能<br>◆ 除晶振占用的 IO 口外，其余所有 IO 口全部引出</p>
<h2 id="1-WIRELESS-模块接口"><a href="#1-WIRELESS-模块接口" class="headerlink" title="1. WIRELESS 模块接口"></a>1. WIRELESS 模块接口</h2><pre><code>这是开发板板载的无线模块接口（U2），可以外接 NRF24L01/RFID 等无线模块。从而实现
</code></pre>
<p>无线通信等功能。注意：接 NRF24L01 模块进行无线通信的时候，必须同时有 2 个模块和 2 个<br>板子，才可以测试，单个模块/板子例程是不能测试的。</p>
<h2 id="2-W25Q128-128Mbit-FLASH"><a href="#2-W25Q128-128Mbit-FLASH" class="headerlink" title="2. W25Q128 128Mbit FLASH"></a>2. W25Q128 128Mbit FLASH</h2><pre><code>这是开发板外扩的 SPI FLASH 芯片（U8），容量为 128Mbit，也就是 16M 字节，可用于存
</code></pre>
<p>储字库和其他用户数据，满足大容量数据存储要求。当然如果觉得 16M 字节还不够用，你可以<br>把数据存放在外部 SD 卡。</p>
<h2 id="3-SD卡接口"><a href="#3-SD卡接口" class="headerlink" title="3. SD卡接口"></a>3. SD卡接口</h2><pre><code>这是开发板板载的一个标准 SD 卡接口（SD_CARD），该接口在开发板的背面，采用大 SD
</code></pre>
<p>卡接口（即相机卡，也可以是 TF 卡+卡套的形式），SDIO 方式驱动，有了这个 SD 卡接口，就<br>可以满足海量数据存储的需求。</p>
<h2 id="4-CAN-USB-选择口"><a href="#4-CAN-USB-选择口" class="headerlink" title="4. CAN/USB 选择口"></a>4. CAN/USB 选择口</h2><pre><code>这是一个 CAN/USB 的选择接口（P6），因为 STM32 的 USB 和 CAN 是共用一组 IO（PA11
</code></pre>
<p>和 PA12），所以我们通过跳线帽来选择不同的功能，以实现 USB/CAN 的实验。</p>
<h2 id="5-USB-串口-串口-1"><a href="#5-USB-串口-串口-1" class="headerlink" title="5.USB 串口/串口 1"></a>5.USB 串口/串口 1</h2><pre><code>这是 USB 串口同 STM32F103ZET6 的串口 1 进行连接的接口（P3），标号 RXD 和 TXD 是
</code></pre>
<p>USB 转串口的 2 个数据口（对 CH340G 来说），而 PA9(TXD)和 PA10(RXD)则是 STM32 的串口<br>1 的两个数据口（复用功能下）。他们通过跳线帽对接，就可以和连接在一起了，从而实现 STM32<br>的程序下载以及串口通信。<br>设计成 USB 串口，是出于现在电脑上串口正在消失，尤其是笔记本，几乎清一色的没有串<br>口。所以板载了 USB 串口可以方便大家下载代码和调试。而在板子上并没有直接连接在一起，<br>则是出于使用方便的考虑。这样设计，你可以把 ALIENTEK 精英 STM32F103 当成一个 USB<br>转 TTL 串口，来和其他板子通信，而其他板子的串口，也可以方便地接到 ALIENTEK 精英<br>STM32F103 开发板上。</p>
<h2 id="6-JTAG-SWD-接口"><a href="#6-JTAG-SWD-接口" class="headerlink" title="6. JTAG/SWD 接口"></a>6. JTAG/SWD 接口</h2><pre><code>这是 ALIENTEK 精英 STM32F103 板载的 20 针标准 JTAG 调试口（JTAG），该 JTAG 口直
</code></pre>
<p>接可以和 ULINK、JLINK 或者 STLINK 等调试器（仿真器）连接，同时由于 STM32 支持 SWD<br>调试，这个 JTAG 口也可以用 SWD 模式来连接。<br>    用标准的 JTAG 调试，需要占用 5 个 IO 口，有些时候，可能造成 IO 口不够用，而用 SWD<br>则只需要 2 个 IO 口，大大节约了 IO 数量，但他们达到的效果是一样的，所以我们强烈建议仿<br>真器使用 SWD 模式！</p>
<h2 id="7-24C02-EEPROM"><a href="#7-24C02-EEPROM" class="headerlink" title="7. 24C02 EEPROM"></a>7. 24C02 EEPROM</h2><pre><code>这是开发板板载的 EEPROM 芯片（U9），容量为 2Kb，也就是 256 字节。用于存储一些掉
</code></pre>
<p>电不能丢失的重要数据，比如系统设置的一些参数/触摸屏校准数据等。有了这个就可以方便的<br>实现掉电数据保存。</p>
<h2 id="8-USB-SLAVE"><a href="#8-USB-SLAVE" class="headerlink" title="8. USB SLAVE"></a>8. USB SLAVE</h2><pre><code>这是开发板板载的一个 MiniUSB 头（USB_SLAVE），用于 USB 从机（SLAVE）通信，一
</code></pre>
<p>般用于 STM32 与电脑的 USB 通信。通过此 MiniUSB 头，开发板就可以和电脑进行 USB 通信<br>了。<br>    开发板总共板载了 2 个 MiniUSB 头，一个（USB_232）用于 USB 转串口，连接 CH340G<br>芯片；另外一个（USB_SLAVE）用于 STM32 内带的 USB。同时开发板可以通过此 MiniUSB<br>头供电，板载两个 MiniUSB 头（不共用），主要是考虑了使用的方便性，以及可以给板子提供<br>更大的电流（两个 USB 都接上）这两个因素。</p>
<h2 id="9-USB-转串口"><a href="#9-USB-转串口" class="headerlink" title="9. USB 转串口"></a>9. USB 转串口</h2><pre><code>这是开发板板载的另外一个 MiniUSB 头（USB_232），用于 USB 连接 CH340G 芯片，从而
</code></pre>
<p>实现 USB 转 TTL 串口。同时，此 MiniUSB 接头也是开发板电源的主要提供口。</p>
<h2 id="10-后备电池接口"><a href="#10-后备电池接口" class="headerlink" title="10. 后备电池接口"></a>10. 后备电池接口</h2><pre><code>这是 STM32 后备区域的供电接口(BAT)，可安装 CR1220 电池（默认安装了），可以用来给
</code></pre>
<p>STM32 的后备区域提供能量，在外部电源断电的时候，维持后备区域数据的存储，以及 RTC<br>的运行。</p>
<h2 id="11-OLED-摄像头模块接口"><a href="#11-OLED-摄像头模块接口" class="headerlink" title="11. OLED/摄像头模块接口"></a>11. OLED/摄像头模块接口</h2><pre><code>这是开发板板载的一个 OLED/摄像头模块接口（P4），如果是 OLED 模块，靠左插即可（右
</code></pre>
<p>边两个孔位悬空）。如果是摄像头模块（ALIENTEK 提供），则刚好插满。通过这个接口，可以<br>分别连接 2 种外部模块，从而实现相关实验。</p>
<h2 id="12-有源蜂鸣器"><a href="#12-有源蜂鸣器" class="headerlink" title="12. 有源蜂鸣器"></a>12. 有源蜂鸣器</h2><pre><code>这是开发板的板载蜂鸣器（BEEP），可以实现简单的报警/闹铃等功能。
</code></pre>
<h2 id="13-红外接收器"><a href="#13-红外接收器" class="headerlink" title="13. 红外接收器"></a>13. 红外接收器</h2><pre><code>这是开发板的红外接收头（U6），可以实现红外遥控功能，通过这个接收头，可以接受市
</code></pre>
<p>面常见的各种遥控器的红外信号，大家甚至可以自己实现万能红外解码。当然，如果应用得当，<br>该接收头也可以用来传输数据。</p>
<h2 id="14-DS18B20-DHT11-接口"><a href="#14-DS18B20-DHT11-接口" class="headerlink" title="14. DS18B20/DHT11 接口"></a>14. DS18B20/DHT11 接口</h2><pre><code>这是开发板的一个复用接口（U4），该接口由 4 个镀金排孔组成，可以用来接
</code></pre>
<p>DS18B20/DS1820 等数字温度传感器。也可以用来接 DHT11 这样的数字温湿度传感器。实现一<br>个接口，2 个功能。不用的时候，大家可以拆下上面的传感器，放到其他地方去用，使用上是<br>十分方便灵活的。</p>
<h2 id="15-2-个-LED"><a href="#15-2-个-LED" class="headerlink" title="15. 2 个 LED"></a>15. 2 个 LED</h2><pre><code>这是开发板板载的两个 LED 灯（DS0 和 DS1），DS0 是红色的，DS1 是绿色的，主要是方
</code></pre>
<p>便大家识别。这里提醒大家不要停留在 51 跑马灯的思维，搞这么多灯，除了浪费 IO 口，实在<br>是想不出其他什么优点。<br>我们一般的应用 2 个 LED 足够了，在调试代码的时候，使用 LED 来指示程序状态，是非<br>常不错的一个辅助调试方法。精英 STM32F103 几乎每个实例都使用了 LED 来指示程序的运行<br>状态。</p>
<h2 id="16-启动选择端口"><a href="#16-启动选择端口" class="headerlink" title="16. 启动选择端口"></a>16. 启动选择端口</h2><pre><code>这是开发板板载的启动模式选择端口（BOOT），STM32 有 BOOT0（B0）和 BOOT1（B1）
</code></pre>
<p>两个启动选择引脚，用于选择复位后 STM32 的启动模式，作为开发板，这两个是必须的。在<br>开发板上，我们通过跳线帽选择 STM32 的启动模式。</p>
<h2 id="17-触摸按钮"><a href="#17-触摸按钮" class="headerlink" title="17. 触摸按钮"></a>17. 触摸按钮</h2><pre><code>这是开发板板载的一个电容触摸输入按键（TPAD），利用电容充放电原理，实现触摸按键
</code></pre>
<p>检测。</p>
<h2 id="18-电源指示灯"><a href="#18-电源指示灯" class="headerlink" title="18. 电源指示灯"></a>18. 电源指示灯</h2><pre><code>这是开发板板载的一颗蓝色的 LED 灯（PWR），用于指示电源状态。在电源开启的时候（通
</code></pre>
<p>过板上的电源开关控制），该灯会亮，否则不亮。通过这个 LED，可以判断开发板的上电情况。</p>
<h2 id="19-复位按钮"><a href="#19-复位按钮" class="headerlink" title="19. 复位按钮"></a>19. 复位按钮</h2><pre><code>这是开发板板载的复位按键（RESET），用于复位 STM32，还具有复位液晶的功能，因为
</code></pre>
<p>液晶模块的复位引脚和 STM32 的复位引脚是连接在一起的，当按下该键的时候，STM32 和液<br>晶一并被复位。</p>
<h2 id="20-3个按键"><a href="#20-3个按键" class="headerlink" title="20. 3个按键"></a>20. 3个按键</h2><pre><code>这是开发板板载的 3 个机械式输入按键（KEY0、KEY1 和 KEY_UP），其中 KEY_UP 具有
</code></pre>
<p>唤醒功能，该按键连接到 STM32 的 WAKE_UP（PA0）引脚，可用于待机模式下的唤醒，在不<br>使用唤醒功能的时候，也可以做为普通按键输入使用。<br>    其他 2 个是普通按键，可以用于人机交互的输入，这 2 个按键是直接连接在 STM32 的 IO<br>口上的。这里注意 KEY_UP 是高电平有效，而 KEY0 和 KEY1 是低电平有效，大家在使用的时<br>候留意一下。</p>
<h2 id="21-STM32F103ZET6"><a href="#21-STM32F103ZET6" class="headerlink" title="21. STM32F103ZET6"></a>21. STM32F103ZET6</h2><pre><code>这是开发板的核心芯片（U1），型号为：STM32F103ZET6。该芯片具有 64KB SRAM、512KB 
</code></pre>
<p>FLASH、2 个基本定时器、4 个通用定时器、2 个高级定时器、2 个 DMA 控制器（共 12 个通道）、3 个 SPI、2 个 IIC、5 个串口、1 个 USB、1 个 CAN、3 个 12 位 ADC、1 个 12 位 DAC、1 个SDIO 接口、1 个 FSMC 接口以及 112 个通用 IO 口。</p>
<h2 id="22-AD-DA-组合接口"><a href="#22-AD-DA-组合接口" class="headerlink" title="22. AD/DA 组合接口"></a>22. AD/DA 组合接口</h2><pre><code>这是 1 个由 4 个排针组成的一个组合接口（P7）。可以实现 AD 采集、DA 输出和板载电容
</code></pre>
<p>触摸按键（TPAD）检测的功能。</p>
<h2 id="23-ATK-模块接口"><a href="#23-ATK-模块接口" class="headerlink" title="23. ATK 模块接口"></a>23. ATK 模块接口</h2><pre><code>这是开发板板载的一个 ALIENTEK 通用模块接口（U3），目前可以支持 ALIENTEK 开发
</code></pre>
<p>的 GPS 模块、蓝牙模块和 MPU6050 模块等，直接插上对应的模块，就可以进行开发。后续我<br>们将开发更多兼容该接口的其他模块，实现更强大的扩展性能。</p>
<h2 id="24-3-3V-电源输入-输出"><a href="#24-3-3V-电源输入-输出" class="headerlink" title="24. 3.3V 电源输入/输出"></a>24. 3.3V 电源输入/输出</h2><pre><code>这是开发板板载的一组 3.3V 电源输入输出排针（2*3）（VOUT1），用于给外部提供 3.3V
</code></pre>
<p>的电源，也可以用于从外部接 3.3V 的电源给板子供电。<br>    大家在实验的时候可能经常会为没有 3.3V 电源而苦恼不已，有了 ALIENTEK 精英<br>STM32F103，你就可以很方便的拥有一个简单的 3.3V 电源（USB 供电的时候，最大电流不能<br>超过 500mA，外部供电的时候，最大可达 1000mA）</p>
<h2 id="25-5V-电源输入-输出"><a href="#25-5V-电源输入-输出" class="headerlink" title="25. 5V 电源输入/输出"></a>25. 5V 电源输入/输出</h2><pre><code>这是开发板板载的一组 5V 电源输入输出排针（2*3）（VOUT2），该排针用于给外部提供
</code></pre>
<p>5V 的电源，也可以用于从外部接 5V 的电源给板子供电。<br>    同样大家在实验的时候可能经常会为没有 5V 电源而苦恼不已，ALIENTEK 充分考虑到了<br>大家需求，有了这组 5V 排针，你就可以很方便的拥有一个简单的 5V 电源（USB 供电的时候，<br>最大电流不能超过 500mA，外部供电的时候，最大可达 1000mA）。</p>
<h2 id="26-电源开关"><a href="#26-电源开关" class="headerlink" title="26. 电源开关"></a>26. 电源开关</h2><pre><code>这是开发板板载的电源开关（K1）。该开关用于控制整个开发板的供电，如果切断，则整
</code></pre>
<p>个开发板都将断电，电源指示灯（PWR）会随着此开关的状态而亮灭。</p>
<h2 id="27-DC6-24V-电源输入"><a href="#27-DC6-24V-电源输入" class="headerlink" title="27. DC6~24V 电源输入"></a>27. DC6~24V 电源输入</h2><pre><code>这是开发板板载的一个外部电源输入口（DC_IN），采用标准的直流电源插座。开发板板载
</code></pre>
<p>了 DC-DC 芯片（MP2359），用于给开发板提供高效、稳定的 5V 电源。由于采用了 DC-DC 芯<br>片，所以开发板的供电范围十分宽，大家可以很方便的找到合适的电源（只要输出范围在<br>DC 6~24V的基本都可以）来给开发板供电。在耗电比较大的情况下，比如用到 4.3 屏/7 寸屏的<br>时候，建议使用外部电源供电，可以提供足够的电流给开发板使用.</p>
<h2 id="28-RS485-选择接口"><a href="#28-RS485-选择接口" class="headerlink" title="28. RS485 选择接口"></a>28. RS485 选择接口</h2><pre><code>这是开发板板载的 RS485 选择接口（P5），MAX3485 通过这个接口来决定是否连接到
</code></pre>
<p>STM32 的串口 2（USART2），当这里断开的时候：串口 2 可以用来做普通串口使用，而 RS485<br>则可以用来实现 RS485 转 TTL 的功能；当这里接上时：串口 2 连接 MAX3485，就可以实现<br>RS485 通信。  </p>
<h2 id="29-引出-IO-口（共-2-组）"><a href="#29-引出-IO-口（共-2-组）" class="headerlink" title="29. 引出 IO 口（共 2 组）"></a>29. 引出 IO 口（共 2 组）</h2><pre><code>这是开发板 IO 引出端口，总共有 2 组主 IO 引出口：P1 和 P2。它们采用 2*27 排针引出，
</code></pre>
<p>总共引出 106 个 IO 口。而 STM32F103ZET6 总共只有 112 个 IO，除去 RTC 晶振占用的 2 个 IO<br>，还剩下 110 个，这 2 组排针，总共引出 106 个 IO，剩下的 4 个 IO 分别通过：P3 和 P5 引出。</p>
<h2 id="30-LCD-接口"><a href="#30-LCD-接口" class="headerlink" title="30. LCD 接口"></a>30. LCD 接口</h2><pre><code>这是开发板板载的 LCD 模块接口，该接口兼容 ALIENTEK 全系列 TFTLCD 模块，包括：
</code></pre>
<p>2.4 寸、2.8 寸、3.5 寸、4.3 寸和 7 寸等 TFTLCD 模块，并且支持电阻/电容触摸功能。</p>
<h2 id="31-光敏传感器"><a href="#31-光敏传感器" class="headerlink" title="31. 光敏传感器"></a>31. 光敏传感器</h2><pre><code>这是开发板板载的一个光敏传感器（LS1），通过该传感器，开发板可以感知周围环境光线
</code></pre>
<p>的变化，从而可以实现类似自动背光控制的应用。</p>
<h2 id="32-RS485-接口"><a href="#32-RS485-接口" class="headerlink" title="32. RS485 接口"></a>32. RS485 接口</h2><pre><code>这是开发板板载的 RS485 总线接口（RS485），通过 2 个端口和外部 485 设备连接。这里提
</code></pre>
<p>醒大家，RS485 通信的时候，必须 A 接 A，B 接 B。否则可能通信不正常！另外，开发板自带<br>了终端电阻（120Ω）。</p>
<h2 id="33-CAN-接口"><a href="#33-CAN-接口" class="headerlink" title="33. CAN 接口"></a>33. CAN 接口</h2><pre><code>这是开发板板载的 CAN 总线接口（CAN），通过 2 个端口和外部 CAN 总线连接，即 CANH
</code></pre>
<p>和 CANL。这里提醒大家：CAN 通信的时候，必须 CANH 接 CANH，CANL 接 CANL，否则<br>可能通信不正常！</p>
<h1 id="STM32-初探"><a href="#STM32-初探" class="headerlink" title="STM32 初探"></a>STM32 初探</h1><h2 id="1-为什么选择STM32"><a href="#1-为什么选择STM32" class="headerlink" title="1. 为什么选择STM32"></a>1. 为什么选择STM32</h2><pre><code>·STM32 是基于ARM内核的32位的 Cortex-M内核
·具有标准的ARM框架
·好性能、低功耗、低电压、创新的内核及外设
·简单易用、低风险

Cortex-M3内核属于ARMv7架构
ARMv7架构定义了三大分工明确的系列:
&quot;A&quot;系列：面向尖端的基于虚拟内存的操作系统和用户应用
&quot;R&quot;系列：针对实时系统
&quot;M”系列：对微控制器

STM32F1属于Cortex-M系列中的Cortex-M3内核，采用ARMv7-M架构。
STM32F4属于Cortex-M4系列采用ARMv7-ME架构。 
Cortex-A5/A8采用ARMv7-A架构。
传统的ARM7系列采用的是ARMv4T架构。

详细对比见PPT的表格

总之Cortex-M3比ARM7好多了
</code></pre>
<h2 id="3-M3系列的优点"><a href="#3-M3系列的优点" class="headerlink" title="3. M3系列的优点"></a>3. M3系列的优点</h2><pre><code>1. 高性能Cortex-M内核
 采用ARM公司流行的标准内核Cortex-M3
 低动态功耗上实现的高性能
 哈佛结构上实现1.25DMIPS/MHZ，功耗只有0.19mv/MHZ，比ARM7TDMI改进了30%
 单周期的乘法和硬件除法
 不可分的位操作，实现对RAM，I/O和寄存器的最优访问。

2. 最佳的代码密度
 Thumb-2指令集以16位指令的密度实现32位指令性能（与ARM7TDMI的ARM模式比减少了30%-45%的代码量）

3. 可预见的运行时间
 中断控制器嵌在内核之中，中断之间的间隔最少可达6个CPU周期。 
 从低功耗模式唤醒只需6个CPU周期

4.改进的调试功能
 串行单步调试和JTAG调试
</code></pre>
<h2 id="2-STM32的命名规则"><a href="#2-STM32的命名规则" class="headerlink" title="2. STM32的命名规则"></a>2. STM32的命名规则</h2><pre><code>见PPT
</code></pre>
<h2 id="3-STM32的优势总结"><a href="#3-STM32的优势总结" class="headerlink" title="3. STM32的优势总结"></a>3. STM32的优势总结</h2><pre><code>1）极高的性能： 主流的Cortex内核。
2）丰富合理的外设，合理的功耗，合理的价格。
3）强大的软件支持：丰富的软件包。
4）全面丰富的技术文档。
5）芯片型号种类多，覆盖面广。
6）强大的用户基础：最先成功试水CM3芯片的公司，积累了大批的用户群体，为其领先做铺垫。
</code></pre>
<h1 id="STM32-芯片解读"><a href="#STM32-芯片解读" class="headerlink" title="STM32 芯片解读"></a>STM32 芯片解读</h1><pre><code>STM32F1数据手册：STM32F103ZET6.pdf
STM32F1中文手册：STM32F1xx中文参考手册.pdf
开发板原理图：XXX STM32F1_Vxx_SCH.pdf
</code></pre>
<h2 id="1-芯片有哪些资源？"><a href="#1-芯片有哪些资源？" class="headerlink" title="1.芯片有哪些资源？"></a>1.芯片有哪些资源？</h2><pre><code>STM32F103ZET6
内核：
 32位 高性能ARM Cortex-M3处理器
 时钟：高达72M,实际还可以超频一点点
 单周期乘法和硬件除法

IO口：
 STM32F103ZET6: 144引脚  112个IO（16×7可以分为7组，PA~PG）
 大部分IO口都耐5V(模拟通道除外)
 支持调试：SWD和JTAG，SWD只要2根数据线

存储器容量：
 STM32F103ZET6:  512K FLASH，64K SRAM

时钟，复位和电源管理：
 ①：2.0~3.6V电源和IO电压（一般用3.3V）
 ②：上电复位，掉电复位和可编程的电压监控
 ③：强大的时钟系统：
   4~16M的外部高速晶振(一般用8M)
   内部8MHz的高速RC振荡器
   内部40KHz低速RC振荡器，看门狗时钟
   内部锁相环（PLL，倍频），一般系统时钟都是外部或者内部高速时钟经过PLL倍频后得到（8M不够就倍频）
   外部低速32.768K的晶振，主要做RTC时钟源

低功耗：
 睡眠，停止和待机三种低功耗模式
 可用电池为RTC和备份寄存器供电

AD:
 3个12位AD【多达21个外部测量通道】
 转换范围：0~3.6(电源电压）（一般用3.3V）
 内部通道可以用于内部温度测量
 内置参考电压  

DA:
 2个12位DA

DMA（直接存储器访问）：
 12个DMA通道（7+5=12; 7通道DMA1,5通道DMA2)支持外设：定时器，ADC,DAC，SDIO,I2S,SPI,I2C,和USART

定时器（11个）：
 4个通用定时器
 2个基本定时器
 2个高级定时器
 1个系统定时器
 2个看门狗定时器

通信接口（13个）：
 2个I2C接口
 5个串口
 3个SPI接口
 1个CAN2.0
 1个USB FS
 1个SDIO
</code></pre>
<h2 id="2-芯片的内部结构"><a href="#2-芯片的内部结构" class="headerlink" title="2. 芯片的内部结构"></a>2. 芯片的内部结构</h2><pre><code>看PPT
</code></pre>
<h2 id="3-STM32的最小系统"><a href="#3-STM32的最小系统" class="headerlink" title="3. STM32的最小系统"></a>3. STM32的最小系统</h2><pre><code> 供电（VDD VSS VDDA VSSA都是3.3V VDDA和VSSA都是模拟的，对纹波的处理要求较高）
 复位（一般是一个按键一个电容，按键没按的时候通过上拉电阻，保持高电压3.3V，有按键按下的时候接地变为0V，可以通过电容充电）
 时钟：外部晶振（2个）（有两个晶振；一个是外部高速晶振，另一个是低速晶振）
 Boot启动模式选择 （BOOT1和BOOT2两个引脚通过一个段子连接在一起，跳线帽，通过一键下载电路可以跳过这个步骤）
 下载电路（串口（串口1,通过PA9和PA10接到USB转232的口再下载）/JTAG/SWD)
 后备电池

 其他地方还有一些滤波电容，一般选104
</code></pre>
<h1 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h1><h2 id="MDK安装"><a href="#MDK安装" class="headerlink" title="MDK安装"></a>MDK安装</h2><pre><code>MDK是什么？
RealView MDK是Keil公司开发的，为基于Cortex 、ARM7、ARM9等处理器设备提供的一个完整的开发环境。
参考资料：
ALIENTEK xxSTM32开发板入门资料\MDK5安装手册.pdf
</code></pre>
<h2 id="USB串口作用："><a href="#USB串口作用：" class="headerlink" title="USB串口作用："></a>USB串口作用：</h2><pre><code>（1）可以当串口使用。
（2）如果USB串口连接到STM32的串口1(STM32ISP下载只能是串口1)的话，那么可以用来串口下载程序。
（3）因为要连接到USB，所以可以用来USB供电。
</code></pre>
<h2 id="USB串口驱动安装"><a href="#USB串口驱动安装" class="headerlink" title="USB串口驱动安装"></a>USB串口驱动安装</h2><pre><code>USB串口驱动芯片型号：CH340
串口下载工具：mcuisp(FlyMcu)
</code></pre>
<h2 id="STM32的ISP下载"><a href="#STM32的ISP下载" class="headerlink" title="STM32的ISP下载"></a>STM32的ISP下载</h2><pre><code>只能使用串口1，也就是对应串口发送接收引脚PA9,PA10。不能使用其他串口（例如串口2：PA2,PA3)用来ISP下载。
</code></pre>
<h1 id="GPIO基本原理与寄存器配置"><a href="#GPIO基本原理与寄存器配置" class="headerlink" title="GPIO基本原理与寄存器配置"></a>GPIO基本原理与寄存器配置</h1><h2 id="GPIO基本结构和工作方式"><a href="#GPIO基本结构和工作方式" class="headerlink" title="GPIO基本结构和工作方式"></a>GPIO基本结构和工作方式</h2><pre><code>STM32F103ZET6
- 一共有7组IO口
- 每组IO口有16个IO
- 一共16X7=112个IO
- 分别是GPIOA GPIOB GPIOC GPIOD GPIOE GPIOF GPIOG
- GPIOA有 PA0 PA1 PA2 PA3 PA4 PA5 PA6 PA7 PA8 PA9 PA10 PA11 PA12 PA13 PA14 PA15

STM32的大部分引脚除了当GPIO使用外，还可以复用为外设功能引脚（比如串口）。

GPIO的工作方式：

4种输入模式：
   输入浮空
   输入上拉 
   输入下拉
   模拟输入
4种输出模式：
  开漏输出：只可以输出强低电平，高电平得靠外部电阻拉高。输出端相当于三极管的集电极. 要得到高电平状态需要上拉电阻才行. 适合于做电流型的驱动,其吸收电流的能力相对强(一般20ma以内)
  开漏复用功能
  推挽式输出：可以输出强高低电平，连接数字器件 
  推挽式复用功能
3种最大翻转速度：
   -2MHZ
   -10MHz
   -50MHz
</code></pre>
<h2 id="每组GPIO端口的寄存器"><a href="#每组GPIO端口的寄存器" class="headerlink" title="每组GPIO端口的寄存器"></a>每组GPIO端口的寄存器</h2><pre><code>包括：

两个32位配置寄存器(GPIOx_CRL ，GPIOx_CRH) ，
两个32位数据寄存器 (GPIOx_IDR和GPIOx_ODR)，
一个32位置位/ 复位寄存器(GPIOx_BSRR)，
一个16位复位寄存器(GPIOx_BRR)，
一个32位锁定寄存器(GPIOx_LCKR)。

每个I/O端口位可以自由编程，然而I/O端口寄存器必须按32位字被访问(不允许半字或字节访问) 。

每组IO口含下面7个寄存器。也就是7个寄存器，一共可以控制一组GPIO的16个IO口。
    - GPIOx_CRL :端口配置低寄存器
    - GPIOx_CRH:端口配置高寄存器
    - GPIOx_IDR:端口输入寄存器
    - GPIOx_ODR:端口输出寄存器
    - GPIOx_BSRR:端口位设置/清除寄存器
    - GPIOx_BRR :端口位清除寄存器
    - GPIOx_LCKR:端口配置锁存寄存器
</code></pre>
<h2 id="端口复用功能"><a href="#端口复用功能" class="headerlink" title="端口复用功能"></a>端口复用功能</h2><p>   STM32的大部分端口都具有复用功能。<br>   所谓复用，就是一些端口不仅仅可以做为通用IO口，还可以复用为一<br>   些外设引脚，比如PA9,PA10可以复用为STM32的串口1引脚。<br>   作用：最大限度的利用端口资源</p>
<h2 id="端口重映射功能"><a href="#端口重映射功能" class="headerlink" title="端口重映射功能"></a>端口重映射功能</h2><p>   就是可以把某些功能引脚映射到其他引脚。<br>   比如串口1默认引脚是PA9,PA10可以通过配置重映射映<br>   射到PB6,PB7<br>   作用：方便布线</p>
<h1 id="跑马灯程序"><a href="#跑马灯程序" class="headerlink" title="跑马灯程序"></a>跑马灯程序</h1><h2 id="硬件连接及GPIO库函数说明"><a href="#硬件连接及GPIO库函数说明" class="headerlink" title="硬件连接及GPIO库函数说明"></a>硬件连接及GPIO库函数说明</h2><pre><code> LED0接PB5
 LED1接PE5
 GPIO采用推挽输出的方式（可以输出高低电平）

 头文件：stm32f10x_gpio.h
 源文件：stm32f10x_gpio.c

 要使用GPIO的话 
 stm32f10x_gpio.c 
 stm32f10x_rcc.c 
 misc.c
 是必要的文件
</code></pre>
<h2 id="初始化函数："><a href="#初始化函数：" class="headerlink" title="初始化函数："></a>初始化函数：</h2><p>void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);<br>第一个参数 GPIO_TypeDef* GPIOx 表示选择第几个GPIO<br>第二个参数 GPIO_InitTypeDef* GPIO_InitStruct 中的GPIO_InitTypeDef结构体中的成员有：</p>
<p>GPIO_Pin用来指定IO口<br>GPIO_Speed用来指定速度<br>GPIO_Mode用来指定模式   </p>
<p>GPIO_Init函数初始化样例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GPIO_InitTypeDef  GPIO_InitStructure;	            //定义结构体</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;          //LED0--&gt;PB.5 端口配置</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;   //推挽输出</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  //IO口速度为50MHz</span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);	            //根据设定参数初始化GPIOB.5</span><br></pre></td></tr></table></figure>

<h2 id="2个读取输入电平函数："><a href="#2个读取输入电平函数：" class="headerlink" title="2个读取输入电平函数："></a>2个读取输入电平函数：</h2><p>uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);<br>作用：读取某<strong>个</strong>GPIO的输入电平。实际操作的是GPIOx_IDR寄存器。<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_5);//读取GPIOA.5的输入电平</span><br></pre></td></tr></table></figure>
<p>uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx);<br>作用：读取某<strong>组</strong>GPIO的输入电平。实际操作的是GPIOx_IDR寄存器。<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GPIO_ReadInputData(GPIOA);//读取GPIOA组中所有io口输入电平</span><br></pre></td></tr></table></figure>

<h2 id="2个读取输出电平函数："><a href="#2个读取输出电平函数：" class="headerlink" title="2个读取输出电平函数："></a>2个读取输出电平函数：</h2><p>uint8_t GPIO_ReadOutputDataBit (GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);<br>作用：读取某个GPIO的输出电平。实际操作的是GPIO_ODR寄存器。<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_5);//读取GPIOA.5的输出电平</span><br></pre></td></tr></table></figure>

<p>uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx);<br>作用：读取某组GPIO的输出电平。实际操作的是GPIO_ODR寄存器。<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GPIO_ReadOutputData(GPIOA);//读取GPIOA组中所有io口输出电平</span><br></pre></td></tr></table></figure>
<h2 id="4个设置输出电平函数："><a href="#4个设置输出电平函数：" class="headerlink" title="4个设置输出电平函数："></a>4个设置输出电平函数：</h2><p>void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);<br>作用：设置某个IO口输出为高电平（1）。实际操作BSRR寄存器</p>
<p>void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);<br>作用：设置某个IO口输出为低电平（0）。实际操作的BRR寄存器。</p>
<p>void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal);<br>void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal);<br> 这两个函数不常用，也是用来设置IO口输出电平。</p>
<h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>步骤：<br> 使能IO口时钟。调用函数RCC_APB2PeriphColckCmd();<br>     不同的IO组，调用的时钟使能函数不一样。<br> 初始化IO口模式。调用函数GPIO_Init();<br> 操作IO口，输出高低电平。<br>     GPIO_SetBits();<br>     GPIO_ResetBits();</p>
<h3 id="1-在template模板中新建HARDWARE（硬件）分组；"><a href="#1-在template模板中新建HARDWARE（硬件）分组；" class="headerlink" title="1.在template模板中新建HARDWARE（硬件）分组；"></a>1.在template模板中新建HARDWARE（硬件）分组；</h3><h3 id="2-在相应的目录中新建HARDWARE文件夹；"><a href="#2-在相应的目录中新建HARDWARE文件夹；" class="headerlink" title="2.在相应的目录中新建HARDWARE文件夹；"></a>2.在相应的目录中新建HARDWARE文件夹；</h3><h3 id="3-在HARDWARE文件夹中再新建LED等外设文件夹"><a href="#3-在HARDWARE文件夹中再新建LED等外设文件夹" class="headerlink" title="3.在HARDWARE文件夹中再新建LED等外设文件夹"></a>3.在HARDWARE文件夹中再新建LED等外设文件夹</h3><h3 id="4-每个外设文件夹中建立一个对应的-h和-c的文件"><a href="#4-每个外设文件夹中建立一个对应的-h和-c的文件" class="headerlink" title="4.每个外设文件夹中建立一个对应的.h和.c的文件"></a>4.每个外设文件夹中建立一个对应的.h和.c的文件</h3><h3 id="5-在-h中预编译防止重新引用"><a href="#5-在-h中预编译防止重新引用" class="headerlink" title="5.在.h中预编译防止重新引用"></a>5.在.h中预编译防止重新引用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifndef __LED_H</span><br><span class="line">#define __LED_H</span><br><span class="line">void LED_Init(void);    //声明LED初始化函数</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<h3 id="6-在-c（源文件）中定义函数"><a href="#6-在-c（源文件）中定义函数" class="headerlink" title="6.在.c（源文件）中定义函数"></a>6.在.c（源文件）中定义函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;led.h&quot;</span><br><span class="line">void LED_Init(void)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-按步骤调用函数RCC-APB2PeriphColckCmd"><a href="#7-按步骤调用函数RCC-APB2PeriphColckCmd" class="headerlink" title="7.按步骤调用函数RCC_APB2PeriphColckCmd();"></a>7.按步骤调用函数RCC_APB2PeriphColckCmd();</h3><p>写入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;led.h&quot;</span><br><span class="line">void LED_Init(void)</span><br><span class="line">&#123;</span><br><span class="line"> RCC_APB2PeriphClockCmd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后右键RCC_APB2PeriphClockCmd();点击go to definition<br>找到定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)</span><br><span class="line">&#123;</span><br><span class="line">  /* Check the parameters */</span><br><span class="line">  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));</span><br><span class="line">  assert_param(IS_FUNCTIONAL_STATE(NewState));</span><br><span class="line">  if (NewState != DISABLE)</span><br><span class="line">  &#123;</span><br><span class="line">    RCC-&gt;APB2ENR |= RCC_APB2Periph;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    RCC-&gt;APB2ENR &amp;= ~RCC_APB2Periph;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个参数RCC_APB2Periph 第二个参数NewState<br>右键IS_RCC_APB2_PERIPH点击go to definition查看有效值<br>找到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define RCC_APB2Periph_AFIO              ((uint32_t)0x00000001)</span><br><span class="line">#define RCC_APB2Periph_GPIOA             ((uint32_t)0x00000004)</span><br><span class="line">#define RCC_APB2Periph_GPIOB             ((uint32_t)0x00000008)</span><br><span class="line">#define RCC_APB2Periph_GPIOC             ((uint32_t)0x00000010)</span><br><span class="line">#define RCC_APB2Periph_GPIOD             ((uint32_t)0x00000020)</span><br><span class="line">#define RCC_APB2Periph_GPIOE             ((uint32_t)0x00000040)</span><br><span class="line">#define RCC_APB2Periph_GPIOF             ((uint32_t)0x00000080)</span><br><span class="line">#define RCC_APB2Periph_GPIOG             ((uint32_t)0x00000100)</span><br><span class="line">#define RCC_APB2Periph_ADC1              ((uint32_t)0x00000200)</span><br><span class="line">#define RCC_APB2Periph_ADC2              ((uint32_t)0x00000400)</span><br><span class="line">#define RCC_APB2Periph_TIM1              ((uint32_t)0x00000800)</span><br><span class="line">#define RCC_APB2Periph_SPI1              ((uint32_t)0x00001000)</span><br><span class="line">#define RCC_APB2Periph_TIM8              ((uint32_t)0x00002000)</span><br><span class="line">#define RCC_APB2Periph_USART1            ((uint32_t)0x00004000)</span><br><span class="line">#define RCC_APB2Periph_ADC3              ((uint32_t)0x00008000)</span><br><span class="line">#define RCC_APB2Periph_TIM15             ((uint32_t)0x00010000)</span><br><span class="line">#define RCC_APB2Periph_TIM16             ((uint32_t)0x00020000)</span><br><span class="line">#define RCC_APB2Periph_TIM17             ((uint32_t)0x00040000)</span><br><span class="line">#define RCC_APB2Periph_TIM9              ((uint32_t)0x00080000)</span><br><span class="line">#define RCC_APB2Periph_TIM10             ((uint32_t)0x00100000)</span><br><span class="line">#define RCC_APB2Periph_TIM11             ((uint32_t)0x00200000)</span><br><span class="line"></span><br><span class="line">#define IS_RCC_APB2_PERIPH(PERIPH) ((((PERIPH) &amp; 0xFFC00002) == 0x00) &amp;&amp; ((PERIPH) != 0x00))</span><br></pre></td></tr></table></figure>
<p>即可查看有效值<br>我们所使用的是GPIOB和GPIOE，所以<br>RCC_APB2PeriphColckCmd()的第一个输入参数是RCC_APB2Periph_GPIOB</p>
<p>同理右键IS_FUNCTIONAL_STATE点击go to definition查看有效值<br>找到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))</span><br></pre></td></tr></table></figure>
<p>发现有效值是DISABLE或者ENABLE<br>我们选择ENABLE，所以<br>RCC_APB2PeriphColckCmd()的第一个输入参数是ENABLE</p>
<p>此时的led.h内容为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;led.h&quot;</span><br><span class="line">void LED_Init(void)</span><br><span class="line">&#123;</span><br><span class="line"> RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编译后有两个error显示RCC_APB2Periph_GPIOB和ENABLE未定义<br>我们引用固件头文件stm32f10x.h后就OK了<br>此时的led.h内容为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;led.h&quot;</span><br><span class="line">#include &quot;stm32f10x.h&quot;</span><br><span class="line">void LED_Init(void)</span><br><span class="line">&#123;</span><br><span class="line"> RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此时GPIOB的时钟就已经启动了；</p>
<h3 id="8-初始化IO口模式。调用函数GPIO-Init"><a href="#8-初始化IO口模式。调用函数GPIO-Init" class="headerlink" title="8.初始化IO口模式。调用函数GPIO_Init();"></a>8.初始化IO口模式。调用函数GPIO_Init();</h3><p>复制GPIO_Init()到led.c中；右键go to definition查看具体参数<br>或者到gpio.h中找声明<br>声明中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);	</span><br></pre></td></tr></table></figure>
<p>有两个个参数分别是GPIOx和GPIO_InitStruct<br>GPIOx此时是GPIOB和GPIOE<br>GPIO_InitStruct是一个GPIO_InitTypeDef类型的结构体；<br>所以我们在前面先定义这个结构体</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStruct;</span><br></pre></td></tr></table></figure>
<p>定义完后注意赋值,发现结构体有<br> GPIO_InitStruct.GPIO_Mode<br> GPIO_InitStruct.GPIO_Pin<br> GPIO_InitStruct.GPIO_Speed<br>三个变量；通过上面的方法找到有效值如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br></pre></td></tr></table></figure>

<p><strong>注意在引用的时候要加&amp;符号</strong></p>
<p>即</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GPIO_Init(GPIOB,&amp;GPIO_InitStruct);</span><br></pre></td></tr></table></figure>
<p>同理可设置GPIOB的值，这一步完成后的led.c代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;led.h&quot;</span><br><span class="line">#include &quot;stm32f10x.h&quot;</span><br><span class="line">void LED_Init(void)</span><br><span class="line">&#123;</span><br><span class="line"> GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">	</span><br><span class="line"> RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line"> RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE,ENABLE);</span><br><span class="line">	</span><br><span class="line"> GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line"> GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;</span><br><span class="line"> GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"> GPIO_Init(GPIOB,&amp;GPIO_InitStruct);</span><br><span class="line">	</span><br><span class="line"> GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line"> GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;</span><br><span class="line"> GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"> GPIO_Init(GPIOE,&amp;GPIO_InitStruct);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-操作IO口，输出高低电平"><a href="#9-操作IO口，输出高低电平" class="headerlink" title="9.操作IO口，输出高低电平"></a>9.操作IO口，输出高低电平</h3><p>一般默认初始化之后灯先不点亮，所以需要设置为高电平，需要用到<br>    GPIO_SetBits();<br>    GPIO_ResetBits();</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GPIO_SetBits(GPIOB,GPIO_Pin_5);</span><br><span class="line">GPIO_SetBits(GPIOE,GPIO_Pin_5);</span><br></pre></td></tr></table></figure>
<p>此时led.c的内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;led.h&quot;</span><br><span class="line">#include &quot;stm32f10x.h&quot;</span><br><span class="line">void LED_Init(void)</span><br><span class="line">&#123;</span><br><span class="line"> GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">	</span><br><span class="line"> RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line"> RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE,ENABLE);</span><br><span class="line">	</span><br><span class="line"> GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line"> GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;</span><br><span class="line"> GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"> GPIO_Init(GPIOB,&amp;GPIO_InitStruct);</span><br><span class="line"> GPIO_SetBits(GPIOB,GPIO_Pin_5);</span><br><span class="line">	</span><br><span class="line"> GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line"> GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;</span><br><span class="line"> GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"> GPIO_Init(GPIOE,&amp;GPIO_InitStruct);</span><br><span class="line"> GPIO_SetBits(GPIOE,GPIO_Pin_5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="从主函数开始写程序"><a href="#从主函数开始写程序" class="headerlink" title="从主函数开始写程序"></a>从主函数开始写程序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&quot;stm32f10x.h&quot;</span><br><span class="line">#include&quot;led.h&quot;</span><br><span class="line">#include&quot;delay.h&quot;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    LED_Init();</span><br><span class="line">    delay_init();</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        GPIO_SetBits(GPIOB,GPIO_Pin_5);</span><br><span class="line">        GPIO_SetBits(GPIOE,GPIO_Pin_5);     //设为高电平</span><br><span class="line"></span><br><span class="line">        delay_ms(500);</span><br><span class="line"></span><br><span class="line">        GPIO_ResetBits(GPIOB,GPIO_Pin_5);</span><br><span class="line">        GPIO_ResetBits(GPIOE,GPIO_Pin_5);     //设为低电平</span><br><span class="line"></span><br><span class="line">        delay_ms(500);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="蜂鸣器实验"><a href="#蜂鸣器实验" class="headerlink" title="蜂鸣器实验"></a>蜂鸣器实验</h1><p>蜂鸣器是一种一体化结构的电子讯响器，采用直流电压供电，广泛应用于计算机、打印机、<br>复印机、报警器、电子玩具、汽车电子设备、电话机、定时器等电子产品中作发声器件。蜂鸣<br>器主要分为压电式蜂鸣器和电磁式蜂鸣器两种类型。<br>这里的有源不是指电源的“源”，而是指有没有自带震荡电路，有源蜂鸣器自带了震荡电路，<br>一通电就会发声；无源蜂鸣器则没有自带震荡电路，必须外部提供 2~5Khz 左右的方波驱动，<br>才能发声。<br>我们用到一个 NPN 三极管（S8050）来驱动蜂鸣器，R33 主要用于防止蜂鸣器的误发<br>声。当 PB.8 输出高电平的时候，蜂鸣器将发声，当 PB.8 输出低电平的时候，蜂鸣器停止发声。<br>电流从三极管基极进入放大后才能驱动蜂鸣器。由于STM32单片机复位后BEEP位是浮空的，即该IO口的状态是不确定的，所以我们需要接一个R38（10KΩ）再接地，把小电流引到地，这样可以防止误发声。</p>
<h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><p>使能IO口时钟。调用函数RCC_APB2PeriphColckCmd();<br>    不同的IO组，调用的时钟使能函数不一样。<br>初始化IO口模式。调用函数BEEP_Init();<br>操作IO口，输出高低电平。</p>
<h1 id="按键输入实验"><a href="#按键输入实验" class="headerlink" title="按键输入实验"></a>按键输入实验</h1><h2 id="按键的硬件连接"><a href="#按键的硬件连接" class="headerlink" title="按键的硬件连接"></a>按键的硬件连接</h2><p>有三个按键 WK UP、KEY_0、KEY_1<br>WK UP接PA0 另一端接Vcc<br>KEY_0接PE4 另一端接GND<br>KEY_1接PE3 另一端接GND</p>
<h2 id="按键输入操作说明"><a href="#按键输入操作说明" class="headerlink" title="按键输入操作说明"></a>按键输入操作说明</h2><p>读取IO口输入电平调用库函数为：<br>uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);</p>
<p>读取IO口输入电平操作寄存器为<br>GPIOx_IDR:端口输入寄存器</p>
<p>使用位带操作读取IO口输入电平：<br>PEin(4)          -读取GPIOE.4口电平<br>PEin(n)          -读取GPIOE.n口电平</p>
<h2 id="按键输入实验步骤"><a href="#按键输入实验步骤" class="headerlink" title="按键输入实验步骤"></a>按键输入实验步骤</h2><p>使能按键对应IO口时钟。调用函数：<br>    RCC_APB2PeriphClockCmd();<br>初始化IO模式：上拉/下拉输入。调用函数：<br>    GPIO_Init();<br>扫描IO口电平（库函数/寄存器/位操作）  </p>
<h2 id="C语言关键字-：static"><a href="#C语言关键字-：static" class="headerlink" title="C语言关键字 ：static"></a>C语言关键字 ：static</h2><p>Static申明的局部变量，存储在静态存储区。<br>它在函数调用结束之后，不会被释放。它的值会一直保留下来。<br>所以可以说static申明的局部变量，具有记忆功能。<br>比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int getValue(void)</span><br><span class="line">&#123;</span><br><span class="line">  int  flag=0;</span><br><span class="line">  flag++;</span><br><span class="line">  return flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int getValue(void)</span><br><span class="line">&#123;</span><br><span class="line">  static int  flag=0;</span><br><span class="line">  flag++;</span><br><span class="line">  return flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="按键扫描（支持连续按）的一般思路"><a href="#按键扫描（支持连续按）的一般思路" class="headerlink" title="按键扫描（支持连续按）的一般思路"></a>按键扫描（支持连续按）的一般思路</h2><p>如果我要实现：按键按下，没有松开，只能算按下一次，这个函数无法实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u8 KEY_Scan(void)</span><br><span class="line">   &#123;</span><br><span class="line">     if(KEY按下）</span><br><span class="line">    &#123;</span><br><span class="line">          delay_ms(10)；//延时10-20ms，防抖。</span><br><span class="line">          if(KEY确实按下)</span><br><span class="line">           &#123;</span><br><span class="line">              return KEY_Value；</span><br><span class="line">            &#125;</span><br><span class="line">         return 无效值；</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="按键扫描（不支持连续按）的一般思路"><a href="#按键扫描（不支持连续按）的一般思路" class="headerlink" title="按键扫描（不支持连续按）的一般思路"></a>按键扫描（不支持连续按）的一般思路</h2><p>不支持连续按：就是说，按键按下了，没有松开，只能算一次。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u8 KEY_Scan(void)</span><br><span class="line">    &#123;</span><br><span class="line">     static u8 key_up=1;  //key_up==1表示前一次是松开的；key_up==0表示前一次是闭合的</span><br><span class="line">      if（key_up &amp;&amp;  KEY按下）</span><br><span class="line">      &#123;</span><br><span class="line">        delay_ms(10);//延时，防抖</span><br><span class="line">        key_up=0;//标记这次key已经按下</span><br><span class="line">        if(KEY确实按下)</span><br><span class="line">          &#123;</span><br><span class="line">           return KEY_VALUE;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;else if(KEY没有按下)  key_up=1;</span><br><span class="line">       return 没有按下</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="按键扫描（两种模式合二为一）的一般思路"><a href="#按键扫描（两种模式合二为一）的一般思路" class="headerlink" title="按键扫描（两种模式合二为一）的一般思路"></a>按键扫描（两种模式合二为一）的一般思路</h2><p>多了一个入口参数mode；mode==1表示支持连续按 mode==0表示不支持连续按 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u8 KEY_Scan(u8 mode)</span><br><span class="line">   &#123;</span><br><span class="line">    static u8 key_up=1;</span><br><span class="line">    if(mode==1) key_up=1;//支持连续按</span><br><span class="line">     if（key_up &amp;&amp;  KEY按下）</span><br><span class="line">     &#123;</span><br><span class="line">       delay_ms(10);//延时，防抖</span><br><span class="line">       key_up=0;//标记这次key已经按下</span><br><span class="line">       if(KEY确实按下)</span><br><span class="line">         &#123;</span><br><span class="line">          return KEY_VALUE;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;else if(KEY没有按下)  key_up=1;</span><br><span class="line">      return 没有按下</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="C语言复习和MDK中寄存器地址名称映射分析"><a href="#C语言复习和MDK中寄存器地址名称映射分析" class="headerlink" title="C语言复习和MDK中寄存器地址名称映射分析"></a>C语言复习和MDK中寄存器地址名称映射分析</h1><h2 id="位操作：6种位操作运算符"><a href="#位操作：6种位操作运算符" class="headerlink" title="位操作：6种位操作运算符"></a>位操作：6种位操作运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
<th>运算符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>按位与</td>
<td>~</td>
<td>取反</td>
</tr>
<tr>
<td>|</td>
<td>按位或</td>
<td>&lt;&lt;</td>
<td>左移</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
<td>&gt;&gt;</td>
<td>右移</td>
</tr>
</tbody></table>
<p>GPIOA-&gt;CRL&amp;=0XFFFFFF0F;    //将第4-7位清0<br>GPIOA-&gt;CRL|=0X00000040;    //设置相应位的值，不改变其他位的值<br>GPIOA-&gt;ODR|=1&lt;&lt;5;<br>TIMx-&gt;SR = (uint16_t)~TIM_FLAG;</p>
<p>左移和右移都是补0</p>
<h2 id="define宏定义关键词"><a href="#define宏定义关键词" class="headerlink" title="define宏定义关键词"></a>define宏定义关键词</h2><p>define是C语言中的预处理命令，它用于宏定义，可以提高源代码的可读性，为编程提供方便。<br>常见的格式：<br>#define 标识符 字符串<br>“标识符”为所定义的宏名。“字符串”可以是常数、表达式、格式串等。<br>例如：<br>#define SYSCLK_FREQ_72MHz  72000000<br>定义标识符SYSCLK_FREQ_72MHz的值为72000000。</p>
<h2 id="ifdef条件编译"><a href="#ifdef条件编译" class="headerlink" title="ifdef条件编译"></a>ifdef条件编译</h2><p>单片机程序开发过程中，经常会遇到一种情况，当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句。条件编译命令最常见的形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef 标识符 </span><br><span class="line">程序段1 </span><br><span class="line">#else </span><br><span class="line">程序段2 </span><br><span class="line">#endif </span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef STM32F10X_HD</span><br><span class="line">大容量芯片需要的一些变量定义</span><br><span class="line">#end</span><br></pre></td></tr></table></figure>

<h2 id="extern变量申明"><a href="#extern变量申明" class="headerlink" title="extern变量申明"></a>extern变量申明</h2><p>Main.c文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u8 id;//定义只允许一次</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">id=1;</span><br><span class="line">printf(&quot;d%&quot;,id);//id=1</span><br><span class="line">test();</span><br><span class="line">printf(&quot;d%&quot;,id);//id=2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>test.c文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extern u8 id;//此处声明id这个变量，不是定义</span><br><span class="line">void test(void)&#123;</span><br><span class="line">id=2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="typedef类型别名"><a href="#typedef类型别名" class="headerlink" title="typedef类型别名"></a>typedef类型别名</h2><p>定义一种类型的别名，而不只是简单的宏替换。可以用作同时声明指针型的多个对象。</p>
<p>typedef unsigned          char uint8_t;<br>typedef unsigned short     int uint16_t;<br>typedef unsigned           int uint32_t;<br>typedef unsigned       __int64 uint64_t;</p>
<h2 id="结构体：构造类型"><a href="#结构体：构造类型" class="headerlink" title="结构体：构造类型"></a>结构体：构造类型</h2><p>Struct 结构体名{<br>成员列表1;<br>成员变量2；<br>…<br>}变量名列表；</p>
<p>在结构体申明的时候可以定义变量，也可以申明之后定义，方法是：<br>Struct 结构体名字   结构体变量列表 ;</p>
<p>结构体作用：<br>    同一个类型可以用数组，不同类型可以用结构体组织。</p>
<pre><code>结构体可扩展性强。

举例说明：
    void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
</code></pre>
<h2 id="STM32中操作："><a href="#STM32中操作：" class="headerlink" title="STM32中操作："></a>STM32中操作：</h2><p>GPIOA-&gt;ODR=0x00000000; </p>
<p>值0x00000000是怎么赋值给了GPIOA的ODR寄存器地址的呢？</p>
<p>也就是说GPIOA-&gt;ODR这种写法，是怎么与GPIOA的ODR寄存器地址映射起来的？<br>#define PERIPH_BASE           ((uint32_t)0x40000000)<br>#define APB2PERIPH_BASE       (PERIPH_BASE + 0x10000)<br>#define GPIOA_BASE            (APB2PERIPH_BASE + 0x0800)<br>#define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)<br>typedef struct<br>{<br>  __IO uint32_t CRL;<br>  __IO uint32_t CRH;<br>  __IO uint32_t IDR;<br>  __IO uint32_t ODR;<br>  __IO uint32_t BSRR;<br>  __IO uint32_t BRR;<br>  __IO uint32_t LCKR;<br>} GPIO_TypeDef;</p>
<h1 id="时钟系统"><a href="#时钟系统" class="headerlink" title="时钟系统"></a>时钟系统</h1><p>几个重要的时钟：</p>
<p>SYSCLK(系统时钟) :<br> AHB总线时钟<br> APB1总线时钟(低速): 速度最高36MHz<br> APB2总线时钟(高速): 速度最高72MHz<br> PLL时钟</p>
<p>参考资料：<br><a href="http://www.openedv.com/posts/list/302.htm">http://www.openedv.com/posts/list/302.htm</a></p>
<ol>
<li><p>STM32 有5个时钟源:HSI、HSE、LSI、LSE、PLL。<br> ①、HSI是高速内部时钟，RC振荡器，频率为8MHz，精度不高。<br> ②、HSE是高速外部时钟，可接石英/陶瓷谐振器，或者接外部时钟源，频率范围为4MHz<del>16MHz。③、LSI是低速内部时钟，RC振荡器，频率为40kHz，提供低功耗时钟。<br> ④、LSE是低速外部时钟，接频率为32.768kHz的石英晶体。<br> ⑤、PLL为锁相环倍频输出，其时钟输入源可选择为HSI/2、HSE或者HSE/2。倍频可选择为2</del>16倍，但是其输出频率最大不得超过72MHz。</p>
</li>
<li><p>系统时钟SYSCLK可来源于三个时钟源：<br> ①、HSI振荡器时钟<br> ②、HSE振荡器时钟<br> ③、PLL时钟</p>
</li>
<li><p>STM32可以选择一个时钟信号输出到MCO脚(PA8)上，可以选择为PLL<br> 输出的2分频、HSI、HSE、或者系统时钟。</p>
</li>
<li><p>任何一个外设在使用之前，必须首先使能其相应的时钟。</p>
</li>
</ol>
<h2 id="系统时钟初始化函数："><a href="#系统时钟初始化函数：" class="headerlink" title="系统时钟初始化函数："></a>系统时钟初始化函数：</h2><pre><code>SystemInit();
</code></pre>
<p>  使用V3.5版本的库函数，该函数在系统启动之后会自动调用：<br>    startup_stm32f10x_xx.s文件中：<br>            ; Reset handler<br>                Reset_Handler   PROC<br>                 EXPORT  Reset_Handler             [WEAK]<br>                 IMPORT  __main<br>                 IMPORT  SystemInit<br>                 LDR     R0, =SystemInit<br>                 BLX     R0<br>                 LDR     R0, =__main<br>                 BX      R0<br>                 ENDP</p>
<h1 id="SysTick定时器"><a href="#SysTick定时器" class="headerlink" title="SysTick定时器"></a>SysTick定时器</h1><p>Systick定时器，是一个简单的定时器，对于CM3,CM4内核芯片，都有Systick定时器。</p>
<p>Systick定时器常用来做延时，或者实时系统的心跳时钟。这样可以节省MCU资源，不用浪费一个定时器。比如UCOS中，分时复用，需要一个最小的时间戳，一般在STM32+UCOS系统中，都采用Systick做UCOS心跳时钟。</p>
<p>Systick定时器就是系统滴答定时器，一个24 位的倒计数定时器，计到0 时，将从RELOAD 寄存器中自动重装载定时初值。只要不把它在SysTick 控制及状态寄存器中的使能位清除，就永不停息，即使在睡眠模式下也能工作。</p>
<p>SysTick定时器被捆绑在NVIC中，用于产生SYSTICK异常（异常号：15）。<br>Systick中断的优先级也可以设置。</p>
<p>4个Systick寄存器</p>
<pre><code>CTRL             SysTick 控制和状态寄存器  
LOAD             SysTick 自动重装载除值寄存器 
VAL              SysTick 当前值寄存器  
CALIB            SysTick 校准值寄存器
</code></pre>
<p>对于STM32，<br>    外部时钟源是 HCLK(AHB总线时钟）的1/8<br>    内核时钟是 HCLK时钟<br>    配置函数：SysTick_CLKSourceConfig();</p>
<p>固件库中的Systick相关函数：</p>
<p>SysTick_CLKSourceConfig()    //Systick时钟源选择  misc.c文件中</p>
<p>SysTick_Config(uint32_t ticks) //初始化systick,时钟为HCLK,并开启中断<br>                               //core_cm3.h/core_cm4.h文件中<br>Systick中断服务函数：</p>
<p>   void SysTick_Handler(void);</p>
<h1 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h1><p>STM32有很多的内置外设，这些外设的外部引脚都是与GPIO复用的。也就是说，一个GPIO如果可以复用为内置外设的功能引脚，那么当这个GPIO作为内置外设使用的时候，就叫做复用。</p>
<p>例如串口1 的发送接收引脚是PA9,PA10，当我们把PA9,PA10不用作GPIO，而用做复用功能串口1的发送接收引脚的时候，叫端口复用。</p>
<p>端口复用配置过程：<br>以PA9,PA10配置为串口1为例<br>1.GPIO端口时钟使能。<br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</p>
<p>2.复用外设时钟使能。<br>    比如你要将端口PA9,PA10复用为串口，所以要使能串口时钟。<br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);</p>
<p>3.端口模式配置。 GPIO_Init（）函数。<br>    查表：<br>   《STM32中文参考手册V10》P110的表格“8.1.11外设的GPIO配置”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);  //①IO时钟使能</span><br><span class="line"></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE); //②外设时钟使能</span><br><span class="line"></span><br><span class="line">//③初始化IO为对应的模式</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //PA.9//复用推挽输出</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; </span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">  </span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;//PA10 PA.10 浮空输入</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);  </span><br></pre></td></tr></table></figure>

<h1 id="中断优先级管理NVIC"><a href="#中断优先级管理NVIC" class="headerlink" title="中断优先级管理NVIC"></a>中断优先级管理NVIC</h1><p>CM3内核支持256个中断，其中包含了16个内核中断和240个外部中断，并且具有256级的可编程中断设置。<br>STM32并没有使用CM3内核的全部东西，而是只用了它的一部分。<br>STM32有84个中断，包括16个内核中断和68个可屏蔽中断，具有16级可编程的中断优先级。<br>STM32F103系列上面，又只有60个可屏蔽中断（在107系列才有68个）</p>
<h2 id="中断管理方法："><a href="#中断管理方法：" class="headerlink" title="中断管理方法："></a>中断管理方法：</h2><p>首先，对STM32中断进行分组，组0~4。同时，对每个中断设置一个抢占优先级和一个响应优先级值。</p>
<p>分组配置是在寄存器SCB-&gt;AIRCR中配置：</p>
<h2 id="抢占优先级-amp-响应优先级区别："><a href="#抢占优先级-amp-响应优先级区别：" class="headerlink" title="抢占优先级 &amp; 响应优先级区别："></a>抢占优先级 &amp; 响应优先级区别：</h2><p>高抢占优先级可以打断正在进行的低抢占优先级中断的。<br>抢占优先级相同的中断，高响应优先级不可以打断低响应优先级的中断。<br>抢占优先级相同的中断，当两个中断同时发生的情况下，哪个响应优先级高，哪个先执行。<br>如果两个中断的抢占优先级和响应优先级都是一样的话，则看哪个中断先发生就先执行；</p>
<p>假定设置中断优先级组为2，然后设置中断3(RTC中断)的抢占优先级为2，响应优先级为1。  中断6（外部中断0）的抢占优先级为3，响应优先级为0。中断7（外部中断1）的抢占优先级为2，响应优先级为0。<br>那么这3个中断的优先级顺序为：中断7&gt;中断3&gt;中断6.</p>
<h2 id="特别说明："><a href="#特别说明：" class="headerlink" title="特别说明："></a>特别说明：</h2><p>一般情况下，系统代码执行过程中，只设置一次中断优先级分组，比如分组2，设置好分组之后一般不会再改变分组。随意改变分组会导致中断管理混乱，程序出现意想不到的执行结果。</p>
<h2 id="中断优先级分组函数"><a href="#中断优先级分组函数" class="headerlink" title="中断优先级分组函数:"></a>中断优先级分组函数:</h2><p>void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup);</p>
<p>void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup)<br>{<br>  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));<br>  SCB-&gt;AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;<br>}</p>
<p>NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</p>
<h2 id="怎么设置单个中断的抢占优先级和响应优先级？"><a href="#怎么设置单个中断的抢占优先级和响应优先级？" class="headerlink" title="怎么设置单个中断的抢占优先级和响应优先级？"></a>怎么设置单个中断的抢占优先级和响应优先级？</h2><p>中断设置相关寄存器<br>__IO uint8_t  IP[240]; //中断优先级控制的寄存器组</p>
<p>__IO uint32_t ISER[8]; //中断使能寄存器组<br>__IO uint32_t ICER[8]; //中断失能寄存器组<br>__IO uint32_t ISPR[8]; //中断挂起寄存器组<br>__IO uint32_t ICPR[8]; //中断解挂寄存器组<br>__IO uint32_t IABR[8]; //中断激活标志位寄存器组</p>
<p>MDK中NVIC寄存器结构体:<br>typedef struct<br>{<br>  __IO uint32_t ISER[8];<br>       uint32_t RESERVED0[24];<br>  __IO uint32_t ICER[8];<br>       uint32_t RSERVED1[24];<br>  __IO uint32_t ISPR[8];<br>       uint32_t RESERVED2[24];<br>  __IO uint32_t ICPR[8];<br>       uint32_t RESERVED3[24];<br>  __IO uint32_t IABR[8];<br>       uint32_t RESERVED4[56];<br>  __IO uint8_t  IP[240];<br>       uint32_t RESERVED5[644];<br>  __O  uint32_t STIR;<br>}  NVIC_Type; </p>
<h2 id="对于每个中断怎么设置优先级？"><a href="#对于每个中断怎么设置优先级？" class="headerlink" title="对于每个中断怎么设置优先级？"></a>对于每个中断怎么设置优先级？</h2><p>中断优先级控制的寄存器组：IP[240]<br>全称是：Interrupt Priority Registers</p>
<p>240个8位寄存器，每个中断使用一个寄存器来确定优先级。STM32F10x系列一共60个可屏蔽中断，使用IP[59]~IP[0]。</p>
<p>每个IP寄存器的高4位用来设置抢占和响应优先级（根据分组），低4位没有用到。</p>
<p>void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);</p>
<h2 id="中断使能寄存器组：ISER-8"><a href="#中断使能寄存器组：ISER-8" class="headerlink" title="中断使能寄存器组：ISER[8]"></a>中断使能寄存器组：ISER[8]</h2><p>作用：用来使能中断<br>32位寄存器，每个位控制一个中断的使能。STM32F10x只有60个可屏蔽中断，所以只使用了其中的ISER[0]和ISER[1]。</p>
<p>ISER[0]的bit0<del>bit31分别对应中断0</del>31。ISER[1]的bit0<del>27对应中断32</del>59；</p>
<p>void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);</p>
<h2 id="中断失能寄存器组：ICER-8"><a href="#中断失能寄存器组：ICER-8" class="headerlink" title="中断失能寄存器组：ICER[8]"></a>中断失能寄存器组：ICER[8]</h2><p>作用：用来失能中断<br>32位寄存器，每个位控制一个中断的失能。STM32F10x只有60个可屏蔽中断，所以只使用了其中的ICER[0]和ICER[1]。</p>
<p>ICER[0]的bit0<del>bit31分别对应中断0</del>31。ICER[1]的bit0<del>27对应中断32</del>59；</p>
<p>配置方法跟ISER一样。</p>
<p>void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);</p>
<h2 id="中断挂起控制寄存器组：ISPR-8"><a href="#中断挂起控制寄存器组：ISPR-8" class="headerlink" title="中断挂起控制寄存器组：ISPR[8]"></a>中断挂起控制寄存器组：ISPR[8]</h2><p>作用：用来挂起中断</p>
<h2 id="中断解挂控制寄存器组：ICPR-8"><a href="#中断解挂控制寄存器组：ICPR-8" class="headerlink" title="中断解挂控制寄存器组：ICPR[8]"></a>中断解挂控制寄存器组：ICPR[8]</h2><p>作用：用来解挂中断<br>static __INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)；<br>static __INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)；<br>static __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)</p>
<h2 id="中断参数初始化函数"><a href="#中断参数初始化函数" class="headerlink" title="中断参数初始化函数"></a>中断参数初始化函数</h2><p>void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);</p>
<p>typedef struct<br>{<br>  uint8_t NVIC_IRQChannel; //设置中断通道<br>  uint8_t NVIC_IRQChannelPreemptionPriority;//设置响应优先级<br>  uint8_t NVIC_IRQChannelSubPriority; //设置抢占优先级<br>  FunctionalState NVIC_IRQChannelCmd; //使能/使能<br>} NVIC_InitTypeDef;</p>
<p>NVIC_InitTypeDef   NVIC_InitStructure;<br>NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;//串口1中断<br>NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=1 ;// 抢占优先级为1<br>NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;// 子优先级位2<br>NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;//IRQ通道使能<br>NVIC_Init(&amp;NVIC_InitStructure);    //根据上面指定的参数初始化NVIC寄存器</p>
<h2 id="中断优先级设置步骤"><a href="#中断优先级设置步骤" class="headerlink" title="中断优先级设置步骤"></a>中断优先级设置步骤</h2><p>系统运行后先设置中断优先级分组。调用函数：</p>
<ol>
<li>void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup);<br>整个系统执行过程中，只设置一次中断分组。</li>
<li>针对每个中断，设置对应的抢占优先级和响应优先级：<br>void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);</li>
<li>如果需要挂起/解挂，查看中断当前激活状态，分别调用相关函数即可</li>
</ol>
<h1 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h1><h2 id="通信接口背景知识"><a href="#通信接口背景知识" class="headerlink" title="通信接口背景知识"></a>通信接口背景知识</h2><p>处理器与外部设备通信的两种方式：<br>并行通信<br>   -传输原理：数据各个位同时传输。<br>   -优点：速度快<br>   -缺点：占用引脚资源多</p>
<p>串行通信<br>   -传输原理：数据按位顺序传输。<br>   -优点：占用引脚资源少<br>   -缺点：速度相对较慢</p>
<p>串行通信：<br>按照数据传送方向，分为：<br>单工：<br>         数据传输只支持数据在一个方向上传输<br>半双工：<br>        允许数据在两个方向上传输，但是，在某一时刻，只允许数<br>        据在一个方向上传输，它实际上是一种切换方向的单工通信；<br>全双工：<br>        允许数据同时在两个方向上传输，因此，全双工通信是两个<br>        单工通信方式的结合，它要求发送设备和接收设备都有独立<br>        的接收和发送能力。 </p>
<p>同步通信：带时钟同步信号传输。<br>    SPI，IIC通信接口<br>异步通信：不带时钟同步信号。<br>    UART(通用异步收发器),单总线(要约定波特率)</p>
<p>常见的串行通信接口：</p>
<table>
<thead>
<tr>
<th>通信标准</th>
<th>引脚说明</th>
<th>通信方式</th>
<th>通信方向</th>
</tr>
</thead>
<tbody><tr>
<td>UART(通用异步收发器)</td>
<td>TXD:发送端 RXD:接受端 GND:公共地</td>
<td>异步通信</td>
<td>全双工</td>
</tr>
<tr>
<td>单总线（1-wire)</td>
<td>DQ:发送/接受端</td>
<td>异步通信</td>
<td>半双工</td>
</tr>
<tr>
<td>SPI</td>
<td>SCK:同步时钟 MISO:主机输入，从机输出 MOSI:主机输出，从机输入</td>
<td>同步通信</td>
<td>全双工</td>
</tr>
<tr>
<td>I²C</td>
<td>SCL:同步时钟 SDA:数据输入/输出端</td>
<td>同步通信</td>
<td>半双工</td>
</tr>
</tbody></table>
<p>STM32的串口通信接口：</p>
<p>UART:通用异步收发器<br>USART:通用同步异步收发器<br>大容量STM32F10x系列芯片，包含3个USART和2个UART</p>
<p>UART异步通信方式引脚：<br>-RXD:数据输入引脚。数据接受。<br>-TXD:数据发送引脚。数据发送。</p>
<table>
<thead>
<tr>
<th>串口号</th>
<th>RXD</th>
<th>TXD</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>PA10</td>
<td>PA9</td>
</tr>
<tr>
<td>2</td>
<td>PA3</td>
<td>PA2</td>
</tr>
<tr>
<td>3</td>
<td>PB11</td>
<td>PB10</td>
</tr>
<tr>
<td>4</td>
<td>PC11</td>
<td>PC10</td>
</tr>
<tr>
<td>5</td>
<td>PD2</td>
<td>PC12</td>
</tr>
</tbody></table>
<p>UART异步通信方式特点：<br>全双工异步通信。<br>分数波特率发生器系统，提供精确的波特率。<br>-发送和接受共用的可编程波特率，最高可达4.5Mbits/s<br>可编程的数据字长度（8位或者9位）；<br>可配置的停止位（支持1或者2位停止位）；<br>可配置的使用DMA多缓冲器通信。<br>单独的发送器和接收器使能位。<br>检测标志：① 接受缓冲器  ②发送缓冲器空 ③传输结束标志<br>多个带标志的中断源。触发中断。<br>其他：校验控制，四个错误检测标志。</p>
<p>STM32串口异步通信需要定义的参数：<br> 起始位<br> 数据位（8位或者9位）<br> 奇偶校验位（第9位）<br> 停止位（1,15,2位）<br> 波特率设置</p>
<h2 id="STM32串口常用寄存器和库函数"><a href="#STM32串口常用寄存器和库函数" class="headerlink" title="STM32串口常用寄存器和库函数"></a>STM32串口常用寄存器和库函数</h2><p>常用的串口相关寄存器:<br>USART_SR状态寄存器<br>USART_DR数据寄存器<br>USART_BRR波特率寄存器<br>串口操作相关库函数（省略入口参数）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void USART_Init(); //串口初始化：波特率，数据字长，奇偶校验，硬件流控以及收发使能</span><br><span class="line">void USART_Cmd();//使能串口</span><br><span class="line">void USART_ITConfig();//使能相关中断</span><br><span class="line"></span><br><span class="line">void USART_SendData();//发送数据到串口，DR</span><br><span class="line">uint16_t USART_ReceiveData();//接受数据，从DR读取接受到的数据</span><br><span class="line"></span><br><span class="line">FlagStatus USART_GetFlagStatus();//获取状态标志位</span><br><span class="line">void USART_ClearFlag();//清除状态标志位</span><br><span class="line">ITStatus USART_GetITStatus();//获取中断状态标志位</span><br><span class="line">void USART_ClearITPendingBit();//清除中断状态标志位</span><br></pre></td></tr></table></figure>
<h3 id="串口初始化函数"><a href="#串口初始化函数" class="headerlink" title="串口初始化函数"></a>串口初始化函数</h3><p>找到初始化函数的声明：<br>void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)<br>两个入口参数分别是<br>串口标号USARTx和一个结构体USART_InitStruct 找到结构体的定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  uint32_t USART_BaudRate;     //波特率       </span><br><span class="line"></span><br><span class="line">  uint16_t USART_WordLength;   //字长     </span><br><span class="line">  uint16_t USART_StopBits;     //停止位       </span><br><span class="line"></span><br><span class="line">  uint16_t USART_Parity;      //奇偶校验位        </span><br><span class="line">  uint16_t USART_Mode;        //发送接收使能位</span><br><span class="line"></span><br><span class="line">  uint16_t USART_HardwareFlowControl;   //硬件流设置</span><br><span class="line">&#125; USART_InitTypeDef;</span><br></pre></td></tr></table></figure>
<h3 id="串口配置的一般步骤"><a href="#串口配置的一般步骤" class="headerlink" title="串口配置的一般步骤"></a>串口配置的一般步骤</h3><p>串口时钟使能，GPIO时钟使能:RCC_APB2PeriphClockCmd();<br>串口复位:USART_DeInit(); 这一步不是必须的<br>GPIO端口模式设置:GPIO_Init(); 模式设置为GPIO_Mode_AF_PP<br>串口参数初始化：USART_Init();<br>开启中断并且初始化NVIC（如果需要开启中断才需要这个步骤）<br>      NVIC_Init();<br>      USART_ITConfig();<br>⑥使能串口:USART_Cmd();<br>⑦编写中断处理函数：USARTx_IRQHandler();<br>⑧串口数据收发：<br>void USART_SendData();//发送数据到串口，DR<br>uint16_t USART_ReceiveData();//接受数据，从DR读取接受到的数据<br>⑨串口传输状态获取：<br>FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG);<br>void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);</p>
<p>PA9 PA10复用为串口1</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void My_USART1_Init(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStruct;				//定义一个GPIO结构体</span><br><span class="line">	USART_InitTypeDef USART_InitStruct;				//定义一个串口结构体</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStruct;				//定义一个中断结构体</span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);		//GPIO时钟使能</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);		//串口时钟使能</span><br><span class="line">	</span><br><span class="line">	//初始化GPIO结构体和GPIO引脚</span><br><span class="line">	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;    //推挽输出</span><br><span class="line">	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_9;			//输出引脚</span><br><span class="line">	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_10MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStruct);				//GPIOA9初始化</span><br><span class="line">	/*************************************************************************/</span><br><span class="line">	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;		//浮空输入</span><br><span class="line">	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_10;					//输出引脚</span><br><span class="line">	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_10MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStruct);						//GPIOA10初始化</span><br><span class="line">	/*************************************************************************/</span><br><span class="line">	</span><br><span class="line">	//初始化串口</span><br><span class="line">	USART_InitStruct.USART_BaudRate = 115200;				//设置波特率</span><br><span class="line">	USART_InitStruct.USART_HardwareFlowControl =	USART_HardwareFlowControl_None; //不使用硬件流</span><br><span class="line">	USART_InitStruct.USART_Mode = USART_Mode_Rx|USART_Mode_Tx; //使能发送和接受</span><br><span class="line">	USART_InitStruct.USART_Parity = USART_Parity_No;     //不用奇偶校验</span><br><span class="line">	USART_InitStruct.USART_StopBits = USART_StopBits_1;  //停止位设为1</span><br><span class="line">	USART_InitStruct.USART_WordLength = USART_WordLength_8b; //字长设为8</span><br><span class="line">	USART_Init(USART1,&amp;USART_InitStruct);</span><br><span class="line">	</span><br><span class="line">	//串口使能函数</span><br><span class="line">	USART_Cmd(USART1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	//打开接收中断</span><br><span class="line">	USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);</span><br><span class="line">	</span><br><span class="line">	//设置相应中断</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannel =	USART1_IRQn;		//设置通道</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;			//开启通道</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 1; //中断优先级分组为2</span><br><span class="line">                                                      //抢占优先级为0.1.2，3都可</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelSubPriority =1;    //子优先级</span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStruct);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void USART1_IRQHandler(void)						//中断服务函数</span><br><span class="line">&#123;</span><br><span class="line">	u8 res;</span><br><span class="line">	if(USART_GetITStatus(USART1,USART_IT_RXNE))		//接收到数据</span><br><span class="line">	&#123;</span><br><span class="line">		res=USART_ReceiveData(USART1);				//读取数据</span><br><span class="line">		USART_SendData(USART1,res);					//发送出去</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	//要使用中断的话要使用NVIC_PriorityGroupConfig函数</span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);	  //设优先级分组为2</span><br><span class="line">	My_USART1_Init();</span><br><span class="line">	while(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>先将程序下载进开发板<br>打开串口调试助手 XCOM V2.6<br>测试成功</p>
<h1 id="外部中断实验"><a href="#外部中断实验" class="headerlink" title="外部中断实验"></a>外部中断实验</h1><h2 id="外部中断概述"><a href="#外部中断概述" class="headerlink" title="外部中断概述"></a>外部中断概述</h2><p>STM32的每个IO都可以作为外部中断输入。<br>STM32的中断控制器支持19个外部中断/事件请求：<br>线0~15：对应外部IO口的输入中断。<br>线16：连接到PVD输出。<br>线17：连接到RTC闹钟事件。<br>线18：连接到USB唤醒事件。</p>
<p>每个外部中断线可以独立的配置触发方式（上升沿，下降沿或者双边沿触发），触发/屏蔽，专用的状态位。</p>
<p>从上面可以看出，STM32供IO使用的中断线只有16个，但是STM32F10x系列的IO口多达上百个，STM32F103ZET6(112),<br>STM32F103RCT6(51)，那么中断线怎么跟io口对应呢？</p>
<p>GPIOx.0映射到EXTI0<br>GPIOx.1映射到EXTI1<br>…<br>GPIOx.15映射到EXTI15</p>
<p>对于每个中断线，我们可以设置相应的触发方式（上升沿触发，下降沿触发，边沿触发）以及使能。</p>
<p>是不是16个中断线就可以分配16个中断服务函数呢？</p>
<p>IO口外部中断在中断向量表中只分配了7个中断向量，也就是只能使用7个中断服务函数<br>外部中断线0<del>4各分配一个中断向量，共五个服务函数<br>外部中断线5</del>9分配一个中断向量，共用一个服务函数<br>外部中断线10~15分配一个中断向量，共用一个中断服务函数。</p>
<p>中断服务函数列表：<br>EXTI0_IRQHandler<br>EXTI1_IRQHandler<br>EXTI2_IRQHandler<br>EXTI3_IRQHandler<br>EXTI4_IRQHandler<br>EXTI9_5_IRQHandler<br>EXTI15_10_IRQHandler    </p>
<h2 id="外部中断常用库函数"><a href="#外部中断常用库函数" class="headerlink" title="外部中断常用库函数"></a>外部中断常用库函数</h2><p>①void GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource);<br>//设置IO口与中断线的映射关系</p>
<p>exp:  GPIO_EXTILineConfig(GPIO_PortSourceGPIOE,GPIO_PinSource2);</p>
<p>②void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct);<br> //初始化中断线：触发方式等</p>
<p>③ITStatus EXTI_GetITStatus(uint32_t EXTI_Line);<br>//判断中断线中断状态，是否发生</p>
<p>④void EXTI_ClearITPendingBit(uint32_t EXTI_Line);<br>//清除中断线上的中断标志位</p>
<h3 id="EXTI-Init函数"><a href="#EXTI-Init函数" class="headerlink" title="EXTI_Init函数"></a>EXTI_Init函数</h3><p>void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  uint32_t EXTI_Line;   //指定要配置的中断线           </span><br><span class="line">  EXTIMode_TypeDef EXTI_Mode;   //模式：事件 OR中断</span><br><span class="line">  EXTITrigger_TypeDef EXTI_Trigger;//触发方式：上升沿/下降沿/双沿触发</span><br><span class="line">  FunctionalState EXTI_LineCmd;  //使能 OR失能</span><br><span class="line">&#125;EXTI_InitTypeDef;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXTI_InitStructure.EXTI_Line=EXTI_Line2;	 </span><br><span class="line">EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;	</span><br><span class="line">EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;</span><br><span class="line">EXTI_InitStructure.EXTI_LineCmd = ENABLE;</span><br><span class="line">EXTI_Init(&amp;EXTI_InitStructure);</span><br></pre></td></tr></table></figure>
<h2 id="外部中断的一般配置步骤："><a href="#外部中断的一般配置步骤：" class="headerlink" title="外部中断的一般配置步骤："></a>外部中断的一般配置步骤：</h2><p>1.初始化IO口为输入。<br>    GPIO_Init();</p>
<p>2.开启IO口复用时钟。<br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);</p>
<p>3.设置IO口与中断线的映射关系。<br>    void GPIO_EXTILineConfig();</p>
<p>4.初始化线上中断，设置触发条件等。<br>    EXTI_Init();</p>
<p>5.配置中断分组（NVIC），并使能中断。<br>    NVIC_Init();</p>
<p>6.编写中断服务函数。<br>    EXTIx_IRQHandler();</p>
<p>7.清除中断标志位<br>    EXTI_ClearITPendingBit();</p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;led.h&quot;</span><br><span class="line">#include &quot;delay.h&quot;</span><br><span class="line">#include &quot;key.h&quot;</span><br><span class="line">#include &quot;sys.h&quot;</span><br><span class="line">#include &quot;beep.h&quot;</span><br><span class="line">#include &quot;usart.h&quot;</span><br><span class="line">#include &quot;exti.h&quot;</span><br><span class="line"></span><br><span class="line"> int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	delay_init();</span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">	uart_init(115200);	//串口初始化为115200</span><br><span class="line">	LED_Init();					//初始化LED</span><br><span class="line">	BEEP_Init();				//初始化蜂鸣器</span><br><span class="line">	KEY_Init();					//初始化按键</span><br><span class="line">	EXTIX_Init();				//初始化外部中断</span><br><span class="line">	LED0=0;							//点亮LED</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">				printf(&quot;OK\n\r&quot;);</span><br><span class="line">				delay_ms(1000);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="看门狗实验"><a href="#看门狗实验" class="headerlink" title="看门狗实验"></a>看门狗实验</h1><h2 id="独立看门狗概述"><a href="#独立看门狗概述" class="headerlink" title="独立看门狗概述"></a>独立看门狗概述</h2><p>为什么要看门狗？<br>在由单片机构成的微型计算机系统中，由于单片机的工作常常会受到来自外界电磁场的干扰，造成程序的跑飞，而陷入死循环，程序的正常运行被打断，由单片机控制的系统无法继续工作，会造成整个系统的陷入停滞状态，发生不可预料的后果，所以出于对单片机运行状态进行实时监测的考虑，便产生了一种专门用于监测单片机程序运行状态的模块或者芯片，俗称“看门狗”(watchdog) 。</p>
<p>看门狗解决的问题是什么？<br>在启动正常运行的时候，系统不能复位。<br>在系统跑飞（程序异常执行）的情况，系统复位，程序重新执行。</p>
<p>STM32内置两个看门狗，提供了更高的安全性，时间的精确性和使用的灵活性。两个看门狗设备（独立看门狗/窗口看门狗)可以用来检测和解决由软件错误引起的故障。当计数器达到给定的超时值时，触发一个中断（仅适用窗口看门狗）或者产生系统复位。<br>独立看门狗（IWDG)由专用的低速时钟（LSI)驱动，即使主时钟发生故障它仍有效。<br>独立看门狗适合应用于需要看门狗作为一个在主程序之外 能够完全独立工作，并且对时间精度要求低的场合。<br>窗口看门狗由从APB1时钟分频后得到时钟驱动。通过可配置的时间窗口来检测应用程序非正常的过迟或过早操作。<br>窗口看门狗最适合那些要求看门狗在精确计时窗口起作用的程序。</p>
<p>独立看门狗功能描述：<br>1.在键值寄存器（IWDG_KR)中写入0xCCCC，开始启用独立看门狗。此时计数器开始从其复位值0xFFF递减，当计数器值计数到尾值0x000时会产生一个复位信号（IWDG_RESET)。<br>2.无论何时，只要在键值寄存器IWDG_KR中写入0xAAAA（通常说的喂狗）, 自动重装载寄存器IWDG_RLR的值就会重新加载到计数器，从而避免看门狗复位。<br>3.如果程序异常，就无法正常喂狗，从而系统复位。</p>
<p>键值寄存器IWDG_KR: 0<del>15位有效<br>预分频寄存器IWDG_PR：0</del>2位有效。具有写保护功能，要操作先取消写保护<br>重装载寄存器IWDG_RLR：0<del>11位有效。具有写保护功能，要操作先取消写保护。<br>状态寄存器IWDG_SR：0</del>1位有效</p>
<p>取消写保护：写入0x5555表示允许访问IWDG_PR和IWDG_RLR寄存器</p>
<h3 id="独立看门狗超时时间"><a href="#独立看门狗超时时间" class="headerlink" title="独立看门狗超时时间"></a>独立看门狗超时时间</h3><p>溢出时间计算：<br>   Tout=((4×2^prer) ×rlr) /40 （M3)</p>
<h2 id="IWDG独立看门狗操作库函数"><a href="#IWDG独立看门狗操作库函数" class="headerlink" title="IWDG独立看门狗操作库函数"></a>IWDG独立看门狗操作库函数</h2><p>void IWDG_WriteAccessCmd(uint16_t IWDG_WriteAccess);//取消写保护：0x5555使能<br>void IWDG_SetPrescaler(uint8_t IWDG_Prescaler);     //设置预分频系数：写PR<br>void IWDG_SetReload(uint16_t Reload);               //设置重装载值：写RLR<br>void IWDG_ReloadCounter(void);                      //喂狗：写0xAAAA到KR<br>void IWDG_Enable(void);                             //使能看门狗：写0xCCCC到KR<br>FlagStatus IWDG_GetFlagStatus(uint16_t IWDG_FLAG);  //状态：重装载/预分频 更新</p>
<p>独立看门狗操作步骤：<br>①  取消寄存器写保护：<br>      IWDG_WriteAccessCmd();<br>②  设置独立看门狗的预分频系数，确定时钟:<br>     IWDG_SetPrescaler();<br>③  设置看门狗重装载值，确定溢出时间:<br>    IWDG_SetReload();<br>④  使能看门狗<br>    IWDG_Enable();<br>⑤  应用程序喂狗:<br>   IWDG_ReloadCounter();</p>
<p>溢出时间计算：<br>   Tout=((4×2^prer) ×rlr) /40 （M3)</p>
<h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><p>#include “led.h”<br>#include “delay.h”<br>#include “key.h”<br>#include “sys.h”<br>#include “beep.h”<br>#include “usart.h”<br>#include “exti.h”<br>#include “wdg.h”<br> int main(void)<br>{<br>    delay_init();<br>    LED_Init();<br>    KEY_Init();<br>    BEEP_Init();</p>
<pre><code>IWDG_Init(4,625);//1s

delay_ms(200);
LED0=0;

while(1)
&#123;
    if(KEY_Scan(0)==WKUP_PRES)
    &#123;
        IWDG_ReloadCounter();
    &#125;
&#125;
</code></pre>
<p>}</p>
<h1 id="TFTLCD显示实验"><a href="#TFTLCD显示实验" class="headerlink" title="TFTLCD显示实验"></a>TFTLCD显示实验</h1><h2 id="TFTLCD驱动原理-TFTLCD简介"><a href="#TFTLCD驱动原理-TFTLCD简介" class="headerlink" title="TFTLCD驱动原理-TFTLCD简介"></a>TFTLCD驱动原理-TFTLCD简介</h2><p>TFTLCD即薄膜晶体管液晶显示器。它与无源TN-LCD、STN-LCD的简单矩阵不同，它在液晶显示屏的每一个像素上都设置有一个薄膜晶体管（TFT），可有效地克服非选通时的串扰，使显示液晶屏的静态特性与扫描线数无关，因此大大提高了图像质量。</p>
<p>TFTLCD具有：亮度好、对比度高、层次感强、颜色鲜艳等特点。是目前最主流的LCD显示器。广泛应用于电视、手机、电脑、平板等各种电子产品。</p>
<p>ATK-4.3寸 TFTLCD模块<br>分辨率：480*800，驱动IC：NT35510，电容触摸屏，16位并口驱动</p>
<h3 id="ALINETEK-2-8寸-TFTLCD接口说明（16位80并口）："><a href="#ALINETEK-2-8寸-TFTLCD接口说明（16位80并口）：" class="headerlink" title="ALINETEK 2.8寸 TFTLCD接口说明（16位80并口）："></a>ALINETEK 2.8寸 TFTLCD接口说明（16位80并口）：</h3><p>注意：DB1<del>DB8，DB10</del>DB17，总是按顺序连接MCU的D0~D15</p>
<p>LCD_CS：LCD片选信号<br>LCD_WR：LCD写信号<br>LCD_RD：LCD读信号<br>DB[17：1]：16位双向数据线。<br>LCD_RST：硬复位LCD信号<br>LCD_RS：命令/数据标志<br>        (0:命令,1:数据)<br>BL_CTR：背光控制信号<br>T_MISO/T_MOSI/T_PEN/T_CS/T_CLK，触摸屏接口信号</p>
<h3 id="ALINETEK-2-8寸-TFTLCD-16位80并口驱动简介"><a href="#ALINETEK-2-8寸-TFTLCD-16位80并口驱动简介" class="headerlink" title="ALINETEK 2.8寸 TFTLCD 16位80并口驱动简介"></a>ALINETEK 2.8寸 TFTLCD 16位80并口驱动简介</h3><p>模块的8080并口读/写的过程为：<br>先根据要写入/读取的数据的类型，设置RS为高（数据）/低（命令），然后拉低片选，选中ILI9341，接着我们根据是读数据，还是要写数据置RD/WR为低，然后：<br>1.读数据：在RD的上升沿， 读取数据线上的数据（D[15:0]）;<br>2.写数据：在WR的上升沿，使数据写入到ILI9341里面</p>
<h3 id="ILI9341-驱动时序"><a href="#ILI9341-驱动时序" class="headerlink" title="ILI9341 驱动时序"></a>ILI9341 驱动时序</h3><p>右图为：ILI9341 8080并口时序，详见：ILI9341_DS.pdf，232页<br>重点时序：<br>读ID低电平脉宽(trdl)<br>读ID高电平脉宽(trdh)<br>读FM低电平脉宽(trdlfm)<br>读FM高电平脉宽(trdhfm)<br>写控制低电平脉宽(twrl)<br>写控制高电平脉宽(twrh)</p>
<p>注意：ID指LCD的ID号<br>FM指帧缓存，即:GRAM </p>
<h3 id="驱动流程"><a href="#驱动流程" class="headerlink" title="驱动流程"></a>驱动流程</h3><p>1.硬复位 LCD_RST=0; delay_ms(100); LCD_RST=1;<br>2.初始化序列→设置坐标<br>2.1写GRAM指令→写入颜色数据→LCD显示<br>2.3读GRAM指令→读出颜色数据→单片机处理</p>
<h3 id="RGB565格式说明"><a href="#RGB565格式说明" class="headerlink" title="RGB565格式说明"></a>RGB565格式说明</h3><p>模块对外接口采用16位并口，颜色深度为16位，格式为RGB565</p>
<table>
<thead>
<tr>
<th>数据线</th>
<th>D15</th>
<th>D14</th>
<th>D13</th>
<th>D12</th>
<th>D11</th>
<th>D10</th>
<th>D9</th>
<th>D8</th>
<th>D7</th>
<th>D6</th>
<th>D5</th>
<th>D4</th>
<th>D3</th>
<th>D2</th>
<th>D1</th>
<th>D0</th>
</tr>
</thead>
<tbody><tr>
<td>LCD GRAM</td>
<td>R[4]</td>
<td>R[3]</td>
<td>R[2]</td>
<td>R[1]</td>
<td>R[0]</td>
<td>G[5]</td>
<td>G[4]</td>
<td>G[3]</td>
<td>G[2]</td>
<td>G[1]</td>
<td>G[0]</td>
<td>B[4]</td>
<td>B[3]</td>
<td>B[2]</td>
<td>B[1]</td>
<td>B[0]</td>
</tr>
</tbody></table>
<p>0xF800=1111 1000 0000 0000 对应R[4]R[3]R[2]R[1]R[0]为1 其余为0 所以是红色 </p>
<h2 id="ILI9341指令格式说明"><a href="#ILI9341指令格式说明" class="headerlink" title="ILI9341指令格式说明"></a>ILI9341指令格式说明</h2><p>ILI9341所有的指令都是8位的（高8位无效），且参数除了读写GRAM的时候是16位，其他操作参数，都是8位的。</p>
<p>ILI9341的指令很多，这里不一一介绍，仅介绍几个重要的指令，他们是：0XD3，0X36，0X2A，0X2B，0X2C，0X2E等6条指令。</p>
<h3 id="0XD3指令"><a href="#0XD3指令" class="headerlink" title="0XD3指令"></a>0XD3指令</h3><p>该指令为读ID4指令，用于读取LCD控制器的ID 。因此，同一个代码，可以根据ID的不同，执行不同的LCD驱动初始化，以兼容不同的LCD屏幕。</p>
<h3 id="0X36指令"><a href="#0X36指令" class="headerlink" title="0X36指令"></a>0X36指令</h3><p>该指令为存储访问控制指令，可以控制ILI9341存储器的读写方向，简单的说，就是在连续写GRAM的时候，可以控制GRAM指针的增长方向，从而控制显示方式（读GRAM也是一样）。</p>
<h3 id="0X2A指令"><a href="#0X2A指令" class="headerlink" title="0X2A指令"></a>0X2A指令</h3><p>该指令是列地址设置指令，在从左到右，从上到下的扫描方式（默认）下面，该指令用于设置横坐标（x坐标）</p>
<h3 id="0X2B指令"><a href="#0X2B指令" class="headerlink" title="0X2B指令"></a>0X2B指令</h3><p>该指令是页地址设置指令，在从左到右，从上到下的扫描方式（默认）下面，该指令用于设置纵坐标（y坐标）</p>
<h3 id="0X2C指令"><a href="#0X2C指令" class="headerlink" title="0X2C指令"></a>0X2C指令</h3><p>该指令是写GRAM指令，在发送该指令之后，我们便可以往LCD的GRAM里面写入颜色数据了，该指令支持连续写 (地址自动递增)</p>
<h3 id="0X2E指令"><a href="#0X2E指令" class="headerlink" title="0X2E指令"></a>0X2E指令</h3><p>该指令是读GRAM指令，用于读取ILI9341的显存（GRAM），同0X2C指令，该指令支持连续读 (地址自动递增)</p>
<h2 id="FSMC简介-FSMC介绍"><a href="#FSMC简介-FSMC介绍" class="headerlink" title="FSMC简介-FSMC介绍"></a>FSMC简介-FSMC介绍</h2><p>FSMC，即灵活的静态存储控制器，能够与同步或异步存储器和16位PC存储器卡连接，STM32的FSMC接口支持包括SRAM、NAND FLASH、NOR FLASH和PSRAM等存储器。FSMC的框图如下图所示：</p>
<p>FSMC驱动外部SRAM时，外部SRAM的控制一般有：地址线（如A0<del>A25）、数据线（如D0</del>D15）、写信号（WE，即WR）、读信号（OE，即RD）、片选信号（CS），如果SRAM支持字节控制，那么还有UB/LB信号。</p>
<h3 id="FSMC驱动LCD的原理"><a href="#FSMC驱动LCD的原理" class="headerlink" title="FSMC驱动LCD的原理"></a>FSMC驱动LCD的原理</h3><p>而TFTLCD的信号我们在前面介绍过，包括：RS、D0<del>D15、WR、RD、CS、RST和BL等，其中真正在操作LCD的时候需要用到的就只有：RS、D0</del>D15、WR、RD和CS。其操作时序和SRAM的控制完全类似，唯一不同就是TFTLCD有RS信号，但是没有地址信号。</p>
<p>TFTLCD通过RS信号来决定传送的数据是数据还是命令，本质上可以理解为一个地址信号，比如我们把RS接在A0上面，那么当FSMC控制器写地址0的时候，会使得A0变为0，对TFTLCD来说，就是写命令。而FSMC写地址1的时候，A0将会变为1，对TFTLCD来说，就是写数据了。这样，就把数据和命令区分开了，他们其实就是对应SRAM操作的两个连续地址。当然RS也可以接在其他地址线上，战舰V3和精英板开发板都是把RS连接在A10上面，而探索者STM32F4把RS接在A6上面。</p>
<p>因此，可以把TFTLCD当成一个SRAM来用，只不过这个SRAM有2个地址，这就是FSMC可以驱动LCD的原理。</p>
<h3 id="存储块1-操作简介"><a href="#存储块1-操作简介" class="headerlink" title="存储块1 操作简介"></a>存储块1 操作简介</h3><p>STM32的FSMC存储块1（Bank1）用于驱动NOR FLASH/SRAM/PSRAM，被分为4个区，每个区管理64M字节空间，每个区都有独立的寄存器对所连接的存储器进行配置。Bank1的256M字节空间由28根地址线（HADDR[27:0]）寻址。<br>这里HADDR，是内部AHB地址总线，其中，HADDR[25:0]来自外部存储器地址FSMC_A[25:0]，而HADDR[26:27]对4个区进行寻址。<br>当Bank1接的是16位宽度存储器的时候：HADDR[25:1] FSMC_A[24:0]<br>当Bank1接的是8位宽度存储器的时候：HADDR[25:0] FSMC_A[25:0]</p>
<p>不论外部接8位/16位宽设备，FSMC_A[0]永远接在外部设备地址A[0]</p>
<p>STM32的FSMC存储块1 支持的异步突发访问模式包括：模式1、模式A~D等多种时序模型，驱动SRAM时一般使用模式1或者模式 A，这里我们使用模式A来驱动LCD（当SRAM用）</p>
<p>模式A支持读写时序分开设置！ 对STM32F4仅写时序DATAST需要+1</p>
<h3 id="FSMC简介-寄存器介绍"><a href="#FSMC简介-寄存器介绍" class="headerlink" title="FSMC简介-寄存器介绍"></a>FSMC简介-寄存器介绍</h3><p>对于NOR FLASH/PSRAM控制器(存储块1)，通过FSMC_BCRx、FSMC_BTRx和FSMC_BWTRx寄存器设置（其中x=1~4，对应4个区）。通过这3个寄存器，可以设置FSMC访问外部存储器的时序参数，拓宽了可选用的外部存储器的速度范围。  </p>
<h4 id="SRAM-NOR闪存片选控制寄存器（FSMC-BCRx）"><a href="#SRAM-NOR闪存片选控制寄存器（FSMC-BCRx）" class="headerlink" title="SRAM/NOR闪存片选控制寄存器（FSMC_BCRx）"></a>SRAM/NOR闪存片选控制寄存器（FSMC_BCRx）</h4><p>EXTMOD：扩展模式使能位，控制是否允许读写不同的时序，需设置为1<br>WREN：写使能位。我们需要向TFTLCD写数据，故该位必须设置为1<br>MWID[1:0]：存储器数据总线宽度。00，表示8位数据模式；01表示16位数据模式；10和11保留。我们的TFTLCD是16位数据线，所以设置WMID[1:0]=01。<br>MTYP[1:0]：存储器类型。00表示SRAM、ROM；01表示PSRAM；10表示NOR FLASH;11保留。我们把LCD当成SRAM用，所以需要设置MTYP[1:0]=00。<br>MBKEN：存储块使能位。需设置为1</p>
<h4 id="SRAM-NOR闪存片选时序寄存器（FSMC-BTRx）"><a href="#SRAM-NOR闪存片选时序寄存器（FSMC-BTRx）" class="headerlink" title="SRAM/NOR闪存片选时序寄存器（FSMC_BTRx）"></a>SRAM/NOR闪存片选时序寄存器（FSMC_BTRx）</h4><p>ACCMOD[1:0]：访问模式。00:模式A；01:模式B；10:模式C；11:模式D。<br>DATAST[7:0]：数据保持时间，等于: DATAST(+1)个HCLK时钟周期，DATAST最大为255。对ILI9341来说，其实就是RD低电平持续时间，最大为355ns。对STM32F1，一个HCLK=13.8ns (1/72M)，设置为15；对STM32F4，一个HCLK=6ns(1/168M) ，设置为60。<br>ADDSET[3:0]：地址建立时间。表示：ADDSET (+1)个HCLK周期，ADDSET最大为15。对ILI9341来说，这里相当于RD高电平持续时间，为90ns。STM32F1的FSMC性能存在问题，即便设置为0，RD也有190ns的高电平，我们这里设置为1。而对STM32F4，则设置为15。 </p>
<h4 id="SRAM-NOR闪存写时序寄存器（FSMC-BWTRx）"><a href="#SRAM-NOR闪存写时序寄存器（FSMC-BWTRx）" class="headerlink" title="SRAM/NOR闪存写时序寄存器（FSMC_BWTRx）"></a>SRAM/NOR闪存写时序寄存器（FSMC_BWTRx）</h4><p>ACCMOD[1:0]：访问模式。00:模式A；01:模式B；10:模式C；11:模式D。<br>DATAST[7:0]：数据保持时间，等于: DATAST(+1)个HCLK时钟周期，DATAST最大为255。对ILI9341来说，其实就是WR低电平持续时间，为15ns，不过ILI9320等则需要50ns。考虑兼容性，对STM32F1，一个HCLK=13.8ns (1/72M)，设置为3；对STM32F4，一个HCLK=6ns(1/168M) ，设置为9。<br>ADDSET[3:0]：地址建立时间。表示：ADDSET+1个HCLK周期，ADDSET最大为15。对ILI9341来说，这里相当于WR高电平持续时间，为15ns。同样考虑兼容ILI9320，对STM32F1，这里即便设置为1，WR也有100ns的高电平，我们这里设置为1。而对STM32F4，则设置为8。 </p>
<h3 id="寄存器组合说明"><a href="#寄存器组合说明" class="headerlink" title="寄存器组合说明"></a>寄存器组合说明</h3><p>在ST官方库提供的的寄存器定义里面，并没有定义FSMC_BCRx、FSMC_BTRx、FSMC_BWTRx等这个单独的寄存器，而是将他们进行了一些组合。规律如下：</p>
<p>FSMC_BCRx和FSMC_BTRx，组合成BTCR[8]寄存器组，他们的对应关系如下：<br>BTCR[0]对应FSMC_BCR1，BTCR[1]对应FSMC_BTR1<br>BTCR[2]对应FSMC_BCR2，BTCR[3]对应FSMC_BTR2<br>BTCR[4]对应FSMC_BCR3，BTCR[5]对应FSMC_BTR3<br>BTCR[6]对应FSMC_BCR4，BTCR[7]对应FSMC_BTR4 </p>
<p>FSMC_BWTRx则组合成BWTR[7]，他们的对应关系如下：<br>BWTR[0]对应FSMC_BWTR1，BWTR[2]对应FSMC_BWTR2，<br>BWTR[4]对应FSMC_BWTR3，BWTR[6]对应FSMC_BWTR4，<br>BWTR[1]、BWTR[3]和BWTR[5]保留，没有用到。</p>
<h2 id="程序函数"><a href="#程序函数" class="headerlink" title="程序函数"></a>程序函数</h2><h3 id="硬件连接"><a href="#硬件连接" class="headerlink" title="硬件连接"></a>硬件连接</h3><p>LCD_BL(背光控制)对应 PB0;<br>LCD_CS 对应 PG12 即 FSMC_NE4;<br>LCD _RS 对应 PG0 即 FSMC_A10;<br>LCD _WR 对应 PD5 即 FSMC_NWE;<br>LCD _RD 对应 PD4 即 FSMC_NOE;<br>LCD _D[15:0]则直接连接在 FSMC_D15~FSMC_D0;</p>
<h3 id="LCD结构体"><a href="#LCD结构体" class="headerlink" title="LCD结构体"></a>LCD结构体</h3><p>//LCD地址结构体<br>typedef struct<br>{<br>        vu16 LCD_REG;<br>        vu16 LCD_RAM;<br>} LCD_TypeDef;<br>//使用NOR/SRAM的 Bank1.sector4,地址位HADDR[27,26]=11 A10作为数据命令区分线<br>//注意设置时STM32内部会右移一位对其!<br>#define LCD_BASE        ((u32)(0x6C000000 | 0x000007FE))<br>#define LCD             ((LCD_TypeDef *) LCD_BASE)</p>
<p>LCD_BASE，须根据外部电路的连接来确定，如Bank1.sector4就是从地址0X6C000000开<br>始，而0X000007FE，则是A10的偏移量。以A10为例，7FE换成二进制为：111 1111 1110<br>，而16位数据时，地址右移一位对齐，对应到地址引脚，就是：A10:A0=011 1111 1111，<br>此时A10是0，但是如果16位地址再加1（对应到8位地址是加2，即7FE+0X02），那么：<br>A10:A0=100 0000 0000，此时A10就是1了，即实现了对RS的0和1的控制。</p>
<p>我们将这个地址强制转换为LCD_TypeDef结构体地址，那么可以得到LCD-&gt;LCD_REG的<br>地址就是0X6C00,07FE，对应A10的状态为0(即RS=0)，而LCD-&gt; LCD_RAM的地址就是<br>0X6C00,0800（结构体地址自增），对应A10的状态为1（即RS=1），从而实现对RS的控<br>制。 </p>
<p>//LCD 重要参数集<br>typedef struct<br>{<br>u16 width; //LCD 宽度<br>u16 height; //LCD 高度<br>u16 id; //LCD ID<br>u8 dir; //横屏还是竖屏控制：0，竖屏；1，横屏。<br>u16 wramcmd; //开始写 gram 指令<br>u16 setxcmd; //设置 x 坐标指令<br>u16 setycmd; //设置 y 坐标指令<br>}_lcd_dev;<br>//LCD 参数<br>extern _lcd_dev lcddev; //管理 LCD 重要参数</p>
<p>cddev结构体参数的赋值，基本上都是在LCD_Display_Dir函数完成</p>
<h3 id="7个底层接口函数："><a href="#7个底层接口函数：" class="headerlink" title="7个底层接口函数："></a>7个底层接口函数：</h3><p>1，写寄存器值函数 ：void LCD_WR_REG(u16 regval)<br>2，写数据函数：void LCD_WR_DATA(u16 data)<br>3，读数据函数：u16 LCD_RD_DATA(void)<br>4，写寄存器内容函数： void LCD_WriteReg(u16 LCD_Reg, u16 LCD_RegValue)<br>5，读寄存器内容函数： u16 LCD_ReadReg(u16 LCD_Reg)<br>6，开始写GRAM函数： void LCD_WriteRAM_Prepare(void)<br>7，写GRAM函数： void LCD_WriteRAM(u16 RGB_Code)</p>
<h3 id="LCD初始化函数伪代码："><a href="#LCD初始化函数伪代码：" class="headerlink" title="LCD初始化函数伪代码："></a>LCD初始化函数伪代码：</h3><p>//LCD初始化<br>void LCD_Init(void)<br>{<br>    初始化GPIO;<br>    初始化FSMC;<br>    读取LCD ID;<br>    printf(“LCD ID:%x\r\n”,lcddev.id);//打印LCD ID，用到了串口1<br>                                        //所以必须初始化串口1，否则黑屏<br>    根据不同的ID执行LCD初始化代码;<br>    LCD_Display_Dir(0);             //默认为竖屏<br>    LCD_LED=1;                 //点亮背光<br>    LCD_Clear(WHITE);            //清屏<br>}</p>
<h3 id="LCD坐标设置函数"><a href="#LCD坐标设置函数" class="headerlink" title="LCD坐标设置函数"></a>LCD坐标设置函数</h3><p>//设置光标位置<br>//Xpos:横坐标<br>//Ypos:纵坐标<br>void LCD_SetCursor(u16 Xpos, u16 Ypos)<br>{<br>     if(lcddev.id==0X9341||lcddev.id==0X5310)<br>     {<br>          LCD_WR_REG(lcddev.setxcmd);<br>          LCD_WR_DATA(Xpos&gt;&gt;8);<br>          LCD_WR_DATA(Xpos&amp;0XFF);<br>          LCD_WR_REG(lcddev.setycmd);<br>     LCD_WR_DATA(Ypos&gt;&gt;8);<br>     LCD_WR_DATA(Ypos&amp;0XFF);<br>     }else if(lcddev.id==XXXX)    //根据不同的LCD型号，执行不同的代码<br>     {<br>     ……//省略部分代码<br>     }<br>}</p>
<h3 id="LCD画点函数"><a href="#LCD画点函数" class="headerlink" title="LCD画点函数"></a>LCD画点函数</h3><p>//画点<br>//x,y:坐标<br>//POINT_COLOR:此点的颜色<br>void LCD_DrawPoint(u16 x,u16 y)<br>{<br>    LCD_SetCursor(x,y);        //设置光标位置<br>    LCD_WriteRAM_Prepare();    //开始写入GRAM<br>    LCD-&gt;LCD_RAM=POINT_COLOR;     //非Mini板的操作方式<br>}</p>
<h3 id="LCD读点函数："><a href="#LCD读点函数：" class="headerlink" title="LCD读点函数："></a>LCD读点函数：</h3><p>u16 LCD_ReadPoint(u16 x,u16 y)</p>
<h3 id="字符显示函数"><a href="#字符显示函数" class="headerlink" title="字符显示函数"></a>字符显示函数</h3><p>//在指定位置显示一个字符<br>//x,y:起始坐标<br>//num:要显示的字符:” “—&gt;”~”<br>//size:字体大小 12/16/24<br>//mode:叠加方式(1)还是非叠加方式(0) 叠加方式的意思是保持底色不变<br>void LCD_ShowChar(u16 x,u16 y,u8 num,u8 size,u8 mode)<br>{<br>       u8 temp,t1,t;<br>       u16 y0=y;<br>       u8 csize=(size/8+((size%8)?1:0))*(size/2);    //得到字体一个字符对应点阵集所占的字节数<br>       num=num-‘ ‘;    //得到偏移后的值（ASCII字库是从空格开始取模，所以-‘ ‘就是对应字符的字库）<br>       for(t=0;t&lt;csize;t++)<br>       {<br>if(size==12)temp=asc2_1206[num][t];         //调用1206字体<br>             else if(size==16)temp=asc2_1608[num][t];    //调用1608字体<br>             else if(size==24)temp=asc2_2412[num][t];    //调用2412字体<br>             else return;            //没有的字库<br>             for(t1=0;t1&lt;8;t1++)<br>             {<br>      if(temp&amp;0x80)LCD_Fast_DrawPoint(x,y,POINT_COLOR);<br>      else if(mode==0)LCD_Fast_DrawPoint(x,y,BACK_COLOR);<br>                    temp&lt;&lt;=1;<br>                    y++;<br>                    if(y&gt;=lcddev.height)return;        //超区域了<br>                    if((y-y0)==size)<br>                    {<br>    y=y0;<br>    x++;<br>    if(x&gt;=lcddev.width)return;        //超区域了<br>    break;<br>                     }<br>              }<br>        }<br>} </p>
<h3 id="字符码表"><a href="#字符码表" class="headerlink" title="字符码表"></a>字符码表</h3><p>const unsigned char oled_asc2_1206[95][12]={<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/<em>“ “,0</em>/<br>{0x00,0x00,0x00,0x00,0x3F,0x40,0x00,0x00,0x00,0x00,0x00,0x00},/<em>“!”,1</em>/<br>……<br>{0x40,0x00,0x80,0x00,0x40,0x00,0x20,0x00,0x20,0x00,0x40,0x00},/<em>“~”,94</em>/<br>};</p>
<p>const unsigned char oled_asc2_1608[95][16]={<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/<em>“ “,0</em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xCC,0x00,0x0C,0x00,0x00,0x00,0x00,0x00,0x00},/<em>“!”,1</em>/<br>……<br>{0x00,0x00,0x60,0x00,0x80,0x00,0x80,0x00,0x40,0x00,0x40,0x00,0x20,0x00,0x20,0x00},/<em>“~”,94</em>/<br>}</p>
<p>const unsigned char oled_asc2_2412[95][36]={<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/<em>“ “,0</em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x80,0x38,0x0F,0xFE,0x38,0x0F,0x80,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/<em>“!”,1</em>/<br>……<br>{0x00,0x00,0x00,0x18,0x00,0x00,0x60,0x00,0x00,0x40,0x00,0x00,0x40,0x00,0x00,0x20,0x00,0x00,0x10,0x00,0x00,0x08,0x00,0x00,0x04,0x00,0x00,0x04,0x00,0x00,0x0C,0x00,0x00,0x10,0x00,0x00},/<em>“~”,94</em>/<br>}</p>
<h2 id="字符生产方式"><a href="#字符生产方式" class="headerlink" title="字符生产方式"></a>字符生产方式</h2><p>用软件PCtoLCD软件<br>配置：<br>点阵格式：阴码<br>取模方式：逐列式<br>取模走向：顺向<br>自定义格式： C51格式</p>
<p>输出方式是从上到下从左到右</p>
<h1 id="温度传感器实验"><a href="#温度传感器实验" class="headerlink" title="温度传感器实验"></a>温度传感器实验</h1><h2 id="DS18B20介绍"><a href="#DS18B20介绍" class="headerlink" title="DS18B20介绍"></a>DS18B20介绍</h2><h3 id="DS18B20技术性能特征："><a href="#DS18B20技术性能特征：" class="headerlink" title="DS18B20技术性能特征："></a>DS18B20技术性能特征：</h3><p>①独特的单总线接口方式，DS18B20在与微处理器连接时仅需要一条口线即可实现微处理器与DS18B20的双向通讯。大大提高了系统的抗干扰性。<br>②测温范围 －55℃～+125℃，精度为±0．5℃。<br>③支持多点组网功能，多个DS18B20可以并联在唯一的三线上，最多只能并联8个，<br>实现多点测温，如果数量过多，会使供电电源电压过低，从而造成信号传输的不稳定。<br>④工作电源: 3.0<del>5.5V/DC （可以数据线寄生电源）。<br>⑤在使用中不需要任何外围元件。<br>⑥测量结果以9</del>12位数字量方式串行传送。</p>
<h3 id="DS18B20封装"><a href="#DS18B20封装" class="headerlink" title="DS18B20封装"></a>DS18B20封装</h3><p>见PPT</p>
<h1 id="光敏传感器实验"><a href="#光敏传感器实验" class="headerlink" title="光敏传感器实验"></a>光敏传感器实验</h1><h2 id="光敏传感器简介"><a href="#光敏传感器简介" class="headerlink" title="光敏传感器简介"></a>光敏传感器简介</h2><p>光敏传感器是最常见的传感器之一，它的种类繁多，主要有：光电管、光电倍增管、光敏电阻、光敏三极管、太阳能电池、红外线传感器、紫外线传感器、光纤式光电传感器、色彩传感器、CCD和CMOS图像传感器等。光传感器是目前产量最多、应用最广的传感器之一，它在自动控制和非电量电测技术中占有非常重要的地位。</p>
<p>光敏传感器是利用光敏元件将光信号转换为电信号的传感器，它的敏感波长在可见光波长附近，包括红外线波长和紫外线波长。光传感器不只局限于对光的探测，它还可以作为探测元件组成其他传感器，对许多非电量进行检测，只要将这些非电量转换为光信号的变化即可</p>
<p>光敏二极管也叫光电二极管。光敏二极管与半导体二极管在结构上是类似的,其管芯是一个具有光敏特征的PN结，具有单向导电性，因此工作时需加上反向电压。无光照时，有很小的饱和反向漏电流，即暗电流，此时光敏二极管截止。当受到光照时,饱和反向漏电流大大增加，形成光电流,它随入射光强度的变化而变化。当光线照射PN结时，可以使PN结中产生电子一空穴对，使少数载流子的密度增加。这些载流子在反向电压下漂移，使反向电流增加。因此可以利用光照强弱来改变电路中的电流。<br>简而言之：照射光敏二极管的光强不同，通过光敏二极管的电流大小就不同，所以可以通过检测电流大小，达到检测光强的目的。</p>
<p>利用这个电流变化，我们串接一个电阻，就可以转换成电压的变化，从而通过ADC读取电压值，判断外部光线的强弱。</p>
<h2 id="硬件连接-1"><a href="#硬件连接-1" class="headerlink" title="硬件连接"></a>硬件连接</h2><p>光敏二极管串联一个电阻连接到VCC，一端接地<br>无光照时，光敏二极管两端无电流通过，电阻左边结点的电压V节点=Vcc<br>有光照时，设通过光么二极管的电流为I，光敏二极管电阻为R，电阻左边结点的电压V节点=Vcc-IR<br>可以看出，V节点与I成反比，即光强越小,I越小，V节点越大<br>我们通过ADC来测量V节点的大小，从而达到检测光强的目的。<br>ADC连接到PF8（ADC3的通道6）</p>
<h1 id="触摸屏实验"><a href="#触摸屏实验" class="headerlink" title="触摸屏实验"></a>触摸屏实验</h1><p>触摸屏（touch screen）又称为“触控屏”、“触控面板”，是一种可接收触头等输入讯号的感应式装置。作为一种新型的电脑输入设备，可以用来取代传统的机械按键等输入设备。它是目前最简单、方便、自然的一种人机交互方式。主要应用于公共信息的查询、领导办公、工业控制、军事指挥、电子游戏、点歌点菜、多媒体教学、房地产预售等。</p>
<p>触摸屏本质上与液晶是分离的。触摸屏负责的是检测触摸点，液晶屏负责的是显示。区别开来。<br>触摸屏一般覆盖在液晶屏上</p>
<p>按照触摸屏的工作原理和传输信息的介质，把触摸屏分为四种，它们分别为<br>电阻式：定位准确，单点触摸。<br>电容感应式：支持多点触摸，价格偏贵。工业应用最广泛<br>红外线式：价格低廉，但其外框易碎，容易产生光干扰，曲面情况下失真。<br>表面声波式：解决各种缺点，但是屏幕表面如果有水滴和尘土会使触摸屏变的迟钝。</p>
<h2 id="电容触摸屏"><a href="#电容触摸屏" class="headerlink" title="电容触摸屏"></a>电容触摸屏</h2><p>电容屏是利用人体感应进行触点检测控制，只需要轻微接触，通过检测感应电流来定位触摸坐标。现在几乎所有智能手机，包括平板电脑都是采用电容屏作为触摸屏。</p>
<p>电容型触摸屏分类<br>表面电容式电容触摸屏：<br>    表面电容式触摸屏技术是利用ITO(铟锡氧化物，是一种透明的导电材料)导电膜，通过电场感应方式感测屏幕表面的触摸行为进行。但是表面电容式触摸屏有一些局限性，它只能识别一个手指或者一次触摸。</p>
<p>投射式电容触摸屏<br>   投射电容式触摸屏是传感器利用触摸屏电极发射出静电场线。一般用于投射电容传感技术的电容类型有两种：自我电容和交互电容。</p>
<p>自我电容式<br>自我电容又称绝对电容，是最广为采用的一种方法，自我电容通常是指扫描电极与地构成的电容。在玻璃表面有用ITO制成的横向与纵向的扫描电极，这些电极和地之间就构成一个电容的两极。当用手或触摸笔触摸的时候就会并联一个电容到电路中去，从而使在该条扫描线上的总体的电容量有所改变。在扫描的时候，控制IC依次扫描纵向和横向电极，并根据扫描前后的电容变化来确定触摸点坐标位置。笔记本电脑触摸输入板就是采用的这种方式，笔记本电脑的输入板采用X*Y的传感电极阵列形成一个传感格子，当手指靠近触摸输入板时，在手指和传感电极之间产生一个小量电荷。采用特定的运算法则处理来自行、列传感器的信号来确定手指的位置。 </p>
<p>交互电容式<br>交互电容又叫做跨越电容，它是在玻璃表面的横向和纵向的ITO电极的交叉处形成电容。交互电容的扫描方式就是扫描每个交叉处的电容变化，来判定触摸点的位置。当触摸的时候就会影响到相邻电极的耦合，从而改变交叉处的电容量，交互电容的扫面方法可以侦测到每个交叉点的电容值和触摸后电容变化，因而它需要的扫描时间与自我电容的扫描方式相比要长一些，需要扫描检测X*Y根电极。目前智能手机/平板电脑等的触摸屏，都是采用交互电容技术。</p>
<p>本实验所选择的电容触摸屏，也是采用的是投射式电容屏（交互电容类型）。<br>透射式电容触摸屏采用纵横两列电极组成感应矩阵，来感应触摸。以两个交叉的电极矩阵，即： X轴电极和Y轴电极，来检测每一格感应单元的电容变化</p>
<h2 id="电阻屏与电容屏的区别"><a href="#电阻屏与电容屏的区别" class="headerlink" title="电阻屏与电容屏的区别"></a>电阻屏与电容屏的区别</h2><p>电阻屏在触模时需要轻触压按，而电容屏只需轻微的手指触碰就能激活</p>
<p>电阻屏可以用任何物体来触摸，而电容屏是人体热感应工作原理，只能用手指的热感区来触摸，指甲和手写笔均无效。由于手指头的面积比手写笔大很多，因此电容屏的手机，触摸比较小图标或者菜单的时候，触摸精度无法做到电阻屏那么高。</p>
<p>电容屏可以很容易进行多点触摸，电阻屏一般不能实现多点触摸的。</p>
<p>电阻屏内部是软的，一般是在4到5层超薄的钢化玻璃中间夹杂细微的炭粒（显微镜下才能看见），通过按压导致上下两层的炭粒相互接触而接通触屏电路，产生触摸反应，容易产生划痕，易坏，容易触屏不灵，而电容屏都是采用单层加厚钢化玻璃，硬度大，耐旧，使用寿长</p>
<p>电阻屏在阳光下可视性稍差，电容屏则非常好，在阳光下可视性很强</p>
<p>电容触摸屏对工作环境的要求是比较高的，在潮湿、多尘、高低温环境下面，都是不适合使用电容屏的。</p>
<p>电容屏优缺点总结</p>
<p>优点：<br>       手感好，无需校准，支持多点触摸，透光性好。<br>缺点：<br>       成本高，精度不高，抗干扰能力差。</p>
<h2 id="触摸屏原理"><a href="#触摸屏原理" class="headerlink" title="触摸屏原理"></a>触摸屏原理</h2><p>电容触摸屏一般都需要一个驱动IC来检测电容触摸，且一般是通过IIC接口输出触摸数据的<br>常见的2种电容触摸屏驱动IC<br>GT9147：采用17<em>10的驱动结构（10个感应通道，17个驱动通道）。（用这个）<br>OTT2001A：采用13</em>8的驱动结构（8个感应通道，13个驱动通道）<br>它们与MCU连接通过4根线：SDA、SCL、RST和INT</p>
<p>GT9147的IIC地址，可以是0X14或者0X5D，当复位结束后的5ms内，如果INT是高电平，则使用0X14作为地址，否则使用0X5D作为地址，具体的设置过程，请看：GT9147数据手册.pdf这个文档。本章我们使用0X14作为器件地址（不含最低位，换算成读写命令则是读：0X29，写：0X28）</p>
<p>GT9147关键寄存器：</p>
<p>控制命令寄存器（0X8040）<br>该寄存器可以写入不同值，实现不同的控制，我们一般使用0和2这两个值，写入2，即可软复位GT9147，在硬复位之后，一般要往该寄存器写2，实行软复位。然后，写入0，即可正常读取坐标数据（并且会结束软复位）。</p>
<p>配置寄存器组（0X8047~0X8100）<br>这里共186个寄存器，用于配置GT9147的各个参数，这些配置一般由厂家提供给我们（一个数组），所以我们只需要将厂家给我们的配置，写入到这些寄存器里面，即可完成GT9147的配置。</p>
<p>产品ID寄存器（0X8140~0X8143）<br>     这里总共由4个寄存器组成，用于保存产品ID，对于GT9147，这4个寄存器读出来就是：9，1，4，7四个字符（ASCII码格式）。因此，我们可以通过这4个寄存器的值，来判断驱动IC的型号，从而判断是OTT2001A还是GT9147，以便执行不同的初始化。</p>
<p>状态寄存器（0X814E）</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>bit7</th>
<th>bit6</th>
<th>bit5</th>
<th>bit4</th>
<th>bit3</th>
<th>bit2</th>
<th>bit1</th>
<th>bit0</th>
</tr>
</thead>
<tbody><tr>
<td>0X814E</td>
<td>buffer状态</td>
<td>大点</td>
<td>接近有效</td>
<td>按键</td>
<td>有效触点个数</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>我们仅关心最高位和最低4位，最高位用于表示buffer状态，如果有数据（坐标/按键），buffer就会是1，最低4位用于表示有效触点的个数，范围是：0~5，0，表示没有触摸，5表示有5点触摸。</p>
<p>坐标数据寄存器（共30个）<br>这里共分成5组（5个点），每组6个寄存器存储数据，以触点1的坐标数据寄存器组为例，</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>bit7~0</th>
<th>寄存器</th>
<th>bit7~0</th>
</tr>
</thead>
<tbody><tr>
<td>0X8150</td>
<td>触点1 x坐标低8位</td>
<td>0X8151</td>
<td>触点1 x坐标高8位</td>
</tr>
<tr>
<td>0X8152</td>
<td>触点1 y坐标低8位</td>
<td>0X8153</td>
<td>触点1 y坐标高8位</td>
</tr>
<tr>
<td>0X8154</td>
<td>触点1 触摸尺寸低8位</td>
<td>0X8155</td>
<td>触点1 触摸尺寸高8位</td>
</tr>
</tbody></table>
<h2 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h2><p>ctiic.c是电容触摸屏的底层驱动结构，基本和myiic.c中内容差不多<br>touch.c是电容触摸屏的入口，会根据入口参数判断型号进行初始化<br>gt9147.c是驱动ic的</p>
<h3 id="touch-c中"><a href="#touch-c中" class="headerlink" title="touch.c中"></a>touch.c中</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u8 TP_Init(void)</span><br><span class="line">&#123;	</span><br><span class="line">	if(lcddev.id==0X5510)				//4.3寸电容触摸屏</span><br><span class="line">	&#123;</span><br><span class="line">		if(GT9147_Init()==0)			//是GT9147</span><br><span class="line">		&#123; </span><br><span class="line">			tp_dev.scan=GT9147_Scan;	//扫描函数指向GT9147触摸屏扫描</span><br><span class="line">		&#125;else</span><br><span class="line">		&#123;</span><br><span class="line">			OTT2001A_Init();</span><br><span class="line">			tp_dev.scan=OTT2001A_Scan;	//扫描函数指向OTT2001A触摸屏扫描</span><br><span class="line">		&#125;</span><br><span class="line">		tp_dev.touchtype|=0X80;			//电容屏 </span><br><span class="line">		tp_dev.touchtype|=lcddev.dir&amp;0X01;//横屏还是竖屏 </span><br><span class="line">		return 0;</span><br><span class="line">	&#125;else if(lcddev.id==0X1963)			//7寸电容触摸屏</span><br><span class="line">	&#123;</span><br><span class="line">		FT5206_Init();</span><br><span class="line">		tp_dev.scan=FT5206_Scan;		//扫描函数指向GT9147触摸屏扫描		</span><br><span class="line">		tp_dev.touchtype|=0X80;			//电容屏 </span><br><span class="line">		tp_dev.touchtype|=lcddev.dir&amp;0X01;//横屏还是竖屏 </span><br><span class="line">		return 0;</span><br><span class="line">	&#125;else</span><br><span class="line">	&#123;</span><br><span class="line">		GPIO_InitTypeDef GPIO_Initure;</span><br><span class="line"></span><br><span class="line">		__HAL_RCC_GPIOB_CLK_ENABLE();           	//开启GPIOB时钟</span><br><span class="line">		__HAL_RCC_GPIOF_CLK_ENABLE();           	//开启GPIOF时钟</span><br><span class="line">		</span><br><span class="line">		//PB1</span><br><span class="line">		GPIO_Initure.Pin=GPIO_PIN_1; 				//PB1</span><br><span class="line">		GPIO_Initure.Mode=GPIO_MODE_OUTPUT_PP;  	//推挽输出</span><br><span class="line">		GPIO_Initure.Pull=GPIO_PULLUP;          	//上拉</span><br><span class="line">		GPIO_Initure.Speed=GPIO_SPEED_FREQ_HIGH;    //高速</span><br><span class="line">		HAL_GPIO_Init(GPIOB,&amp;GPIO_Initure);</span><br><span class="line">	</span><br><span class="line">		//PB2</span><br><span class="line">		GPIO_Initure.Pin=GPIO_PIN_2; 				//PB2</span><br><span class="line">		GPIO_Initure.Mode=GPIO_MODE_INPUT;  		//上拉输入</span><br><span class="line">		HAL_GPIO_Init(GPIOB,&amp;GPIO_Initure);</span><br><span class="line">		</span><br><span class="line">		//PF9,11</span><br><span class="line">		GPIO_Initure.Pin=GPIO_PIN_9|GPIO_PIN_11; 	//PF9,11</span><br><span class="line">		GPIO_Initure.Mode=GPIO_MODE_OUTPUT_PP;  	//推挽输出</span><br><span class="line">		HAL_GPIO_Init(GPIOF,&amp;GPIO_Initure);</span><br><span class="line">		</span><br><span class="line">		//PF10</span><br><span class="line">		GPIO_Initure.Pin=GPIO_PIN_10; 				//PF10</span><br><span class="line">		GPIO_Initure.Mode=GPIO_MODE_INPUT;  		//输入</span><br><span class="line">		GPIO_Initure.Pull=GPIO_PULLUP;          	//上拉</span><br><span class="line">		HAL_GPIO_Init(GPIOF,&amp;GPIO_Initure);</span><br><span class="line"></span><br><span class="line">		TP_Read_XY(&amp;tp_dev.x[0],&amp;tp_dev.y[0]);//第一次读取初始化	 </span><br><span class="line">		AT24CXX_Init();			//初始化24CXX</span><br><span class="line">		if(TP_Get_Adjdata())return 0;//已经校准</span><br><span class="line">		else			  		//未校准?</span><br><span class="line">		&#123; 										    </span><br><span class="line">			LCD_Clear(WHITE);	//清屏</span><br><span class="line">			TP_Adjust();  		//屏幕校准  </span><br><span class="line">		&#125;			</span><br><span class="line">		TP_Get_Adjdata();	</span><br><span class="line">	&#125;</span><br><span class="line">	return 1; 									 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中if(<br>lcddev.id==0X5510)是来判断是否是4.3寸电容触摸屏<br>if(GT9147_Init()==0)以9147的方法初始化，看能否正确运行<br>能正确运行的话执行tp_dev.scan=GT9147_Scan;<br>tp_dev是一个_m_tp_dev类型的结构体<br>这个结构体很重要，看一下它的定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct </span><br><span class="line">&#123;</span><br><span class="line">	u8 (*init)(void);			//初始化触摸屏控制器</span><br><span class="line">	u8 (*scan)(u8);				//扫描触摸屏.0,屏幕扫描;1,物理坐标;	 </span><br><span class="line">	void (*adjust)(void);		//触摸屏校准 </span><br><span class="line">	u16 x[CT_MAX_TOUCH]; 		//当前坐标</span><br><span class="line">	u16 y[CT_MAX_TOUCH];		//电容屏有最多5组坐标,电阻屏则用x[0],y[0]代表:此次扫描时,触屏的坐标,用</span><br><span class="line">								//x[4],y[4]存储第一次按下时的坐标. </span><br><span class="line">	u8  sta;					//笔的状态 </span><br><span class="line">								//b7:按下1/松开0; </span><br><span class="line">	                            //b6:0,没有按键按下;1,有按键按下. </span><br><span class="line">								//b5:保留</span><br><span class="line">								//b4~b0:电容触摸屏按下的点数(0,表示未按下,1表示按下)</span><br><span class="line">/////////////////以下为电阻触摸屏校准参数(电容屏不需要校准)//////////////////////								</span><br><span class="line">	float xfac;					</span><br><span class="line">	float yfac;</span><br><span class="line">	short xoff;</span><br><span class="line">	short yoff;	   </span><br><span class="line">//新增的参数,当触摸屏的左右上下完全颠倒时需要用到.</span><br><span class="line">//b0:0,竖屏(适合左右为X坐标,上下为Y坐标的TP)</span><br><span class="line">//   1,横屏(适合左右为Y坐标,上下为X坐标的TP) </span><br><span class="line">//b1~6:保留.</span><br><span class="line">//b7:0,电阻屏</span><br><span class="line">//   1,电容屏 </span><br><span class="line">	u8 touchtype;</span><br><span class="line">&#125;_m_tp_dev;</span><br></pre></td></tr></table></figure>
<p>CT_MAX_TOUCH是允许同时触摸的最大点数<br>tp_dev的具体定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_m_tp_dev tp_dev=</span><br><span class="line">&#123;</span><br><span class="line">	TP_Init,                //初始化函数</span><br><span class="line">	TP_Scan,                //扫描函数</span><br><span class="line">	TP_Adjust,              //校准函数</span><br><span class="line">	0,</span><br><span class="line">	0, </span><br><span class="line">	0,</span><br><span class="line">	0,</span><br><span class="line">	0,</span><br><span class="line">	0,	  	 		</span><br><span class="line">	0,</span><br><span class="line">	0,	  	 		</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以tp_dev.scan=GT9147_Scan;的实际作用是： 扫描函数指向GT9147触摸屏扫描函数</p>
<h3 id="gt9147-c中"><a href="#gt9147-c中" class="headerlink" title="gt9147.c中"></a>gt9147.c中</h3><p>u8 GT9147_Send_Cfg(u8 mode)                 写配置文件<br>u8 GT9147_WR_Reg(u16 reg,u8 *buf,u8 len)    读寄存器<br>gt9147中比较重要的是扫描函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u8 GT9147_Scan(u8 mode)</span><br><span class="line">&#123;</span><br><span class="line">	u8 buf[4];</span><br><span class="line">	u8 i=0;</span><br><span class="line">	u8 res=0;</span><br><span class="line">	u8 temp;</span><br><span class="line">	u8 tempsta;</span><br><span class="line"> 	static u8 t=0;//控制查询间隔,从而降低CPU占用率   </span><br><span class="line">	t++;</span><br><span class="line">	if((t%10)==0||t&lt;10)//空闲时,每进入10次TP_Scan函数才检测1次,从而节省CPU使用率</span><br><span class="line">	&#123;</span><br><span class="line">		GT9147_RD_Reg(GT_GSTID_REG,&amp;mode,1);	//读取触摸点的状态  </span><br><span class="line"> 		if(mode&amp;0X80&amp;&amp;((mode&amp;0XF)&lt;6))</span><br><span class="line">		&#123;</span><br><span class="line">			temp=0;</span><br><span class="line">			GT9147_WR_Reg(GT_GSTID_REG,&amp;temp,1);//清标志 		</span><br><span class="line">		&#125;		</span><br><span class="line">		if((mode&amp;0XF)&amp;&amp;((mode&amp;0XF)&lt;6))</span><br><span class="line">		&#123;</span><br><span class="line">			temp=0XFF&lt;&lt;(mode&amp;0XF);		//将点的个数转换为1的位数,匹配tp_dev.sta定义 </span><br><span class="line">			tempsta=tp_dev.sta;			//保存当前的tp_dev.sta值</span><br><span class="line">			tp_dev.sta=(~temp)|TP_PRES_DOWN|TP_CATH_PRES; </span><br><span class="line">			tp_dev.x[4]=tp_dev.x[0];	//保存触点0的数据</span><br><span class="line">			tp_dev.y[4]=tp_dev.y[0];</span><br><span class="line">			for(i=0;i&lt;5;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				if(tp_dev.sta&amp;(1&lt;&lt;i))	//触摸有效?</span><br><span class="line">				&#123;</span><br><span class="line">					GT9147_RD_Reg(GT9147_TPX_TBL[i],buf,4);	//读取XY坐标值</span><br><span class="line">					if(tp_dev.touchtype&amp;0X01)//横屏</span><br><span class="line">					&#123;</span><br><span class="line">						tp_dev.y[i]=((u16)buf[1]&lt;&lt;8)+buf[0];</span><br><span class="line">						tp_dev.x[i]=800-(((u16)buf[3]&lt;&lt;8)+buf[2]);</span><br><span class="line">					&#125;else</span><br><span class="line">					&#123;</span><br><span class="line">						tp_dev.x[i]=((u16)buf[1]&lt;&lt;8)+buf[0];</span><br><span class="line">						tp_dev.y[i]=((u16)buf[3]&lt;&lt;8)+buf[2];</span><br><span class="line">					&#125;  </span><br><span class="line">					//printf(&quot;x[%d]:%d,y[%d]:%d\r\n&quot;,i,tp_dev.x[i],i,tp_dev.y[i]);</span><br><span class="line">				&#125;			</span><br><span class="line">			&#125; </span><br><span class="line">			res=1;</span><br><span class="line">			if(tp_dev.x[0]&gt;lcddev.width||tp_dev.y[0]&gt;lcddev.height)//非法数据(坐标超出了)</span><br><span class="line">			&#123; </span><br><span class="line">				if((mode&amp;0XF)&gt;1)		//有其他点有数据,则复第二个触点的数据到第一个触点.</span><br><span class="line">				&#123;</span><br><span class="line">					tp_dev.x[0]=tp_dev.x[1];</span><br><span class="line">					tp_dev.y[0]=tp_dev.y[1];</span><br><span class="line">					t=0;				//触发一次,则会最少连续监测10次,从而提高命中率</span><br><span class="line">				&#125;else					//非法数据,则忽略此次数据(还原原来的)  </span><br><span class="line">				&#123;</span><br><span class="line">					tp_dev.x[0]=tp_dev.x[4];</span><br><span class="line">					tp_dev.y[0]=tp_dev.y[4];</span><br><span class="line">					mode=0X80;		</span><br><span class="line">					tp_dev.sta=tempsta;	//恢复tp_dev.sta</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;else t=0;					//触发一次,则会最少连续监测10次,从而提高命中率</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if((mode&amp;0X8F)==0X80)//无触摸点按下</span><br><span class="line">	&#123; </span><br><span class="line">		if(tp_dev.sta&amp;TP_PRES_DOWN)	//之前是被按下的</span><br><span class="line">		&#123;</span><br><span class="line">			tp_dev.sta&amp;=~(1&lt;&lt;7);	//标记按键松开</span><br><span class="line">		&#125;else						//之前就没有被按下</span><br><span class="line">		&#123; </span><br><span class="line">			tp_dev.x[0]=0xffff;</span><br><span class="line">			tp_dev.y[0]=0xffff;</span><br><span class="line">			tp_dev.sta&amp;=0XE0;	//清除点有效标记	</span><br><span class="line">		&#125;	 </span><br><span class="line">	&#125; 	</span><br><span class="line">	if(t&gt;240)t=10;//重新从10开始计数</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先状态寄存器的bit7会置1表示启用了<br>bit4~bit0表示有效触点个数范围是0个(00000)到5个(11111)</p>
<p>由于头文件中已经宏定义<br>#define GT_GSTID_REG     0X814E<br>0X814E又是状态寄存器<br>所以<br>GT9147_RD_Reg(GT_GSTID_REG,&amp;mode,1);<br>的作用是读取触点的状态<br>if(mode&amp;0X80&amp;&amp;((mode&amp;0XF)&lt;6))中<br>mode&amp;0X80得到最高位<br>mode&amp;0XF可以得到低四位 表示最高位有1，且有触摸</p>
<p>具体处理过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">temp=0XFF&lt;&lt;(mode&amp;0XF);		//将点的个  数转换为1的位数,匹配tp_dev.sta定义 </span><br><span class="line">                            //mode取低四位，假入取了后转化为十进制是5，然后1111 1111左移5位</span><br><span class="line">                            //得到tempt==1110 0000</span><br><span class="line"></span><br><span class="line">tempsta=tp_dev.sta;			//保存当前的tp_dev.sta值 sta表示笔的状态</span><br><span class="line">                            //bit4~bit0 哪一位为1就表示按下</span><br><span class="line">                            //比如00010表示bit1被按下</span><br><span class="line"></span><br><span class="line">tp_dev.sta=(~temp)|TP_PRES_DOWN|TP_CATH_PRES; </span><br><span class="line">                            //取反temp得到 0001 1111</span><br><span class="line">                            //同如有4个点按下会得到 0000 1111</span><br><span class="line">                            //3个点0000 0111 ····</span><br><span class="line">// #define TP_PRES_DOWN 0x80  	表示触屏被按下	  </span><br><span class="line">// #define TP_CATH_PRES 0x40  	表示按键被按下 </span><br><span class="line">//则tp_dev.sta==0001 1111|1000 0000|0100 0000</span><br><span class="line">//保证了最高位和次高位都是1</span><br><span class="line">//此时笔的状态是tp_dev.sta==1101 1111</span><br><span class="line">//参考刚刚结构体中的定义看看具体含义</span><br><span class="line">//u8  sta;					    //笔的状态 </span><br><span class="line">								//b7:按下1/松开0; </span><br><span class="line">	                            //b6:0,没有按键按下;1,有按键按下. </span><br><span class="line">								//b5:保留</span><br><span class="line">								//b4~b0:电容触摸屏按下的点数(0,表示未按下,1表示按下)</span><br><span class="line"></span><br><span class="line">tp_dev.x[4]=tp_dev.x[0];	//保存触点0的数据</span><br><span class="line">tp_dev.y[4]=tp_dev.y[0];</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(i=0;i&lt;5;i++)</span><br><span class="line">&#123;</span><br><span class="line">    if(tp_dev.sta&amp;(1&lt;&lt;i))	//sta触摸有效?sta是低5位的</span><br><span class="line">                            //1&lt;&lt;i可以分别得到 00001 00010 00100 01000 10000</span><br><span class="line">                            //再和tp_dev.sta相与可以判断该位置的触点是否按下</span><br><span class="line">    &#123;</span><br><span class="line">		GT9147_RD_Reg(GT9147_TPX_TBL[i],buf,4);	//读取XY坐标值</span><br><span class="line">                            //数组GT9147_TPX_TBL[5]中分别存储了</span><br><span class="line">                            //第一个到第五个触摸点数据地址</span><br><span class="line">		if(tp_dev.touchtype&amp;0X01)//横屏</span><br><span class="line">		&#123;</span><br><span class="line">			tp_dev.y[i]=((u16)buf[1]&lt;&lt;8)+buf[0];</span><br><span class="line">			tp_dev.x[i]=800-(((u16)buf[3]&lt;&lt;8)+buf[2]);</span><br><span class="line">		&#125;</span><br><span class="line">        else</span><br><span class="line">		&#123;</span><br><span class="line">			tp_dev.x[i]=((u16)buf[1]&lt;&lt;8)+buf[0];</span><br><span class="line">			tp_dev.y[i]=((u16)buf[3]&lt;&lt;8)+buf[2];</span><br><span class="line">		&#125;</span><br><span class="line">        //上面这个if else分支作用是在确定有出点按下后找到该触点的横纵坐标</span><br><span class="line">        //然后存储到结构体tp_dev的数组中</span><br><span class="line"></span><br><span class="line">		//printf(&quot;x[%d]:%d,y[%d]:%d\r\n&quot;,i,tp_dev.x[i],i,tp_dev.y[i]);</span><br><span class="line">	&#125;			</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(tp_dev.x[0]&gt;lcddev.width||tp_dev.y[0]&gt;lcddev.height)//非法数据(坐标超出了)</span><br><span class="line">	&#123; </span><br><span class="line">		if((mode&amp;0XF)&gt;1)		//有其他点有数据,则复第二个触点的数据到第一个触点.</span><br><span class="line">		    &#123;</span><br><span class="line">				tp_dev.x[0]=tp_dev.x[1];</span><br><span class="line">				tp_dev.y[0]=tp_dev.y[1];</span><br><span class="line">				t=0;				//触发一次,则会最少连续监测10次,从而提高命中率	</span><br><span class="line">            &#125;</span><br><span class="line">        else					    //非法数据,则忽略此次数据(还原原来的)  </span><br><span class="line">	        &#123;</span><br><span class="line">				tp_dev.x[0]=tp_dev.x[4];</span><br><span class="line">				tp_dev.y[0]=tp_dev.y[4];</span><br><span class="line">				mode=0X80;		</span><br><span class="line">				tp_dev.sta=tempsta;	//恢复tp_dev.sta</span><br><span class="line">    &#125;</span><br><span class="line">else</span><br><span class="line">t=0;           //触发一次,则会最少连续监测10次,从而提高命中率</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if((mode&amp;0X8F)==0X80)//无触摸点按下</span><br><span class="line">	&#123; </span><br><span class="line">		if(tp_dev.sta&amp;TP_PRES_DOWN)	//之前是被按下的</span><br><span class="line">		&#123;</span><br><span class="line">			tp_dev.sta&amp;=~(1&lt;&lt;7);	//标记按键松开</span><br><span class="line">		&#125;else						//之前就没有被按下</span><br><span class="line">		&#123; </span><br><span class="line">			tp_dev.x[0]=0xffff;</span><br><span class="line">			tp_dev.y[0]=0xffff;</span><br><span class="line">			tp_dev.sta&amp;=0XE0;	//清除点有效标记	</span><br><span class="line">		&#125;	 </span><br><span class="line">	&#125; 	</span><br></pre></td></tr></table></figure>
<h3 id="main函数中"><a href="#main函数中" class="headerlink" title="main函数中"></a>main函数中</h3><p>//电容触摸屏测试函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void ctp_test(void)</span><br><span class="line">&#123;</span><br><span class="line">	u8 t=0;</span><br><span class="line">	u8 i=0;	  	    </span><br><span class="line"> 	u16 lastpos[5][2];		//最后一次的数据 </span><br><span class="line">	while(1)                //循环扫描</span><br><span class="line">	&#123;</span><br><span class="line">		tp_dev.scan(0);     </span><br><span class="line">                //tp_dev.scan函数会根据型号不同调用不同的函数，这里是9147的扫描函数</span><br><span class="line">    </span><br><span class="line">		for(t=0;t&lt;5;t++)</span><br><span class="line">		&#123;</span><br><span class="line">			if((tp_dev.sta)&amp;(1&lt;&lt;t))</span><br><span class="line">                //前文说过这个语句可以判断触点是否按下，是哪个触点</span><br><span class="line">			&#123;</span><br><span class="line">                //printf(&quot;X坐标:%d,Y坐标:%d\r\n&quot;,tp_dev.x[0],tp_dev.y[0]);</span><br><span class="line">				if(tp_dev.x[t]&lt;lcddev.width&amp;&amp;tp_dev.y[t]&lt;lcddev.height)</span><br><span class="line">				&#123;</span><br><span class="line">					if(lastpos[t][0]==0XFFFF)</span><br><span class="line">					&#123;</span><br><span class="line">						lastpos[t][0] = tp_dev.x[t];    //写入坐标</span><br><span class="line">						lastpos[t][1] = tp_dev.y[t];    </span><br><span class="line">					&#125;</span><br><span class="line">                    </span><br><span class="line">					lcd_draw_bline(lastpos[t][0],lastpos[t][1],tp_dev.x[t],tp_dev.y[t],2,POINT_COLOR_TBL[t]);//画线</span><br><span class="line">					lastpos[t][0]=tp_dev.x[t];</span><br><span class="line">					lastpos[t][1]=tp_dev.y[t];</span><br><span class="line">					if(tp_dev.x[t]&gt;(lcddev.width-24)&amp;&amp;tp_dev.y[t]&lt;20)</span><br><span class="line">					&#123;</span><br><span class="line">						Load_Drow_Dialog();//清除</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;else lastpos[t][0]=0XFFFF;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		delay_ms(5);i++;</span><br><span class="line">		if(i%20==0)LED0=!LED0;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单地说原理就是快速读入两次触点的坐标，并且画出两点间的直线，接着再画下一段直线<br>由于每次读入触点坐标的间隔时间非常段，所以总体上看像是连续的笔画</p>
]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>关于cannot get archives的问题</title>
    <url>/2022/02/08/%E5%85%B3%E4%BA%8Ecannot%20get%20archives%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>今天碰到个问题，hexo的next主题，在点击头像下面的 日志 时无法正常跳转，反而显示<br>cannot get archives%7C%7C%20archive<br>在网上找了很久答案都不满意，最后终于找到解决方法了<br><strong>思路在下面，不想看的的到文末看结论就行了</strong></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>首先我们要知道 %7C是|的编码，%20是空格的编码<br>所以上面的报错实际上是<br>cannot get archives|| archive<br>其中archives|| archive有没有觉得很眼熟？<br>没错，我们在next的主题配置中有这样一段代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /|| home</span><br><span class="line">  about: /2022/01/26/关于本站点/|| user</span><br><span class="line">  tags: /tags/|| tags</span><br><span class="line">  categories: /categories/|| th</span><br><span class="line">  archives: /archives/|| archive</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>所以这里就有了第一个解决方法<br>把最后一行改为archives: /archives/即删掉后面的部分，但是这种方法很明显有问题<br>因为|| archive是一种格式，后面表示的是图标，删掉的话你的博客里面的“归档”就没有图标了</p>
<p>然后再想想<br>头像下面的日志不能再次打开，但是下面的分类和标签却可以正常打开，<br>这三个部分都属于 sidebar(侧边栏?)<br>所以我想问题出在sidebar的文件中<br>打开 \themes\next\layout_macro\sidebar.swig<br>因为我没学过这种语言，所以只能用对比的方法来找问题<br>我们找到有关 archive(日志) categorie(分类) tags(标签)的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% if config.archive_dir != &#x27;/&#x27; and site.posts.length &gt; 0 %&#125;</span><br><span class="line">  &lt;div class=&quot;site-state-item site-state-posts&quot;&gt;</span><br><span class="line">  &#123;% if theme.menu.archives %&#125;</span><br><span class="line">    &lt;a href=&quot;&#123;&#123; url_for(theme.menu.archives).split(&#x27;||&#x27;)[0] | trim &#125;&#125;&quot;&gt;</span><br><span class="line">  &#123;% else %&#125;</span><br><span class="line">    &lt;a href=&quot;&#123;&#123; url_for(config.archive_dir) &#125;&#125;&quot;&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">      &lt;span class=&quot;site-state-item-count&quot;&gt;&#123;&#123; site.posts.length &#125;&#125;&lt;/span&gt;</span><br><span class="line">      &lt;span class=&quot;site-state-item-name&quot;&gt;&#123;&#123; __(&#x27;state.posts&#x27;) &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"> </span><br><span class="line">&#123;% if site.categories.length &gt; 0 %&#125;</span><br><span class="line">  &#123;% set categoriesPageQuery = site.pages.find(&#123;type: &#x27;categories&#x27;&#125;, &#123;lean: true&#125;) %&#125;</span><br><span class="line">  &#123;% set hasCategoriesPage = categoriesPageQuery.length &gt; 0 %&#125;</span><br><span class="line">  &lt;div class=&quot;site-state-item site-state-categories&quot;&gt;</span><br><span class="line">    &#123;% if hasCategoriesPage %&#125;&lt;a href=&quot;&#123;&#123; url_for(categoriesPageQuery[0].path) &#125;&#125;&quot;&gt;&#123;% endif %&#125;</span><br><span class="line">      &lt;span class=&quot;site-state-item-count&quot;&gt;&#123;&#123; site.categories.length &#125;&#125;&lt;/span&gt;</span><br><span class="line">      &lt;span class=&quot;site-state-item-name&quot;&gt;&#123;&#123; __(&#x27;state.categories&#x27;) &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &#123;% if hasCategoriesPage %&#125;&lt;/a&gt;&#123;% endif %&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% if site.tags.length &gt; 0 %&#125;</span><br><span class="line">  &#123;% set tagsPageQuery = site.pages.find(&#123;type: &#x27;tags&#x27;&#125;, &#123;lean: true&#125;) %&#125;</span><br><span class="line">  &#123;% set hasTagsPage = tagsPageQuery.length &gt; 0 %&#125;</span><br><span class="line">  &lt;div class=&quot;site-state-item site-state-tags&quot;&gt;</span><br><span class="line">    &#123;% if hasTagsPage %&#125;&lt;a href=&quot;&#123;&#123; url_for(tagsPageQuery[0].path) &#125;&#125;&quot;&gt;&#123;% endif %&#125;</span><br><span class="line">      &lt;span class=&quot;site-state-item-count&quot;&gt;&#123;&#123; site.tags.length &#125;&#125;&lt;/span&gt;</span><br><span class="line">      &lt;span class=&quot;site-state-item-name&quot;&gt;&#123;&#123; __(&#x27;state.tags&#x27;) &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &#123;% if hasTagsPage %&#125;&lt;/a&gt;&#123;% endif %&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>查了一下url_for是转码用的，可能和跳转有关，我们来看一下这三条语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;&#123;&#123; url_for(theme.menu.archives).split(&#x27;||&#x27;)[0] | trim &#125;&#125;&quot;&gt;</span><br><span class="line">&lt;a href=&quot;&#123;&#123; url_for(categoriesPageQuery[0].path) &#125;&#125;&quot;&gt;</span><br><span class="line">&lt;a href=&quot;&#123;&#123; url_for(tagsPageQuery[0].path) &#125;&#125;&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>芜湖，一对比几乎可以确定问题出在这儿，第一行的代码格式与下两行明显不一样，其中的||正好对应%7C%7C<br>我们直接把第一行的格式修改的和下面两行差不多</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;&#123;&#123; url_for(theme.menu.archives[0].path) &#125;&#125;&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>再测试，成功！花了一晚上时间想这个好难啊QAQ</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>打开\themes\next\layout_macro\sidebar.swig<br>找到archive段中的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;&#123;&#123; url_for(theme.menu.archives).split(&#x27;||&#x27;)[0] | trim &#125;&#125;&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>修改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;&#123;&#123; url_for(theme.menu.archives[0].path) &#125;&#125;&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>即可</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/01/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>关于本站点</title>
    <url>/2022/01/26/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99%E7%82%B9/</url>
    <content><![CDATA[<p><em><strong>这里是风雪归心的小屋</strong></em><br><em><strong>欢迎访问</strong></em><br><em><strong>内容基本上是随手记的笔记~</strong></em></p>
]]></content>
  </entry>
  <entry>
    <title>复试要点</title>
    <url>/2022/03/28/%E5%A4%8D%E8%AF%95%E8%A6%81%E7%82%B9/</url>
    <content><![CDATA[<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>缴费;<br>编程测试(手写，拍照上传，不计分数，但是影响印象);<br>外语水平测试(翻译专业文献);<br>专业知识问答(874选两门);<br>准备个人PPT(老师会根据PPT问问题);</p>
<p>PPT内容:科研经历没有的话写课设毕设内容<br>获奖和学术成果没有就删了</p>
<h2 id="研究生阶段的科研计划或其他个人规划："><a href="#研究生阶段的科研计划或其他个人规划：" class="headerlink" title="研究生阶段的科研计划或其他个人规划："></a>研究生阶段的科研计划或其他个人规划：</h2><p>·复试结束后，继续学习编程课程，同时学习人工智能神经网络方面的知识。争取达到科班水平。提前进入老师实验室，提升专业知识技能。以饱满的激情投入到学习中去。<br>·研一阶段，扎实掌握专业基础，并寻找适合自己的科研方向。并判断自己是否适合科研道路，是否做好读博/出国的决定。<br>·研二阶段，在自己选择的方向上做出成果，着手论文书写工作。如果选择了工作道路，还需要做好实习准备。<br>·研三阶段，完美完成毕业工作。并规划好人生的道路，沿道路一直走下去。</p>
<p>是否愿意调剂为非全日制：否</p>
<h2 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h2><p>大多数跟数据结构相关，不难<br>往年题：<br>①约瑟夫问题：n个人围成一圈，从第一个人开始报数，第m个人退出，依次继续，直到最后一个人留下。<br>编写函数，求解约瑟夫问题，对指定的n,m，求最后留下的人的初始编号是多少。<strong>要求用单向链表模拟实现</strong><br>②检测字符串是否为IPV4<br>③大数相加<br>④旋转矩阵<br>⑤ZIGZAG<br>⑥统计文件中大小写字母、数字个数。</p>
<h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><p>双绞线···找一本专业词汇还有python。要求朗读后翻译。(扇贝单词里面有)</p>
<h2 id="专业课题目"><a href="#专业课题目" class="headerlink" title="专业课题目"></a>专业课题目</h2><p>874三门里面选两门，数据结构一定要选(比较简单)，概念题多。</p>
<h2 id="PPT问答"><a href="#PPT问答" class="headerlink" title="PPT问答"></a>PPT问答</h2><p>1、PPT准备，最主要的是把PPT熟悉，保证写上去的东西都能说清楚，并且针对他们的问题能答上，毕业论文很重要。<br>2、专业知识：<br>①《深度学习入门》：基础，只有python基础语法，有一个简单项目，mnist手写书数字识字。适合0基础。<br>②吴恩达的机器学习课程，需要一定的基础知识。<br>③周志华的西瓜书和南瓜书，进阶，难。<br>人工智能可以看李宏毅的作业CSDN；</p>
<h2 id="专业方向："><a href="#专业方向：" class="headerlink" title="专业方向："></a>专业方向：</h2><p>出成绩就发邮件，一个星期不回就换老师，可以参加实验室的面试；<br>几乎所有方向都有：数据库；计算机网络；网安；计算机图形学（游戏）；算法；OS；软件；</p>
<p>张严辞：有图形学基础，搞游戏引擎开发的，要求很优秀的才行。<br>赵启军：论文产出好，想搞学术的去<br>吕建成：实验室项目多，资源多，略卷，老师好，时间少。<br>徐文政：很好，毕业要求学术发顶会<br>朱敏：要求严</p>
]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title>将关于界面直接改成文章内容</title>
    <url>/2022/01/26/%E5%B0%86%E5%85%B3%E4%BA%8E%E7%95%8C%E9%9D%A2%E7%9B%B4%E6%8E%A5%E6%94%B9%E6%88%90%E6%96%87%E7%AB%A0%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<p>直接打开E:\Blog\themes\next_config.yml进行设置<br>找到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /|| home</span><br><span class="line">  about: /about/|| user</span><br><span class="line">  tags: /tags/|| tags</span><br><span class="line">  categories: /categories/|| th</span><br><span class="line">  archives: /archives/|| archive</span><br></pre></td></tr></table></figure>
<p>这段代码中如 tags: /tags/|| tags这一句<br>第一个tags是指menu中的tags<br>第二个tags是指我们在网页中点开tags后的子域名,比如我现在点开tags后就是<a href="https://wangyier.top/tags/">https://wangyier.top/tags/</a> 可以看到子域名就是第二个tags<br>第三个tags 可以理解为注释（其实不是注释，应该是一个固定格式，删了好像有影响）</p>
<p><strong>现在来说说应该怎么点开about后直接显示一篇内容</strong><br>我们新建一篇名为about的文章 hexo new about<br>现在在主题config中的about属性中修改属性为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">about: /2022/1/26/about/|| user</span><br></pre></td></tr></table></figure>
<p>test<br>测试失败<br>修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">about: /2022/01/26/about/|| user</span><br></pre></td></tr></table></figure>
<p>test<br>测试成功！<br>现在把about改成 关于本站点<br>1.把E:\Blog\source_posts\about.md修改为E:\Blog\source_posts\关于本站点.md<br>2.把theme中的_config.yml 中的menu中的about修改如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">about: /2022/01/26/关于本站点/|| user</span><br></pre></td></tr></table></figure>
<p>test 失败<br>显示和之前一样重命名about为关于本站点好像无效<br>直接把该文章删掉，再hexo new 关于本站点<br>test<br>测试成功！</p>
<p><strong>现在修改 关于本站点 的内容就OK了！</strong></p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统信号量题目技巧</title>
    <url>/2022/03/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%A2%98%E7%9B%AE%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="生产者消费者问题-吸烟者问题"><a href="#生产者消费者问题-吸烟者问题" class="headerlink" title="生产者消费者问题(吸烟者问题)"></a>生产者消费者问题(吸烟者问题)</h1><h2 id="同步：生产了产品才能被消费、消费完了才有空位才能重新生产；也就是full和empty之间的关系"><a href="#同步：生产了产品才能被消费、消费完了才有空位才能重新生产；也就是full和empty之间的关系" class="headerlink" title="同步：生产了产品才能被消费、消费完了才有空位才能重新生产；也就是full和empty之间的关系"></a>同步：生产了产品才能被消费、消费完了才有空位才能重新生产；也就是full和empty之间的关系</h2><p>full表示还有多少个产品可以消费<br>empty表示还有多少个空位可以重新生产（注意初值）</p>
<p>生产者过程：<br>首先需要一个空位p(empty)<br>生产完后多了一个产品v(full)</p>
<p>消费者过程：<br>首先需要一个产品p(full)<br>消费完后多了一个空位v(empty)</p>
<h2 id="互斥：注意哪些东西不能同时访问-mutex-初值为1"><a href="#互斥：注意哪些东西不能同时访问-mutex-初值为1" class="headerlink" title="互斥：注意哪些东西不能同时访问 mutex 初值为1"></a>互斥：注意哪些东西不能同时访问 mutex 初值为1</h2><h1 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h1><p>读者写者问题主要是为了解决互斥问题。读和读之间可以同时访问；读和写、写和写之间是互斥的<br>引入计数器counter；表示读的人</p>
<h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><p>mutex<br>写过程是不容其他过程的，可以直接P(mutex)<br>而读过程P(mutex)受计数器counter的影响；需要考虑是不是第一个读进程(负责P)；以及退出时是不是最后一个推出的(负责V)<br>rw，读写之间的互斥</p>
<h1 id="哲学家问题"><a href="#哲学家问题" class="headerlink" title="哲学家问题"></a>哲学家问题</h1><p>哲学家问题的关键时限制并行，三种思路<br>1、限制申请条件(破坏死锁条件)<br>比如规定单号哲学家先取左边；双号(if i%2==0)哲学家先取右边筷子</p>
<p>2、限制信号量并行数<br>如：限制同一时间只能有一个哲学家就餐(禁止并行)</p>
<p>3、限制哲学家只有取得两只筷子时才能就餐(破坏死锁条件)</p>
<h1 id="理发师问题-涉及取号叫号"><a href="#理发师问题-涉及取号叫号" class="headerlink" title="理发师问题(涉及取号叫号)"></a>理发师问题(涉及取号叫号)</h1><p>理发师、营业员都是这一类<br>同步：顾客的取号和工作人员的叫号通过同步信号量实现，顾客到达取号后就P操作排队，因为信号量机制中P会把自己阻塞并进入阻塞队列。先来的顾客就在前面<br>互斥：取号机只有一个；可以通过队列实现叫号</p>
<h1 id="做题技巧"><a href="#做题技巧" class="headerlink" title="做题技巧"></a><strong>做题技巧</strong></h1><p>1.审题 找对应题型<br>2.找到临界资源 确定互斥信号量<br>3.找到进程之间的同步关系 确定同步信号量<br>4.写出代码 添加注释<br>5.回顾题目 看是否满足要求<br>6.外层写同步信号量；内层写互斥信号量(反了的话可能会出问题)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P(empty)</span><br><span class="line">    P(mutex)</span><br><span class="line">        具体操作</span><br><span class="line">    V(mutex)</span><br><span class="line">V(full)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一篇经济学人</title>
    <url>/2022/04/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AF%87%E7%BB%8F%E6%B5%8E%E5%AD%A6%E4%BA%BA/</url>
    <content><![CDATA[<h2 id="DAY-1-Genetic-tests-for-pets——Testing-dogs’-DNA-is-increasingly-popular-and-full-of-surprises"><a href="#DAY-1-Genetic-tests-for-pets——Testing-dogs’-DNA-is-increasingly-popular-and-full-of-surprises" class="headerlink" title="DAY 1:Genetic tests for pets——Testing dogs’ DNA is increasingly popular, and full of surprises."></a>DAY 1:Genetic tests for pets——Testing dogs’ DNA is increasingly popular, and full of surprises.</h2><p><a href="https://www.bilibili.com/video/BV1S94y1o7QV?spm_id_from=0.0.header_right.history_list.click">https://www.bilibili.com/video/BV1S94y1o7QV?spm_id_from=0.0.header_right.history_list.click</a></p>
<p>Carnegie <font color= red>Violet</font> dog-fuller lives a happy life in Hollywood. She enjoys <font color= red>munching</font> ice cubes and listening to Snoop Dogg. Life was not always easy. Found as an injured <font color= red>stray</font> in Santa Monica, she spent time in a rescue centre before being adopted by Gregg and Linday last year.They reckoned she was a French Bulldog mix. But a DNA test revealed her to be more American Staffordshire Terrier (39%) than French Bulldog (24%), with significant Pomeranian genes (16%). “We were shocked,” admits Mr Fuller.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Violet n.紫罗兰，此处应该是名字</span><br><span class="line">munch (on/at) sth vt/vi.咀嚼某物</span><br><span class="line">stray vi.走失 adj.走失的 n.走失的宠物/家畜</span><br></pre></td></tr></table></figure>

<p>Genealogy was once the <font color= red>preserve</font> of elite dogs. Their breeders take a special interest in keeping bloodlines pure, to create new champions and to raise the prices of <font color= red>puppies</font>. Now common <font color= red>mutts</font> are having their <font color= red>pedigrees</font> traced. Wisdom Panel, a firm that tests pet DNA, said on March 3rd that its database had expanded to 3m animals (<font color= blue>over 95% of them dogs</font>), up from 1m in 2018. Embark Veterinary, a similar firm which has 1m dogs in its database, was valued at $700m in July after a $75 investment.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">preserve n.私人领域、专属领域</span><br><span class="line">puppy n.小狗，幼犬</span><br><span class="line">mutt n.狗，杂交狗</span><br><span class="line">pedigree n.动物血统记录 a.纯种的，血统优良的</span><br><span class="line">over 95% of them dogs 其中超过95%是狗</span><br></pre></td></tr></table></figure>

<p>During the pandemic 23m Americans adopted puppies, according to the American <font color= red>Society</font> for the Prevention of <font color= red>Cruelty</font> to Animals. Rebecca Chodroff Foran, <font color= red>research director</font> at Wistom Panel, thinks this trend has <font color= red>collided</font> with another: the growth of human-DNA bussiness. Owners “now consider their pets to be key numbers of the family”, she says.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">society n.协会</span><br><span class="line">cruelty n.残忍，虐待，残暴的行为</span><br><span class="line">research director 研究总监</span><br><span class="line">collide with 与···相撞</span><br></pre></td></tr></table></figure>

<p>Animal DNA tests work much like human ones. They compare genetic markers with a database of pets with verified pedigrees, revealing <font color= red>canine</font> lineage and potional health problems. Embark claims 99.9% accuracy; Wisdom Panel claims over 98%.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">canine a.狗的</span><br></pre></td></tr></table></figure>

<p>Some owners are horrified to discover that their costly <font color= red>crossbreed</font> is in fact a mix of entirely different breeds. But owners of adopted and <font color= red>rescue dogs</font>, which make up 67% of Wisdom Panel’s database, are keen to learn. Murrary, who lives in New York with his owner Erica Hyman, looks like a Jack Russell but with his uprigtht years. He turned out to be a mix of 23 breeds. “Now I just tell people ‘He’s just a dog’”, says Ms Hyman.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crossbreed n.杂交品种</span><br><span class="line">rescue dog 搜救犬</span><br></pre></td></tr></table></figure>

<p>Chico Lopez, who breeds American Pit Bull Terriers, thinks DNA is a <font color= red>decent</font> investment for mutts. He compares them to second-hand cars: “You don’t know if the engine comes from a Toyota, the transmission from a Bugatti and the tyres from a little motorcycle, so you need to…find out what is going to break first.” But those wanting to pureblood, he says, should not rely on DNA, as <font color= red>reputable</font> breeders already have accurate knowlegde of a dog’s ancestor.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">decent a.恰好的 </span><br><span class="line">decent investment 不错的投资</span><br><span class="line">reputable a.值得尊敬的，声誉良好的</span><br></pre></td></tr></table></figure>

<p>Owners of adopted dogs like searching for long-lost kin. About 12% of dogs on Embark’s database discover a <font color= red>sibling</font>, parent or offspring. And, as with human DNA testing, there is the possibility of <font color=blue>stumbling on a family secret</font>. Some dog owners are now finding that their sweet pooch fathered a little in another state before absconding. <font color= red>Paw form</font>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sibling n.兄弟姐妹</span><br><span class="line">stumbling on a family secret 撞破一个家庭秘密</span><br><span class="line">Paw form 四处留情</span><br></pre></td></tr></table></figure>

<h2 id="DAY-2-Bartleby-Body-of-research——Online-work-has-changed-the-nature-of-non-verb-com-munication"><a href="#DAY-2-Bartleby-Body-of-research——Online-work-has-changed-the-nature-of-non-verb-com-munication" class="headerlink" title="DAY 2:Bartleby:Body of research——Online work has changed the nature of non-verb com-munication"></a>DAY 2:Bartleby:Body of research——Online work has changed the nature of non-verb com-munication</h2><p><a href="https://www.bilibili.com/video/BV1P34y1t7RX?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1P34y1t7RX?spm_id_from=333.337.search-card.all.click</a></p>
<p>Communication is an essential part of leadership. And body language is an essential part of communication. <font color= blue>On those slim pillars rests a mini-industry of research and advice into how executives can influence, encourage and <font color= red>ascend</font> without needing to say a word</font>. The pandemic has made much of it <font color= red>redundant</font>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ascend v.上升</span><br><span class="line">redundant a.冗余的</span><br><span class="line">一种关于研究和建议高管如何不需要说一句话就能够影响、鼓励、晋升的微型产业建立在了这些细小的支柱上</span><br></pre></td></tr></table></figure>

<p>Plenty of studies have looked into the non-verbal behaviour that <font color= red>makes out”emergent leaders”</font>, people who do not have a <font color= red>specified</font> role in the <font color= red>hierarchy</font> but naturally assume a position of authority in groups. They are a bag of <font color= red>tics</font>. They nod; they touch others but not themselves; they gesture; they <font color= red>furrow</font> their brows; they hold themselves erect; their facial expressions are more <font color= red>animated</font>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make out 造就</span><br><span class="line">emergent a.紧急的/自发的 这里可以理解为天生的领袖？</span><br><span class="line">specify vt.指定 </span><br><span class="line">hierarchy  [ˈhaɪərɑːki]  n. 阶级</span><br><span class="line">tic n.抽搐 a bag of tics 充满了动作</span><br><span class="line">furrow n.犁沟;沟;车辙;(脸上的)皱纹</span><br><span class="line">       v.犁;(使)皱(眉)，蹙(额)</span><br><span class="line">brow n.额头</span><br><span class="line">erect a.垂直的 vt.建造  </span><br><span class="line">animate vt.使有生气，使生气勃勃</span><br><span class="line">animated a.有生气的</span><br></pre></td></tr></table></figure>

<p>Other research suggests that, to win votes in an election, candidates should deliver speeches with their feet <font color= red>planted</font> apart. The seconed-most popular TED talk claims that <font color= blue>two minutes of private</font>, <font color= red>hands-on-hips</font> “power posing” can <font color= red>infuse</font> a job candidate with confidence and improve others’ perception of them.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plant vt.树立，安放</span><br><span class="line">two minutes of private 私下两分钟</span><br><span class="line">hip n.臀部，髋骨 </span><br><span class="line">hands-on-hip 双手叉腰</span><br><span class="line">infuse vt.使具有(流入)</span><br></pre></td></tr></table></figure>

<p>Gazing can foster a sense of psychological safety as well as <font color= red>confer</font> authority: in a recent paper, a <font color= red>trio</font> of research from Havard Bussiness School found that receiving more eye contact from a <font color= red>bigwig</font> led to greater participation in group interactions. Leaders who adopt <font color= red>open</font> body positions, with arms and legs uncrossed, are also more likely to encourage contribution.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">confer=bestow vt.授予</span><br><span class="line">trio n.三人小组</span><br><span class="line">bigwig n.大人物</span><br><span class="line">open a.开放的</span><br></pre></td></tr></table></figure>

<p>There are three problems with this body of research on non-verbal communication. One is that so much of it is <font color= red>blindingly</font> obvious. Nodding at someone rather than shaking head in incredulity when they are speaking to you——this dose indeed send a powerful signal. But so does punching someone in the face, <font color= blue>and no one thinks that requires a journal publication.</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">blind a.瞎的</span><br><span class="line">blinding a.刺眼的，炫目的</span><br><span class="line">blindingly ad.极其地=extremely=especially</span><br><span class="line">credulity n.轻信</span><br><span class="line">incredulity n.怀疑，不信</span><br><span class="line">journal n.报刊，杂志</span><br><span class="line">没人需要阅读期刊论文才明白这个道理</span><br></pre></td></tr></table></figure>

<p>A second problem is that people look for different things from their bosses. <font color= red>Frowning</font> is seen as a mark of emergent leaders but not of suppositive ones; <font color= blue>the reverse is true of smiling</font>. (The effect of similing with <font color= red>lowered eyebrows</font> <font color= pink>cries out</font> for study.) A recent paper found that male <font color= red>recipients</font> regarded bosses who used emojis, a form of non-quite-verbal communication, in an email as more effective, but that female recipients perceived them as less effective. </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frown vi.皱眉头</span><br><span class="line">be true of 适用于；符合于</span><br><span class="line">关于微笑（的观点）正好相反</span><br><span class="line">lowered eyebrow 与 raised eyebrowed 相对应. raise eyebrow 表示不赞成 那么lower eyebrow 呢？</span><br><span class="line">cry out for 迫切需要</span><br><span class="line">整句：关于垂眉微笑的影响更需要研究</span><br><span class="line">recipient n.收件人</span><br></pre></td></tr></table></figure>

<p>The third problem is newer. Almost all of the research on body language dates from a time of <font color= red>in-person</font> interactions. Even when the pandemic <font color= red>wanes</font> and offices in the West refill, most buildings will not return to full capacity. Employees will keep working remotely for at least part of the week; <font color= red>Zoom</font> will remain <font color= red>integral</font> to white-collar working lives. And if there is one thing for which online interactions are not suited, it is body language.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">in-person ad.亲自 a.亲自的</span><br><span class="line">wane=fade=decrease [weɪn] vi.衰落、减弱</span><br><span class="line">refill vt.再装满</span><br><span class="line">Zoom 视频会议软件</span><br><span class="line">integral a.完整的→不可或缺的</span><br></pre></td></tr></table></figure>

<p>That is partly because bodies themselves are largely hidden from view: whatever language they are speaking, it is hard to hear them. You will know the partners, pets and <font color= red>home-decor</font> choices of new colleagues before you will know how tall they are. And although faces fill the video-conferencing screen, meaningfull eye contact is impossible.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">decor n.装饰风格</span><br></pre></td></tr></table></figure>

<p>Once past a basic <font color= red>threshold</font> of <font color= red>attentiveness</font>——not looking down at your mobile phone, <font color= red>say</font>——most people have the same glassy-eyed <font color= red>stare</font>. If several faces appear on screen, these participants have no way of knowing that you are gazing specifically at them. (Angway, adimit it: the face you are looking at with most interest is your own.) If your camera is in the wrong place, you may think you are looking meaningfully at your team but you are actually just giving them a view of your <font color= red>nostrills</font>. Animated expressions are hard to <font color= red>spot</font>, particularly when people attending hybrid meetings in the office are <font color= blue>Lowry-like</font> figures seated metres away.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">threshold n.阈值</span><br><span class="line">attentiveness n.专心</span><br><span class="line">say v 假设</span><br><span class="line">not looking down at your mobile phone, say这一整句才是完整的插入语部分</span><br><span class="line">glassy a.(眼睛)无神的 呆滞的</span><br><span class="line">stare n.盯</span><br><span class="line">nostrill n.鼻孔</span><br><span class="line">spot v发现注意到=observe=notice</span><br><span class="line">Lowry-like 像Lowry画的火柴人一样</span><br></pre></td></tr></table></figure>

<p>There are no good ways to compensate for these problems. One tactic is to go <font color= red>all in</font> on expressiveness, nodding <font color= red>furiously</font> and gesturing dementedly—— a small <font color= red>tile</font> of caged energy somewhere in the bottom left-hand corner of the screen. Another is to do a “Zoom loom”, placing yourself so close to the camera that you will give everyone nightmares.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">all-in a.不遗余力的 </span><br><span class="line">furiously ad.激烈地 猛烈地</span><br><span class="line">dementedly ad.焦躁地</span><br><span class="line">tile n.瓷砖 这里比喻了屏幕上面的头像框</span><br><span class="line">loom n.逼近 突然出现</span><br><span class="line">Zoom loom Zoom特写</span><br></pre></td></tr></table></figure>

<p>The simpler option is not to think too hard about body language. At a few specific moments, like job interviews and <font color= red>set-piece</font> speeches, first impressions matter and a bit of <font color= red>self-conscious</font> posing <font color= red>pays off</font>. But posture is not leadership. If you want to give people a break from staring at a screen, turning off your camera is a good way to do it. If you want to <font color= red>waggle</font> your eyebrows, up or down, let them loose. And if you need to be told that looking at someone makes them feel valued, you have big issues. </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set-piece a.事先精心安排的</span><br><span class="line">self-conscious = intentional a.故意的、刻意的</span><br><span class="line">pay off</span><br><span class="line">waggle vt.来回摆动</span><br></pre></td></tr></table></figure>

<h2 id="DAY-3-The-Theranos-trial-Blood-will-have-blood——A-jury-finds-a-former-Silicon-Valley-star-guilty-of-fraud"><a href="#DAY-3-The-Theranos-trial-Blood-will-have-blood——A-jury-finds-a-former-Silicon-Valley-star-guilty-of-fraud" class="headerlink" title="DAY 3: The Theranos trial: Blood will have blood——A jury finds a former Silicon Valley star guilty of fraud."></a>DAY 3: The Theranos trial: Blood will have blood——A jury finds a former Silicon Valley star guilty of fraud.</h2><p><a href="https://www.bilibili.com/video/BV1ti4y1Q7BL?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1ti4y1Q7BL?spm_id_from=333.999.0.0</a></p>
<p>On JANUARY 3RD, after seven days of <font color= red>delibration</font>, a 12-member jury in Silicon Valley found Elizabeth Homlmes, the entrepreneur behind a blood-testing <font color= red>startup</font>, guilty of four <font color= red>counts</font> of <font color= red>fraudulently</font> deceiving investors. Each count carries a <font color= red>prison term</font> of up to 20 years; <font color= blue>no date has been set for her sentencing</font>.She was <font color= red>acquitted</font> of four charges of deceiving patients and doctors; on three others the jury were <font color= red>deadlocked</font>. The <font color= red>verdict</font>, against which Ms Holmes’s lawyers are expected to <font color= red>appeal</font>, marks the collapse of a career that <font color= red>beguiled</font> the media, politicians and investors.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delibration n.讨论，审议</span><br><span class="line">startup n.新型小型企业</span><br><span class="line">guilty of ``` 有···罪</span><br><span class="line">count n.罪状</span><br><span class="line">fraudulent a.欺骗的，欺诈的</span><br><span class="line">prison term 刑期</span><br><span class="line">set a date for 选定···日期 sentence v.宣判</span><br><span class="line">acquit sb of sth v.宣告无罪(罪名不成立)</span><br><span class="line">deadlock n.僵持不下(死锁) deadlocked a.僵持不下的</span><br><span class="line">verdict n.裁定</span><br><span class="line">appeal v.上诉</span><br><span class="line">beguile vt.欺骗</span><br></pre></td></tr></table></figure>

<p>After dropping out of Stanford University in 2003 at the age of 19, Ms Holmes founded Theranos to develop a <font color= red>radical advance</font> in blood-testing technology that she hoped would allow hundreds of tests to be performed using a single tiny drop of blood rather than a full vial. The tantalising vision promised to make health care more effective and efficient.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">radical a.彻底的</span><br><span class="line">advance n.进步</span><br><span class="line">a drop of 一滴</span><br><span class="line">vial n.小瓶</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Unfortunately, Ms Holmes could not bring it to fruition. In voting to concict on four counts, the jury concluded that, aware of her company’s failure, Ms Holmes intentionally lied about its prospects and capabilities, and so crossed the fine line from promotion to deliberate fraud——a step she explicity denied in her own testimony.</p>
<p>In many ways Theranos differed little from many hot startups. It raised more than $1bn, reached an extravagant theoretical valuation (in its case $9bn) before crashing without ever going public and disintegrating into a vast graveyard of unfeasible ideas. Typically, executives behind such ventures are quickly forgotten. But Ms Holmes’s path differed at least in part because even though her company’s products failed, her presence about broader story proved unusually compelling.</p>
<p>In building Theranos, Ms Holmes assembled a remarkable collection of acolytes. Her board was filled with several former secretaries of state and defence. Joe Bidden, while vice-prisident, called Theranos “the laboratory of future” and Ms Holmes “an inspiration”. The company’s shocking failure suggested her famous followers had fed merely on type. The fashion press was besotted by Ms Holmes’s ability to present herself. The steve Jobs-inspired black turtlenecks she wore at work were seen as reflecting authority. The opennecked shirts and blouses she donned during the trial were a sign of appealing vulnerability, augmented by the nappy bag she carried to court, which signalled to jury the costs of a potential prison term to a young mother and her infant child (who was born in July). Reporters and other onlookers waited for hours to nab a set in the packed courtroom.</p>
<p>Ms Holmes’s defence followed two distinct lines. The most obvious hinged on naivety. She may have been wrong about Theranos’s prospecets, the argument went, but that is not a crime. Startup investors are supposed to be a sophisticated lot, willing to wager based on deep insights in the hope of a big return, while understanding that long shots can fail. The prosecutors’ counterargument rested primarily on the presentations which Ms Holmes made to investors. These appeared to exaggerate potential sales and trumpet non-existent endorsements from the armed forces and big pharmaceutical companies. The single substantive request made by the jurors during their delibretion was to rehear a presentation that had been recorded, suggesting they were parsing what precisely she had been telling her backers.</p>
<p>Ms Holmes’ sound line of argument, the so-called Svengali defence, was particularly appealing to hot Hollywood, but its impact on the jury was unclear. She claimed at the trial to have been sexually and emotionally abused and manuplated by Ramesh “Sunny” Balwani, her ex-partner and Theranos’s former chief operating officer. As such, her lawyers posited, she could not be held responsible for her actions.</p>
<p>Mr Balwani has strongly denied all allegations. His own trial for fraud charges will begin next month, ensuring the Theranos saga will not end soon. And even after the last gavel is pounded, there will be more to come. In the lead-up to the verdict Hulu, a capable network, released photos from an upcoming mini-series on Ms Holmes’s story, starring Amanda Seyfried. Ms Holmes may end up going to prison, but she will not be going away.</p>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏通关记录及杂谈</title>
    <url>/2022/02/11/%E6%B8%B8%E6%88%8F%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95%E5%8F%8A%E6%9D%82%E8%B0%88/</url>
    <content><![CDATA[<h1 id="单机"><a href="#单机" class="headerlink" title="单机"></a>单机</h1><p>在2022/2/11 之前通关的游戏</p>
<h2 id="Bright-Memory-光明记忆"><a href="#Bright-Memory-光明记忆" class="headerlink" title="Bright Memory 光明记忆"></a>Bright Memory 光明记忆</h2><p>平台：steam<br>开发商：飞燕群岛<br>体验：<br>    一般，剧情和游戏性中规中矩，不过作为国产游戏不错了，开不了RTX感受不了这个卖点有点可惜了。</p>
<h2 id="Call-of-Cthulhu-克苏鲁的呼唤"><a href="#Call-of-Cthulhu-克苏鲁的呼唤" class="headerlink" title="Call of Cthulhu 克苏鲁的呼唤"></a>Call of Cthulhu 克苏鲁的呼唤</h2><p>平台：steam<br>开发商：Cyanide Studio<br>体验：<br>    不错不错，有那味儿了，镜鬼那里很有压迫感，但是感觉制作组可能缺经费，最后的邪神都没啥画面。</p>
<h2 id="Dark-Souls-2-黑魂2"><a href="#Dark-Souls-2-黑魂2" class="headerlink" title="Dark Souls 2 黑魂2"></a>Dark Souls 2 黑魂2</h2><p>平台：steam<br>开发商：FromSoftware<br>体验：<br>    神中神！蓝高达虐我千百遍，我待高达如初恋！<br>    第一次玩的魂系游戏，咒老师是真的记忆深刻，打了一下午，教会了我怎么翻滚，以及不要贪刀！<br>    流程虽然有硬凑的感觉，但是毕竟是入坑作，情怀分up up<br>    DLC是针不戳，白王YYDS！马雷达别让我逮着你嗷！<br>    我的多兰古雷格！我的鲁卡提耶！</p>
<h2 id="Dark-Souls-3-黑魂3"><a href="#Dark-Souls-3-黑魂3" class="headerlink" title="Dark Souls 3 黑魂3"></a>Dark Souls 3 黑魂3</h2><p>平台：steam<br>开发商：FromSoftware<br>体验：<br>    原汁原味！<br>    火之将熄,然位不见王影(我将以高达形态出击！)</p>
<h2 id="Grand-Theft-Auto-5-给她爱5"><a href="#Grand-Theft-Auto-5-给她爱5" class="headerlink" title="Grand Theft Auto 5 给她爱5"></a>Grand Theft Auto 5 给她爱5</h2><p>平台：steam<br>开发商：Rockstar North<br>体验：<br>    勾起了小时候玩罪恶都市的回忆~<br>    崔佛这个神经病什么时候死啊</p>
<h2 id="Grim-Dawn-恐怖黎明"><a href="#Grim-Dawn-恐怖黎明" class="headerlink" title="Grim Dawn 恐怖黎明"></a>Grim Dawn 恐怖黎明</h2><p>平台：steam<br>开发商：Crate Entertainment<br>体验：<br>    感觉还不错。。。但是我打通关了卸载了才意识到需要刷刷刷</p>
<h2 id="Iris-Fall-彩虹坠入"><a href="#Iris-Fall-彩虹坠入" class="headerlink" title="Iris.Fall 彩虹坠入"></a>Iris.Fall 彩虹坠入</h2><p>平台：steam<br>开发商：NEXT Studios<br>体验：<br>    解密挺不错的，但是光顾着解密了，剧情没咋看–</p>
<h2 id="Kakusankibou-扩散希望"><a href="#Kakusankibou-扩散希望" class="headerlink" title="Kakusankibou 扩散希望"></a>Kakusankibou 扩散希望</h2><p>平台：steam<br>开发商：あみそ組<br>体验：<br>    ？？我还没通关啊为啥放这儿了</p>
<h2 id="KOEWOTAYORINI-声之寄托"><a href="#KOEWOTAYORINI-声之寄托" class="headerlink" title="KOEWOTAYORINI 声之寄托"></a>KOEWOTAYORINI 声之寄托</h2><p>平台：steam<br>开发商：あみそ組<br>体验：<br>    小成本游戏，还算有新意，流程太短了</p>
<h2 id="KOEWOTAYORINI-SP-声之寄托SP"><a href="#KOEWOTAYORINI-SP-声之寄托SP" class="headerlink" title="KOEWOTAYORINI SP 声之寄托SP"></a>KOEWOTAYORINI SP 声之寄托SP</h2><p>平台：steam<br>开发商：あみそ組<br>体验：<br>    小成本游戏，还算有新意，流程太短了</p>
<h2 id="Raging-Loop-人狼村之谜"><a href="#Raging-Loop-人狼村之谜" class="headerlink" title="Raging Loop 人狼村之谜"></a>Raging Loop 人狼村之谜</h2><p>平台：steam<br>开发商：KEMCO<br>体验：<br>    ！！神中神！！还差一点··<br>    游戏设计挺不错的，二周目还能开心里描述，可玩度up up，剧情到后面感觉有点崩，但是还是不错。<br>    房石大大滴坏。千枝实大大滴好！</p>
<h2 id="Sekiro-Shadow-Die-Twice-只狼：影逝二度"><a href="#Sekiro-Shadow-Die-Twice-只狼：影逝二度" class="headerlink" title="Sekiro:Shadow Die Twice 只狼：影逝二度"></a>Sekiro:Shadow Die Twice 只狼：影逝二度</h2><p>平台：steam<br>开发商：FromSoftware<br>体验：<br>    非常ncie，很有意思的战斗系统，第一个预购的游戏，记得早上五点五十就起来了，来电就开玩。难度还是有一点的，打铁的战斗快感比黑魂高多了。</p>
<h2 id="Shadow-Warrior-影子武士"><a href="#Shadow-Warrior-影子武士" class="headerlink" title="Shadow Warrior  影子武士"></a>Shadow Warrior  影子武士</h2><p>平台：steam<br>开发商：Flying Wild Hog<br>体验：<br>    就你TM叫恶魔啊？</p>
<h2 id="Shadow-Warrior-2-影子武士2"><a href="#Shadow-Warrior-2-影子武士2" class="headerlink" title="Shadow Warrior 2 影子武士2"></a>Shadow Warrior 2 影子武士2</h2><p>平台：steam<br>开发商：Flying Wild Hog<br>体验：<br>    王洛yyds，砍死它们！今年要出3了好像。</p>
<h2 id="Titan-Quest-Annyversary-Edition-泰坦之旅十周年纪念版"><a href="#Titan-Quest-Annyversary-Edition-泰坦之旅十周年纪念版" class="headerlink" title="Titan Quest Annyversary Edition 泰坦之旅十周年纪念版"></a>Titan Quest Annyversary Edition 泰坦之旅十周年纪念版</h2><p>平台：steam<br>开发商：THQ<br>体验：<br>    我接触的第一款刷刷刷的游戏==和恐怖黎明一样，我没刷刷刷，通关剧情就溜了。好像只有POE我是真的刷了(毕竟网游)</p>
<h2 id="Catherine-Classic-凯瑟琳经典版"><a href="#Catherine-Classic-凯瑟琳经典版" class="headerlink" title="Catherine Classic 凯瑟琳经典版"></a>Catherine Classic 凯瑟琳经典版</h2><p>平台：steam<br>开发商：ATLUS<br>体验：<br>    神中神！我就知道我这种好男人最后会和Katherine一起结婚！区区Catherine也想勾引我，吃我一拳！<br>    不过游戏对于婚姻和孩子的思考还是挺深的，突然告诉你你当爸爸了，你会这么想？害怕还是高兴？<br>    I will hold you dear for the rest of our lives.Will you marry me?<br>    …Katherine,I love you.<br>    My life has no meaning without you…</p>
<h2 id="Ryse-Son-of-Rome-崛起：罗马之子"><a href="#Ryse-Son-of-Rome-崛起：罗马之子" class="headerlink" title="Ryse:Son of Rome 崛起：罗马之子"></a>Ryse:Son of Rome 崛起：罗马之子</h2><p>平台：steam<br>开发商：Crytek<br>体验：<br>    画质牛啊牛啊，打击感不错，刀刀到肉的感觉针不戳，但是玩久了明显感觉游戏性很差，比较枯燥</p>
<h2 id="METAL-GEAR-RISING-REVEMGEANCE-合金装备崛起：复仇"><a href="#METAL-GEAR-RISING-REVEMGEANCE-合金装备崛起：复仇" class="headerlink" title="METAL GEAR RISING: REVEMGEANCE 合金装备崛起：复仇"></a>METAL GEAR RISING: REVEMGEANCE 合金装备崛起：复仇</h2><p>平台：steam<br>开发商：Platinum Games Inc.<br>体验：<br>    一句话，<br>    男人的浪漫</p>
<h2 id="Braid"><a href="#Braid" class="headerlink" title="Braid"></a>Braid</h2><p>平台：steam<br>开发商：Number None<br>体验：<br>    游戏针不戳，很精致的解密游戏，很有意思</p>
<h2 id="Killer-is-Dead"><a href="#Killer-is-Dead" class="headerlink" title="Killer is Dead"></a>Killer is Dead</h2><p>平台：steam<br>开发商：KADOKAWA GAMES / GRASSHOPPER MANUFACTURE<br>体验：<br>    极其糟糕，冲着画风去的但是游戏性让我恶心的不行</p>
<h2 id="Metro-2033-Redux"><a href="#Metro-2033-Redux" class="headerlink" title="Metro 2033 Redux"></a>Metro 2033 Redux</h2><p>平台：steam<br>开发商：4A Games<br>体验：<br>    情怀党！以前初中的时候买的地铁2033和2034的小说，里面还送莫斯科地铁线路图。2035等半天好像出版社跑路了==难受啊</p>
<h2 id="Elden-Ring-艾尔登法环"><a href="#Elden-Ring-艾尔登法环" class="headerlink" title="Elden Ring 艾尔登法环"></a>Elden Ring 艾尔登法环</h2><p>平台： steam<br>开发商：FromSoftware<br>体验：<br>    时间：2022.4.14 全成就通关<br>    因为是慢慢体验，最后查攻略打的全结局(主要是抑制癫火的剧情有点绕)，花了180个小时<br>    宫崎英高主题乐园，不死人狂喜！<br>    作为一个老魂玩家，只能说是心满意足了<br>    梅琳娜？菈妮？老婆！经典恋爱养成游戏<br>    近战有点受苦，但是感觉还行，也不是不能打<br>    通关了感觉自己的记地图能力还是挺强的，没咋迷路<br>    &lt;&lt;关于我开局就打到碎星门口才知道走错方向了这件事&gt;&gt;<br>    最受苦的怪是盖利德神授塔的神皮贵族和碎星将军门口的双BOSS，因为前期就去了，这个神皮一刀就把我砍死了==<br>    女武神就是个屑，拉塔恩将军yyds！<br>    荷莱露为啥杀狮子啊–<br>    梅琳娜你知不知道为了救你我付出了多少！！</p>
<h1 id="联机"><a href="#联机" class="headerlink" title="联机"></a>联机</h1>]]></content>
      <categories>
        <category>游戏相关</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>生词</title>
    <url>/2022/06/17/%E7%94%9F%E8%AF%8D/</url>
    <content><![CDATA[<h2 id="monitress"><a href="#monitress" class="headerlink" title="monitress"></a>monitress</h2><p>n.女班长</p>
<h2 id="malpractice"><a href="#malpractice" class="headerlink" title="malpractice"></a>malpractice</h2><p>n.不当行为<br>Just think of the malpractice you bring to the class !</p>
<h2 id="vice-monitor"><a href="#vice-monitor" class="headerlink" title="vice-monitor"></a>vice-monitor</h2><p>n.副班长</p>
<h2 id="Study-Commissary"><a href="#Study-Commissary" class="headerlink" title="Study Commissary"></a>Study Commissary</h2><p>学习委员<br>【commissary】 n. 代表, 委员, 杂货店 [经] 粮食, 粮食部, 食品供应部 名词复数形式: commissaries;</p>
<h2 id="Class-Board"><a href="#Class-Board" class="headerlink" title="Class Board"></a>Class Board</h2><p>班委会</p>
<h2 id="in-ecstasy"><a href="#in-ecstasy" class="headerlink" title="in ecstasy"></a>in ecstasy</h2><p>陷入狂喜；入迷<br>【ecstasy】 n. 狂喜, 心醉神迷, 忘形 [医] 入迷 名词复数形式: ecstasies;</p>
<h2 id="get-familiarized-with"><a href="#get-familiarized-with" class="headerlink" title="get familiarized with"></a>get familiarized with</h2><p>n.与···熟悉<br>【familiarized】 v. 使（某人）熟悉, 使通晓( familiarize的过去式和过去分词 ) 原型: familiarize; 原型变换形式: 过去分词,过去式;</p>
<h2 id="low-key"><a href="#low-key" class="headerlink" title="low-key"></a>low-key</h2><p>a.低调的<br>Could we keep our relationship low-key at school?</p>
<h2 id="homeroom-session"><a href="#homeroom-session" class="headerlink" title="homeroom session"></a>homeroom session</h2><p>班会<br>【homeroom】 n.指导教室<br>【session】 n. 期间, 开庭期, 会议, 学期 [计] 会话, 对话, 会晤, 通用任务程序 名词复数形式: sessions;</p>
<h2 id="semester"><a href="#semester" class="headerlink" title="semester"></a>semester</h2><p>n.学期<br>2 weeks have passed since the beginning of the second semester of senior 3.</p>
<h2 id="mobilization"><a href="#mobilization" class="headerlink" title="mobilization"></a>mobilization</h2><p>n.动员<br>Today is the mobilization of Gaokao.</p>
<h2 id="provincial"><a href="#provincial" class="headerlink" title="provincial"></a>provincial</h2><p>n.外地人 a.外地的、省的<br>as the provincial key school</p>
<h2 id="indolence"><a href="#indolence" class="headerlink" title="indolence"></a>indolence</h2><p>【indolence】 n. 怠惰, 无痛 [医] 无痛<br>I don’t want to see anybody living a life of regret for some temporary indolence.</p>
<h2 id="break-out-in-cold-sweat"><a href="#break-out-in-cold-sweat" class="headerlink" title="break out in cold sweat"></a>break out in cold sweat</h2><p>布满冷汗<br>break out 爆发<br>break out in sth 布满···<br>I broke out in cold sweat just now.</p>
<h2 id="intimidation"><a href="#intimidation" class="headerlink" title="intimidation"></a>intimidation</h2><p>【intimidation】 n. 恐吓, 威胁 [法] 恐吓, 威胁 名词复数形式: intimidations;<br>【intimidate】 vt. 威胁, 恐吓 [法] 恐吓, 威胁, 使恐惧 过去分词: intimidated; 过去式: intimidated; 第三人称单数: intimidates; 现在分词: intimidating;</p>
<h2 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h2><p>【arena】 n. 角斗场, 舞台, 场地 [医] 尿沉渣, 尿沙; 脑沙 名词复数形式: arenas;</p>
<h2 id="downright"><a href="#downright" class="headerlink" title="downright"></a>downright</h2><p>【downright】 a. 明白的, 率直的, 十足的 adv. 全然, 彻底, 完全=fully<br>My soul is downright burning.</p>
<h2 id="combustible"><a href="#combustible" class="headerlink" title="combustible"></a>combustible</h2><p>【combustible】 a. 易燃的, 燃烧性的, 易动激情的 n. 易燃物, 可燃物 名词复数形式: combustibles;<br>Your soul is combustible?</p>
<h2 id="coma"><a href="#coma" class="headerlink" title="coma"></a>coma</h2><p>【coma】 n. 昏迷, 麻木, 彗发 [化] 彗差; 彗形像差 名词复数形式: comas;<br>fall into a coma </p>
<h2 id="plausible"><a href="#plausible" class="headerlink" title="plausible"></a>plausible</h2><p>【plausible】 a. 貌似真实的, 貌似合理的, 说得煞有其事的 [法] 花言巧语的, 似乎有理的<br>似是而非的</p>
<h2 id="tuck-yourself"><a href="#tuck-yourself" class="headerlink" title="tuck yourself"></a>tuck yourself</h2><p>照顾好自己<br>【tuck】 n. 缝褶, 活力, 鼓声, 船尾突出部, 食品 vt. 打褶, 卷起, 挤进, 塞, 收藏 vi. 缝褶裥, 缩拢 过去分词: tucked; 过去式: tucked; 现在分词: tucking; 第三人称单数: tucks; 名词复数形式: tucks;</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>编程小技巧</title>
    <url>/2022/01/30/%E7%BC%96%E7%A8%8B%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="编程小技巧"><a href="#编程小技巧" class="headerlink" title="编程小技巧"></a><em><strong>编程小技巧</strong></em></h1><p>  1、<cstdio>的编译速度比<iostream><br>  2、要求保留几位小数时，用printf更好因为用setprecision还要用<iomanip><br>  3、4/3会默认整除，可以改成4/3.0<br>  4、string要用<string><br>  5、cout默认输出会有一个有效值，超过了会用科学计数法表示<br>  比如<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; a/0.5 &lt;&lt; endl;</span><br></pre></td></tr></table></figure><br>  假如a=15312346,输出会是一个科学计数法表示的数字，这时我们强制int输出就能得到一般表示。<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; (int)(a/0.5) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><br>  6.带权值的问题，比如a,b,c,d四个数，权值大小分别是2，3，4，1，求平均值？<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">media=(a*2+b*3+c*4+d*1)/(2+3+4+1)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
</search>
